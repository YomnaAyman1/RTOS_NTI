
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007c46  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00007c46  00007cda  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000647  0080006e  0080006e  00007ce8  2**0
                  ALLOC
  3 .stab         00009edc  00000000  00000000  00007ce8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000605d  00000000  00000000  00011bc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00017c21  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  00017d81  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  00017f10  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  00019f55  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  0001b056  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  0001bfd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  0001c158  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  0001c41a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001cca8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 c5 31 	jmp	0x638a	; 0x638a <__vector_6>
      1c:	0c 94 a0 09 	jmp	0x1340	; 0x1340 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e4       	ldi	r30, 0x46	; 70
      68:	fc e7       	ldi	r31, 0x7C	; 124
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 3b       	cpi	r26, 0xB5	; 181
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 0a 3d 	call	0x7a14	; 0x7a14 <main>
      8a:	0c 94 21 3e 	jmp	0x7c42	; 0x7c42 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 a9 3d 	jmp	0x7b52	; 0x7b52 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e6       	ldi	r26, 0x65	; 101
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 c5 3d 	jmp	0x7b8a	; 0x7b8a <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 b5 3d 	jmp	0x7b6a	; 0x7b6a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 d1 3d 	jmp	0x7ba2	; 0x7ba2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 b5 3d 	jmp	0x7b6a	; 0x7b6a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 d1 3d 	jmp	0x7ba2	; 0x7ba2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 a9 3d 	jmp	0x7b52	; 0x7b52 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e6       	ldi	r24, 0x65	; 101
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 c5 3d 	jmp	0x7b8a	; 0x7b8a <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 b1 3d 	jmp	0x7b62	; 0x7b62 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	65 e6       	ldi	r22, 0x65	; 101
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 cd 3d 	jmp	0x7b9a	; 0x7b9a <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 b5 3d 	jmp	0x7b6a	; 0x7b6a <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 d1 3d 	jmp	0x7ba2	; 0x7ba2 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 b5 3d 	jmp	0x7b6a	; 0x7b6a <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 d1 3d 	jmp	0x7ba2	; 0x7ba2 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 b5 3d 	jmp	0x7b6a	; 0x7b6a <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 d1 3d 	jmp	0x7ba2	; 0x7ba2 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 d5 3d 	jmp	0x7baa	; 0x7baa <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	00 d0       	rcall	.+0      	; 0xca4 <pvPortMalloc+0x6>
     ca4:	00 d0       	rcall	.+0      	; 0xca6 <pvPortMalloc+0x8>
     ca6:	cd b7       	in	r28, 0x3d	; 61
     ca8:	de b7       	in	r29, 0x3e	; 62
     caa:	9c 83       	std	Y+4, r25	; 0x04
     cac:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
     cae:	1a 82       	std	Y+2, r1	; 0x02
     cb0:	19 82       	std	Y+1, r1	; 0x01
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
     cb2:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
     cb6:	80 91 70 00 	lds	r24, 0x0070
     cba:	90 91 71 00 	lds	r25, 0x0071
     cbe:	00 97       	sbiw	r24, 0x00	; 0
     cc0:	31 f4       	brne	.+12     	; 0xcce <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     cc2:	82 e7       	ldi	r24, 0x72	; 114
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	90 93 71 00 	sts	0x0071, r25
     cca:	80 93 70 00 	sts	0x0070, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
     cce:	8b 81       	ldd	r24, Y+3	; 0x03
     cd0:	9c 81       	ldd	r25, Y+4	; 0x04
     cd2:	00 97       	sbiw	r24, 0x00	; 0
     cd4:	99 f1       	breq	.+102    	; 0xd3c <pvPortMalloc+0x9e>
     cd6:	80 91 6e 00 	lds	r24, 0x006E
     cda:	90 91 6f 00 	lds	r25, 0x006F
     cde:	2b 81       	ldd	r18, Y+3	; 0x03
     ce0:	3c 81       	ldd	r19, Y+4	; 0x04
     ce2:	82 0f       	add	r24, r18
     ce4:	93 1f       	adc	r25, r19
     ce6:	25 e0       	ldi	r18, 0x05	; 5
     ce8:	8b 3d       	cpi	r24, 0xDB	; 219
     cea:	92 07       	cpc	r25, r18
     cec:	38 f5       	brcc	.+78     	; 0xd3c <pvPortMalloc+0x9e>
     cee:	20 91 6e 00 	lds	r18, 0x006E
     cf2:	30 91 6f 00 	lds	r19, 0x006F
     cf6:	8b 81       	ldd	r24, Y+3	; 0x03
     cf8:	9c 81       	ldd	r25, Y+4	; 0x04
     cfa:	28 0f       	add	r18, r24
     cfc:	39 1f       	adc	r19, r25
     cfe:	80 91 6e 00 	lds	r24, 0x006E
     d02:	90 91 6f 00 	lds	r25, 0x006F
     d06:	82 17       	cp	r24, r18
     d08:	93 07       	cpc	r25, r19
     d0a:	c0 f4       	brcc	.+48     	; 0xd3c <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     d0c:	20 91 70 00 	lds	r18, 0x0070
     d10:	30 91 71 00 	lds	r19, 0x0071
     d14:	80 91 6e 00 	lds	r24, 0x006E
     d18:	90 91 6f 00 	lds	r25, 0x006F
     d1c:	82 0f       	add	r24, r18
     d1e:	93 1f       	adc	r25, r19
     d20:	9a 83       	std	Y+2, r25	; 0x02
     d22:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     d24:	20 91 6e 00 	lds	r18, 0x006E
     d28:	30 91 6f 00 	lds	r19, 0x006F
     d2c:	8b 81       	ldd	r24, Y+3	; 0x03
     d2e:	9c 81       	ldd	r25, Y+4	; 0x04
     d30:	82 0f       	add	r24, r18
     d32:	93 1f       	adc	r25, r19
     d34:	90 93 6f 00 	sts	0x006F, r25
     d38:	80 93 6e 00 	sts	0x006E, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     d3c:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
     d40:	89 81       	ldd	r24, Y+1	; 0x01
     d42:	9a 81       	ldd	r25, Y+2	; 0x02
}
     d44:	0f 90       	pop	r0
     d46:	0f 90       	pop	r0
     d48:	0f 90       	pop	r0
     d4a:	0f 90       	pop	r0
     d4c:	cf 91       	pop	r28
     d4e:	df 91       	pop	r29
     d50:	08 95       	ret

00000d52 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     d52:	df 93       	push	r29
     d54:	cf 93       	push	r28
     d56:	00 d0       	rcall	.+0      	; 0xd58 <vPortFree+0x6>
     d58:	cd b7       	in	r28, 0x3d	; 61
     d5a:	de b7       	in	r29, 0x3e	; 62
     d5c:	9a 83       	std	Y+2, r25	; 0x02
     d5e:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     d60:	0f 90       	pop	r0
     d62:	0f 90       	pop	r0
     d64:	cf 91       	pop	r28
     d66:	df 91       	pop	r29
     d68:	08 95       	ret

00000d6a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     d6a:	df 93       	push	r29
     d6c:	cf 93       	push	r28
     d6e:	cd b7       	in	r28, 0x3d	; 61
     d70:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     d72:	10 92 6f 00 	sts	0x006F, r1
     d76:	10 92 6e 00 	sts	0x006E, r1
}
     d7a:	cf 91       	pop	r28
     d7c:	df 91       	pop	r29
     d7e:	08 95       	ret

00000d80 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     d80:	df 93       	push	r29
     d82:	cf 93       	push	r28
     d84:	cd b7       	in	r28, 0x3d	; 61
     d86:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     d88:	20 91 6e 00 	lds	r18, 0x006E
     d8c:	30 91 6f 00 	lds	r19, 0x006F
     d90:	8b ed       	ldi	r24, 0xDB	; 219
     d92:	95 e0       	ldi	r25, 0x05	; 5
     d94:	82 1b       	sub	r24, r18
     d96:	93 0b       	sbc	r25, r19
}
     d98:	cf 91       	pop	r28
     d9a:	df 91       	pop	r29
     d9c:	08 95       	ret

00000d9e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	cd b7       	in	r28, 0x3d	; 61
     da4:	de b7       	in	r29, 0x3e	; 62
     da6:	28 97       	sbiw	r28, 0x08	; 8
     da8:	0f b6       	in	r0, 0x3f	; 63
     daa:	f8 94       	cli
     dac:	de bf       	out	0x3e, r29	; 62
     dae:	0f be       	out	0x3f, r0	; 63
     db0:	cd bf       	out	0x3d, r28	; 61
     db2:	9c 83       	std	Y+4, r25	; 0x04
     db4:	8b 83       	std	Y+3, r24	; 0x03
     db6:	7e 83       	std	Y+6, r23	; 0x06
     db8:	6d 83       	std	Y+5, r22	; 0x05
     dba:	58 87       	std	Y+8, r21	; 0x08
     dbc:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     dbe:	eb 81       	ldd	r30, Y+3	; 0x03
     dc0:	fc 81       	ldd	r31, Y+4	; 0x04
     dc2:	81 e1       	ldi	r24, 0x11	; 17
     dc4:	80 83       	st	Z, r24
	pxTopOfStack--;
     dc6:	8b 81       	ldd	r24, Y+3	; 0x03
     dc8:	9c 81       	ldd	r25, Y+4	; 0x04
     dca:	01 97       	sbiw	r24, 0x01	; 1
     dcc:	9c 83       	std	Y+4, r25	; 0x04
     dce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     dd0:	eb 81       	ldd	r30, Y+3	; 0x03
     dd2:	fc 81       	ldd	r31, Y+4	; 0x04
     dd4:	82 e2       	ldi	r24, 0x22	; 34
     dd6:	80 83       	st	Z, r24
	pxTopOfStack--;
     dd8:	8b 81       	ldd	r24, Y+3	; 0x03
     dda:	9c 81       	ldd	r25, Y+4	; 0x04
     ddc:	01 97       	sbiw	r24, 0x01	; 1
     dde:	9c 83       	std	Y+4, r25	; 0x04
     de0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     de2:	eb 81       	ldd	r30, Y+3	; 0x03
     de4:	fc 81       	ldd	r31, Y+4	; 0x04
     de6:	83 e3       	ldi	r24, 0x33	; 51
     de8:	80 83       	st	Z, r24
	pxTopOfStack--;
     dea:	8b 81       	ldd	r24, Y+3	; 0x03
     dec:	9c 81       	ldd	r25, Y+4	; 0x04
     dee:	01 97       	sbiw	r24, 0x01	; 1
     df0:	9c 83       	std	Y+4, r25	; 0x04
     df2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     df4:	8d 81       	ldd	r24, Y+5	; 0x05
     df6:	9e 81       	ldd	r25, Y+6	; 0x06
     df8:	9a 83       	std	Y+2, r25	; 0x02
     dfa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     dfc:	89 81       	ldd	r24, Y+1	; 0x01
     dfe:	eb 81       	ldd	r30, Y+3	; 0x03
     e00:	fc 81       	ldd	r31, Y+4	; 0x04
     e02:	80 83       	st	Z, r24
	pxTopOfStack--;
     e04:	8b 81       	ldd	r24, Y+3	; 0x03
     e06:	9c 81       	ldd	r25, Y+4	; 0x04
     e08:	01 97       	sbiw	r24, 0x01	; 1
     e0a:	9c 83       	std	Y+4, r25	; 0x04
     e0c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     e0e:	89 81       	ldd	r24, Y+1	; 0x01
     e10:	9a 81       	ldd	r25, Y+2	; 0x02
     e12:	89 2f       	mov	r24, r25
     e14:	99 27       	eor	r25, r25
     e16:	9a 83       	std	Y+2, r25	; 0x02
     e18:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     e1a:	89 81       	ldd	r24, Y+1	; 0x01
     e1c:	eb 81       	ldd	r30, Y+3	; 0x03
     e1e:	fc 81       	ldd	r31, Y+4	; 0x04
     e20:	80 83       	st	Z, r24
	pxTopOfStack--;
     e22:	8b 81       	ldd	r24, Y+3	; 0x03
     e24:	9c 81       	ldd	r25, Y+4	; 0x04
     e26:	01 97       	sbiw	r24, 0x01	; 1
     e28:	9c 83       	std	Y+4, r25	; 0x04
     e2a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     e2c:	eb 81       	ldd	r30, Y+3	; 0x03
     e2e:	fc 81       	ldd	r31, Y+4	; 0x04
     e30:	10 82       	st	Z, r1
	pxTopOfStack--;
     e32:	8b 81       	ldd	r24, Y+3	; 0x03
     e34:	9c 81       	ldd	r25, Y+4	; 0x04
     e36:	01 97       	sbiw	r24, 0x01	; 1
     e38:	9c 83       	std	Y+4, r25	; 0x04
     e3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     e3c:	eb 81       	ldd	r30, Y+3	; 0x03
     e3e:	fc 81       	ldd	r31, Y+4	; 0x04
     e40:	80 e8       	ldi	r24, 0x80	; 128
     e42:	80 83       	st	Z, r24
	pxTopOfStack--;
     e44:	8b 81       	ldd	r24, Y+3	; 0x03
     e46:	9c 81       	ldd	r25, Y+4	; 0x04
     e48:	01 97       	sbiw	r24, 0x01	; 1
     e4a:	9c 83       	std	Y+4, r25	; 0x04
     e4c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     e4e:	eb 81       	ldd	r30, Y+3	; 0x03
     e50:	fc 81       	ldd	r31, Y+4	; 0x04
     e52:	10 82       	st	Z, r1
	pxTopOfStack--;
     e54:	8b 81       	ldd	r24, Y+3	; 0x03
     e56:	9c 81       	ldd	r25, Y+4	; 0x04
     e58:	01 97       	sbiw	r24, 0x01	; 1
     e5a:	9c 83       	std	Y+4, r25	; 0x04
     e5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     e5e:	eb 81       	ldd	r30, Y+3	; 0x03
     e60:	fc 81       	ldd	r31, Y+4	; 0x04
     e62:	82 e0       	ldi	r24, 0x02	; 2
     e64:	80 83       	st	Z, r24
	pxTopOfStack--;
     e66:	8b 81       	ldd	r24, Y+3	; 0x03
     e68:	9c 81       	ldd	r25, Y+4	; 0x04
     e6a:	01 97       	sbiw	r24, 0x01	; 1
     e6c:	9c 83       	std	Y+4, r25	; 0x04
     e6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     e70:	eb 81       	ldd	r30, Y+3	; 0x03
     e72:	fc 81       	ldd	r31, Y+4	; 0x04
     e74:	83 e0       	ldi	r24, 0x03	; 3
     e76:	80 83       	st	Z, r24
	pxTopOfStack--;
     e78:	8b 81       	ldd	r24, Y+3	; 0x03
     e7a:	9c 81       	ldd	r25, Y+4	; 0x04
     e7c:	01 97       	sbiw	r24, 0x01	; 1
     e7e:	9c 83       	std	Y+4, r25	; 0x04
     e80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     e82:	eb 81       	ldd	r30, Y+3	; 0x03
     e84:	fc 81       	ldd	r31, Y+4	; 0x04
     e86:	84 e0       	ldi	r24, 0x04	; 4
     e88:	80 83       	st	Z, r24
	pxTopOfStack--;
     e8a:	8b 81       	ldd	r24, Y+3	; 0x03
     e8c:	9c 81       	ldd	r25, Y+4	; 0x04
     e8e:	01 97       	sbiw	r24, 0x01	; 1
     e90:	9c 83       	std	Y+4, r25	; 0x04
     e92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     e94:	eb 81       	ldd	r30, Y+3	; 0x03
     e96:	fc 81       	ldd	r31, Y+4	; 0x04
     e98:	85 e0       	ldi	r24, 0x05	; 5
     e9a:	80 83       	st	Z, r24
	pxTopOfStack--;
     e9c:	8b 81       	ldd	r24, Y+3	; 0x03
     e9e:	9c 81       	ldd	r25, Y+4	; 0x04
     ea0:	01 97       	sbiw	r24, 0x01	; 1
     ea2:	9c 83       	std	Y+4, r25	; 0x04
     ea4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     ea6:	eb 81       	ldd	r30, Y+3	; 0x03
     ea8:	fc 81       	ldd	r31, Y+4	; 0x04
     eaa:	86 e0       	ldi	r24, 0x06	; 6
     eac:	80 83       	st	Z, r24
	pxTopOfStack--;
     eae:	8b 81       	ldd	r24, Y+3	; 0x03
     eb0:	9c 81       	ldd	r25, Y+4	; 0x04
     eb2:	01 97       	sbiw	r24, 0x01	; 1
     eb4:	9c 83       	std	Y+4, r25	; 0x04
     eb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     eb8:	eb 81       	ldd	r30, Y+3	; 0x03
     eba:	fc 81       	ldd	r31, Y+4	; 0x04
     ebc:	87 e0       	ldi	r24, 0x07	; 7
     ebe:	80 83       	st	Z, r24
	pxTopOfStack--;
     ec0:	8b 81       	ldd	r24, Y+3	; 0x03
     ec2:	9c 81       	ldd	r25, Y+4	; 0x04
     ec4:	01 97       	sbiw	r24, 0x01	; 1
     ec6:	9c 83       	std	Y+4, r25	; 0x04
     ec8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     eca:	eb 81       	ldd	r30, Y+3	; 0x03
     ecc:	fc 81       	ldd	r31, Y+4	; 0x04
     ece:	88 e0       	ldi	r24, 0x08	; 8
     ed0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ed2:	8b 81       	ldd	r24, Y+3	; 0x03
     ed4:	9c 81       	ldd	r25, Y+4	; 0x04
     ed6:	01 97       	sbiw	r24, 0x01	; 1
     ed8:	9c 83       	std	Y+4, r25	; 0x04
     eda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     edc:	eb 81       	ldd	r30, Y+3	; 0x03
     ede:	fc 81       	ldd	r31, Y+4	; 0x04
     ee0:	89 e0       	ldi	r24, 0x09	; 9
     ee2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ee4:	8b 81       	ldd	r24, Y+3	; 0x03
     ee6:	9c 81       	ldd	r25, Y+4	; 0x04
     ee8:	01 97       	sbiw	r24, 0x01	; 1
     eea:	9c 83       	std	Y+4, r25	; 0x04
     eec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     eee:	eb 81       	ldd	r30, Y+3	; 0x03
     ef0:	fc 81       	ldd	r31, Y+4	; 0x04
     ef2:	80 e1       	ldi	r24, 0x10	; 16
     ef4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ef6:	8b 81       	ldd	r24, Y+3	; 0x03
     ef8:	9c 81       	ldd	r25, Y+4	; 0x04
     efa:	01 97       	sbiw	r24, 0x01	; 1
     efc:	9c 83       	std	Y+4, r25	; 0x04
     efe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     f00:	eb 81       	ldd	r30, Y+3	; 0x03
     f02:	fc 81       	ldd	r31, Y+4	; 0x04
     f04:	81 e1       	ldi	r24, 0x11	; 17
     f06:	80 83       	st	Z, r24
	pxTopOfStack--;
     f08:	8b 81       	ldd	r24, Y+3	; 0x03
     f0a:	9c 81       	ldd	r25, Y+4	; 0x04
     f0c:	01 97       	sbiw	r24, 0x01	; 1
     f0e:	9c 83       	std	Y+4, r25	; 0x04
     f10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     f12:	eb 81       	ldd	r30, Y+3	; 0x03
     f14:	fc 81       	ldd	r31, Y+4	; 0x04
     f16:	82 e1       	ldi	r24, 0x12	; 18
     f18:	80 83       	st	Z, r24
	pxTopOfStack--;
     f1a:	8b 81       	ldd	r24, Y+3	; 0x03
     f1c:	9c 81       	ldd	r25, Y+4	; 0x04
     f1e:	01 97       	sbiw	r24, 0x01	; 1
     f20:	9c 83       	std	Y+4, r25	; 0x04
     f22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     f24:	eb 81       	ldd	r30, Y+3	; 0x03
     f26:	fc 81       	ldd	r31, Y+4	; 0x04
     f28:	83 e1       	ldi	r24, 0x13	; 19
     f2a:	80 83       	st	Z, r24
	pxTopOfStack--;
     f2c:	8b 81       	ldd	r24, Y+3	; 0x03
     f2e:	9c 81       	ldd	r25, Y+4	; 0x04
     f30:	01 97       	sbiw	r24, 0x01	; 1
     f32:	9c 83       	std	Y+4, r25	; 0x04
     f34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     f36:	eb 81       	ldd	r30, Y+3	; 0x03
     f38:	fc 81       	ldd	r31, Y+4	; 0x04
     f3a:	84 e1       	ldi	r24, 0x14	; 20
     f3c:	80 83       	st	Z, r24
	pxTopOfStack--;
     f3e:	8b 81       	ldd	r24, Y+3	; 0x03
     f40:	9c 81       	ldd	r25, Y+4	; 0x04
     f42:	01 97       	sbiw	r24, 0x01	; 1
     f44:	9c 83       	std	Y+4, r25	; 0x04
     f46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     f48:	eb 81       	ldd	r30, Y+3	; 0x03
     f4a:	fc 81       	ldd	r31, Y+4	; 0x04
     f4c:	85 e1       	ldi	r24, 0x15	; 21
     f4e:	80 83       	st	Z, r24
	pxTopOfStack--;
     f50:	8b 81       	ldd	r24, Y+3	; 0x03
     f52:	9c 81       	ldd	r25, Y+4	; 0x04
     f54:	01 97       	sbiw	r24, 0x01	; 1
     f56:	9c 83       	std	Y+4, r25	; 0x04
     f58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     f5a:	eb 81       	ldd	r30, Y+3	; 0x03
     f5c:	fc 81       	ldd	r31, Y+4	; 0x04
     f5e:	86 e1       	ldi	r24, 0x16	; 22
     f60:	80 83       	st	Z, r24
	pxTopOfStack--;
     f62:	8b 81       	ldd	r24, Y+3	; 0x03
     f64:	9c 81       	ldd	r25, Y+4	; 0x04
     f66:	01 97       	sbiw	r24, 0x01	; 1
     f68:	9c 83       	std	Y+4, r25	; 0x04
     f6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     f6c:	eb 81       	ldd	r30, Y+3	; 0x03
     f6e:	fc 81       	ldd	r31, Y+4	; 0x04
     f70:	87 e1       	ldi	r24, 0x17	; 23
     f72:	80 83       	st	Z, r24
	pxTopOfStack--;
     f74:	8b 81       	ldd	r24, Y+3	; 0x03
     f76:	9c 81       	ldd	r25, Y+4	; 0x04
     f78:	01 97       	sbiw	r24, 0x01	; 1
     f7a:	9c 83       	std	Y+4, r25	; 0x04
     f7c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     f7e:	eb 81       	ldd	r30, Y+3	; 0x03
     f80:	fc 81       	ldd	r31, Y+4	; 0x04
     f82:	88 e1       	ldi	r24, 0x18	; 24
     f84:	80 83       	st	Z, r24
	pxTopOfStack--;
     f86:	8b 81       	ldd	r24, Y+3	; 0x03
     f88:	9c 81       	ldd	r25, Y+4	; 0x04
     f8a:	01 97       	sbiw	r24, 0x01	; 1
     f8c:	9c 83       	std	Y+4, r25	; 0x04
     f8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     f90:	eb 81       	ldd	r30, Y+3	; 0x03
     f92:	fc 81       	ldd	r31, Y+4	; 0x04
     f94:	89 e1       	ldi	r24, 0x19	; 25
     f96:	80 83       	st	Z, r24
	pxTopOfStack--;
     f98:	8b 81       	ldd	r24, Y+3	; 0x03
     f9a:	9c 81       	ldd	r25, Y+4	; 0x04
     f9c:	01 97       	sbiw	r24, 0x01	; 1
     f9e:	9c 83       	std	Y+4, r25	; 0x04
     fa0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     fa2:	eb 81       	ldd	r30, Y+3	; 0x03
     fa4:	fc 81       	ldd	r31, Y+4	; 0x04
     fa6:	80 e2       	ldi	r24, 0x20	; 32
     fa8:	80 83       	st	Z, r24
	pxTopOfStack--;
     faa:	8b 81       	ldd	r24, Y+3	; 0x03
     fac:	9c 81       	ldd	r25, Y+4	; 0x04
     fae:	01 97       	sbiw	r24, 0x01	; 1
     fb0:	9c 83       	std	Y+4, r25	; 0x04
     fb2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     fb4:	eb 81       	ldd	r30, Y+3	; 0x03
     fb6:	fc 81       	ldd	r31, Y+4	; 0x04
     fb8:	81 e2       	ldi	r24, 0x21	; 33
     fba:	80 83       	st	Z, r24
	pxTopOfStack--;
     fbc:	8b 81       	ldd	r24, Y+3	; 0x03
     fbe:	9c 81       	ldd	r25, Y+4	; 0x04
     fc0:	01 97       	sbiw	r24, 0x01	; 1
     fc2:	9c 83       	std	Y+4, r25	; 0x04
     fc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     fc6:	eb 81       	ldd	r30, Y+3	; 0x03
     fc8:	fc 81       	ldd	r31, Y+4	; 0x04
     fca:	82 e2       	ldi	r24, 0x22	; 34
     fcc:	80 83       	st	Z, r24
	pxTopOfStack--;
     fce:	8b 81       	ldd	r24, Y+3	; 0x03
     fd0:	9c 81       	ldd	r25, Y+4	; 0x04
     fd2:	01 97       	sbiw	r24, 0x01	; 1
     fd4:	9c 83       	std	Y+4, r25	; 0x04
     fd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     fd8:	eb 81       	ldd	r30, Y+3	; 0x03
     fda:	fc 81       	ldd	r31, Y+4	; 0x04
     fdc:	83 e2       	ldi	r24, 0x23	; 35
     fde:	80 83       	st	Z, r24
	pxTopOfStack--;
     fe0:	8b 81       	ldd	r24, Y+3	; 0x03
     fe2:	9c 81       	ldd	r25, Y+4	; 0x04
     fe4:	01 97       	sbiw	r24, 0x01	; 1
     fe6:	9c 83       	std	Y+4, r25	; 0x04
     fe8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     fea:	8f 81       	ldd	r24, Y+7	; 0x07
     fec:	98 85       	ldd	r25, Y+8	; 0x08
     fee:	9a 83       	std	Y+2, r25	; 0x02
     ff0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ff2:	89 81       	ldd	r24, Y+1	; 0x01
     ff4:	eb 81       	ldd	r30, Y+3	; 0x03
     ff6:	fc 81       	ldd	r31, Y+4	; 0x04
     ff8:	80 83       	st	Z, r24
	pxTopOfStack--;
     ffa:	8b 81       	ldd	r24, Y+3	; 0x03
     ffc:	9c 81       	ldd	r25, Y+4	; 0x04
     ffe:	01 97       	sbiw	r24, 0x01	; 1
    1000:	9c 83       	std	Y+4, r25	; 0x04
    1002:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1004:	89 81       	ldd	r24, Y+1	; 0x01
    1006:	9a 81       	ldd	r25, Y+2	; 0x02
    1008:	89 2f       	mov	r24, r25
    100a:	99 27       	eor	r25, r25
    100c:	9a 83       	std	Y+2, r25	; 0x02
    100e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1010:	89 81       	ldd	r24, Y+1	; 0x01
    1012:	eb 81       	ldd	r30, Y+3	; 0x03
    1014:	fc 81       	ldd	r31, Y+4	; 0x04
    1016:	80 83       	st	Z, r24
	pxTopOfStack--;
    1018:	8b 81       	ldd	r24, Y+3	; 0x03
    101a:	9c 81       	ldd	r25, Y+4	; 0x04
    101c:	01 97       	sbiw	r24, 0x01	; 1
    101e:	9c 83       	std	Y+4, r25	; 0x04
    1020:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1022:	eb 81       	ldd	r30, Y+3	; 0x03
    1024:	fc 81       	ldd	r31, Y+4	; 0x04
    1026:	86 e2       	ldi	r24, 0x26	; 38
    1028:	80 83       	st	Z, r24
	pxTopOfStack--;
    102a:	8b 81       	ldd	r24, Y+3	; 0x03
    102c:	9c 81       	ldd	r25, Y+4	; 0x04
    102e:	01 97       	sbiw	r24, 0x01	; 1
    1030:	9c 83       	std	Y+4, r25	; 0x04
    1032:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1034:	eb 81       	ldd	r30, Y+3	; 0x03
    1036:	fc 81       	ldd	r31, Y+4	; 0x04
    1038:	87 e2       	ldi	r24, 0x27	; 39
    103a:	80 83       	st	Z, r24
	pxTopOfStack--;
    103c:	8b 81       	ldd	r24, Y+3	; 0x03
    103e:	9c 81       	ldd	r25, Y+4	; 0x04
    1040:	01 97       	sbiw	r24, 0x01	; 1
    1042:	9c 83       	std	Y+4, r25	; 0x04
    1044:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1046:	eb 81       	ldd	r30, Y+3	; 0x03
    1048:	fc 81       	ldd	r31, Y+4	; 0x04
    104a:	88 e2       	ldi	r24, 0x28	; 40
    104c:	80 83       	st	Z, r24
	pxTopOfStack--;
    104e:	8b 81       	ldd	r24, Y+3	; 0x03
    1050:	9c 81       	ldd	r25, Y+4	; 0x04
    1052:	01 97       	sbiw	r24, 0x01	; 1
    1054:	9c 83       	std	Y+4, r25	; 0x04
    1056:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1058:	eb 81       	ldd	r30, Y+3	; 0x03
    105a:	fc 81       	ldd	r31, Y+4	; 0x04
    105c:	89 e2       	ldi	r24, 0x29	; 41
    105e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1060:	8b 81       	ldd	r24, Y+3	; 0x03
    1062:	9c 81       	ldd	r25, Y+4	; 0x04
    1064:	01 97       	sbiw	r24, 0x01	; 1
    1066:	9c 83       	std	Y+4, r25	; 0x04
    1068:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    106a:	eb 81       	ldd	r30, Y+3	; 0x03
    106c:	fc 81       	ldd	r31, Y+4	; 0x04
    106e:	80 e3       	ldi	r24, 0x30	; 48
    1070:	80 83       	st	Z, r24
	pxTopOfStack--;
    1072:	8b 81       	ldd	r24, Y+3	; 0x03
    1074:	9c 81       	ldd	r25, Y+4	; 0x04
    1076:	01 97       	sbiw	r24, 0x01	; 1
    1078:	9c 83       	std	Y+4, r25	; 0x04
    107a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    107c:	eb 81       	ldd	r30, Y+3	; 0x03
    107e:	fc 81       	ldd	r31, Y+4	; 0x04
    1080:	81 e3       	ldi	r24, 0x31	; 49
    1082:	80 83       	st	Z, r24
	pxTopOfStack--;
    1084:	8b 81       	ldd	r24, Y+3	; 0x03
    1086:	9c 81       	ldd	r25, Y+4	; 0x04
    1088:	01 97       	sbiw	r24, 0x01	; 1
    108a:	9c 83       	std	Y+4, r25	; 0x04
    108c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    108e:	8b 81       	ldd	r24, Y+3	; 0x03
    1090:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1092:	28 96       	adiw	r28, 0x08	; 8
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	de bf       	out	0x3e, r29	; 62
    109a:	0f be       	out	0x3f, r0	; 63
    109c:	cd bf       	out	0x3d, r28	; 61
    109e:	cf 91       	pop	r28
    10a0:	df 91       	pop	r29
    10a2:	08 95       	ret

000010a4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    10a4:	df 93       	push	r29
    10a6:	cf 93       	push	r28
    10a8:	cd b7       	in	r28, 0x3d	; 61
    10aa:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    10ac:	0e 94 44 09 	call	0x1288	; 0x1288 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    10b0:	a0 91 4e 06 	lds	r26, 0x064E
    10b4:	b0 91 4f 06 	lds	r27, 0x064F
    10b8:	cd 91       	ld	r28, X+
    10ba:	cd bf       	out	0x3d, r28	; 61
    10bc:	dd 91       	ld	r29, X+
    10be:	de bf       	out	0x3e, r29	; 62
    10c0:	ff 91       	pop	r31
    10c2:	ef 91       	pop	r30
    10c4:	df 91       	pop	r29
    10c6:	cf 91       	pop	r28
    10c8:	bf 91       	pop	r27
    10ca:	af 91       	pop	r26
    10cc:	9f 91       	pop	r25
    10ce:	8f 91       	pop	r24
    10d0:	7f 91       	pop	r23
    10d2:	6f 91       	pop	r22
    10d4:	5f 91       	pop	r21
    10d6:	4f 91       	pop	r20
    10d8:	3f 91       	pop	r19
    10da:	2f 91       	pop	r18
    10dc:	1f 91       	pop	r17
    10de:	0f 91       	pop	r16
    10e0:	ff 90       	pop	r15
    10e2:	ef 90       	pop	r14
    10e4:	df 90       	pop	r13
    10e6:	cf 90       	pop	r12
    10e8:	bf 90       	pop	r11
    10ea:	af 90       	pop	r10
    10ec:	9f 90       	pop	r9
    10ee:	8f 90       	pop	r8
    10f0:	7f 90       	pop	r7
    10f2:	6f 90       	pop	r6
    10f4:	5f 90       	pop	r5
    10f6:	4f 90       	pop	r4
    10f8:	3f 90       	pop	r3
    10fa:	2f 90       	pop	r2
    10fc:	1f 90       	pop	r1
    10fe:	0f 90       	pop	r0
    1100:	0f be       	out	0x3f, r0	; 63
    1102:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1104:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1106:	81 e0       	ldi	r24, 0x01	; 1
}
    1108:	cf 91       	pop	r28
    110a:	df 91       	pop	r29
    110c:	08 95       	ret

0000110e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    110e:	df 93       	push	r29
    1110:	cf 93       	push	r28
    1112:	cd b7       	in	r28, 0x3d	; 61
    1114:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1116:	cf 91       	pop	r28
    1118:	df 91       	pop	r29
    111a:	08 95       	ret

0000111c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    111c:	0f 92       	push	r0
    111e:	0f b6       	in	r0, 0x3f	; 63
    1120:	f8 94       	cli
    1122:	0f 92       	push	r0
    1124:	1f 92       	push	r1
    1126:	11 24       	eor	r1, r1
    1128:	2f 92       	push	r2
    112a:	3f 92       	push	r3
    112c:	4f 92       	push	r4
    112e:	5f 92       	push	r5
    1130:	6f 92       	push	r6
    1132:	7f 92       	push	r7
    1134:	8f 92       	push	r8
    1136:	9f 92       	push	r9
    1138:	af 92       	push	r10
    113a:	bf 92       	push	r11
    113c:	cf 92       	push	r12
    113e:	df 92       	push	r13
    1140:	ef 92       	push	r14
    1142:	ff 92       	push	r15
    1144:	0f 93       	push	r16
    1146:	1f 93       	push	r17
    1148:	2f 93       	push	r18
    114a:	3f 93       	push	r19
    114c:	4f 93       	push	r20
    114e:	5f 93       	push	r21
    1150:	6f 93       	push	r22
    1152:	7f 93       	push	r23
    1154:	8f 93       	push	r24
    1156:	9f 93       	push	r25
    1158:	af 93       	push	r26
    115a:	bf 93       	push	r27
    115c:	cf 93       	push	r28
    115e:	df 93       	push	r29
    1160:	ef 93       	push	r30
    1162:	ff 93       	push	r31
    1164:	a0 91 4e 06 	lds	r26, 0x064E
    1168:	b0 91 4f 06 	lds	r27, 0x064F
    116c:	0d b6       	in	r0, 0x3d	; 61
    116e:	0d 92       	st	X+, r0
    1170:	0e b6       	in	r0, 0x3e	; 62
    1172:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1174:	0e 94 53 24 	call	0x48a6	; 0x48a6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1178:	a0 91 4e 06 	lds	r26, 0x064E
    117c:	b0 91 4f 06 	lds	r27, 0x064F
    1180:	cd 91       	ld	r28, X+
    1182:	cd bf       	out	0x3d, r28	; 61
    1184:	dd 91       	ld	r29, X+
    1186:	de bf       	out	0x3e, r29	; 62
    1188:	ff 91       	pop	r31
    118a:	ef 91       	pop	r30
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	bf 91       	pop	r27
    1192:	af 91       	pop	r26
    1194:	9f 91       	pop	r25
    1196:	8f 91       	pop	r24
    1198:	7f 91       	pop	r23
    119a:	6f 91       	pop	r22
    119c:	5f 91       	pop	r21
    119e:	4f 91       	pop	r20
    11a0:	3f 91       	pop	r19
    11a2:	2f 91       	pop	r18
    11a4:	1f 91       	pop	r17
    11a6:	0f 91       	pop	r16
    11a8:	ff 90       	pop	r15
    11aa:	ef 90       	pop	r14
    11ac:	df 90       	pop	r13
    11ae:	cf 90       	pop	r12
    11b0:	bf 90       	pop	r11
    11b2:	af 90       	pop	r10
    11b4:	9f 90       	pop	r9
    11b6:	8f 90       	pop	r8
    11b8:	7f 90       	pop	r7
    11ba:	6f 90       	pop	r6
    11bc:	5f 90       	pop	r5
    11be:	4f 90       	pop	r4
    11c0:	3f 90       	pop	r3
    11c2:	2f 90       	pop	r2
    11c4:	1f 90       	pop	r1
    11c6:	0f 90       	pop	r0
    11c8:	0f be       	out	0x3f, r0	; 63
    11ca:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11cc:	08 95       	ret

000011ce <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    11ce:	0f 92       	push	r0
    11d0:	0f b6       	in	r0, 0x3f	; 63
    11d2:	f8 94       	cli
    11d4:	0f 92       	push	r0
    11d6:	1f 92       	push	r1
    11d8:	11 24       	eor	r1, r1
    11da:	2f 92       	push	r2
    11dc:	3f 92       	push	r3
    11de:	4f 92       	push	r4
    11e0:	5f 92       	push	r5
    11e2:	6f 92       	push	r6
    11e4:	7f 92       	push	r7
    11e6:	8f 92       	push	r8
    11e8:	9f 92       	push	r9
    11ea:	af 92       	push	r10
    11ec:	bf 92       	push	r11
    11ee:	cf 92       	push	r12
    11f0:	df 92       	push	r13
    11f2:	ef 92       	push	r14
    11f4:	ff 92       	push	r15
    11f6:	0f 93       	push	r16
    11f8:	1f 93       	push	r17
    11fa:	2f 93       	push	r18
    11fc:	3f 93       	push	r19
    11fe:	4f 93       	push	r20
    1200:	5f 93       	push	r21
    1202:	6f 93       	push	r22
    1204:	7f 93       	push	r23
    1206:	8f 93       	push	r24
    1208:	9f 93       	push	r25
    120a:	af 93       	push	r26
    120c:	bf 93       	push	r27
    120e:	cf 93       	push	r28
    1210:	df 93       	push	r29
    1212:	ef 93       	push	r30
    1214:	ff 93       	push	r31
    1216:	a0 91 4e 06 	lds	r26, 0x064E
    121a:	b0 91 4f 06 	lds	r27, 0x064F
    121e:	0d b6       	in	r0, 0x3d	; 61
    1220:	0d 92       	st	X+, r0
    1222:	0e b6       	in	r0, 0x3e	; 62
    1224:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1226:	0e 94 bc 22 	call	0x4578	; 0x4578 <xTaskIncrementTick>
    122a:	88 23       	and	r24, r24
    122c:	11 f0       	breq	.+4      	; 0x1232 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    122e:	0e 94 53 24 	call	0x48a6	; 0x48a6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1232:	a0 91 4e 06 	lds	r26, 0x064E
    1236:	b0 91 4f 06 	lds	r27, 0x064F
    123a:	cd 91       	ld	r28, X+
    123c:	cd bf       	out	0x3d, r28	; 61
    123e:	dd 91       	ld	r29, X+
    1240:	de bf       	out	0x3e, r29	; 62
    1242:	ff 91       	pop	r31
    1244:	ef 91       	pop	r30
    1246:	df 91       	pop	r29
    1248:	cf 91       	pop	r28
    124a:	bf 91       	pop	r27
    124c:	af 91       	pop	r26
    124e:	9f 91       	pop	r25
    1250:	8f 91       	pop	r24
    1252:	7f 91       	pop	r23
    1254:	6f 91       	pop	r22
    1256:	5f 91       	pop	r21
    1258:	4f 91       	pop	r20
    125a:	3f 91       	pop	r19
    125c:	2f 91       	pop	r18
    125e:	1f 91       	pop	r17
    1260:	0f 91       	pop	r16
    1262:	ff 90       	pop	r15
    1264:	ef 90       	pop	r14
    1266:	df 90       	pop	r13
    1268:	cf 90       	pop	r12
    126a:	bf 90       	pop	r11
    126c:	af 90       	pop	r10
    126e:	9f 90       	pop	r9
    1270:	8f 90       	pop	r8
    1272:	7f 90       	pop	r7
    1274:	6f 90       	pop	r6
    1276:	5f 90       	pop	r5
    1278:	4f 90       	pop	r4
    127a:	3f 90       	pop	r3
    127c:	2f 90       	pop	r2
    127e:	1f 90       	pop	r1
    1280:	0f 90       	pop	r0
    1282:	0f be       	out	0x3f, r0	; 63
    1284:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1286:	08 95       	ret

00001288 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1288:	df 93       	push	r29
    128a:	cf 93       	push	r28
    128c:	00 d0       	rcall	.+0      	; 0x128e <prvSetupTimerInterrupt+0x6>
    128e:	00 d0       	rcall	.+0      	; 0x1290 <prvSetupTimerInterrupt+0x8>
    1290:	00 d0       	rcall	.+0      	; 0x1292 <prvSetupTimerInterrupt+0xa>
    1292:	cd b7       	in	r28, 0x3d	; 61
    1294:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1296:	80 e4       	ldi	r24, 0x40	; 64
    1298:	9f e1       	ldi	r25, 0x1F	; 31
    129a:	a0 e0       	ldi	r26, 0x00	; 0
    129c:	b0 e0       	ldi	r27, 0x00	; 0
    129e:	8b 83       	std	Y+3, r24	; 0x03
    12a0:	9c 83       	std	Y+4, r25	; 0x04
    12a2:	ad 83       	std	Y+5, r26	; 0x05
    12a4:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	9c 81       	ldd	r25, Y+4	; 0x04
    12aa:	ad 81       	ldd	r26, Y+5	; 0x05
    12ac:	be 81       	ldd	r27, Y+6	; 0x06
    12ae:	68 94       	set
    12b0:	15 f8       	bld	r1, 5
    12b2:	b6 95       	lsr	r27
    12b4:	a7 95       	ror	r26
    12b6:	97 95       	ror	r25
    12b8:	87 95       	ror	r24
    12ba:	16 94       	lsr	r1
    12bc:	d1 f7       	brne	.-12     	; 0x12b2 <prvSetupTimerInterrupt+0x2a>
    12be:	8b 83       	std	Y+3, r24	; 0x03
    12c0:	9c 83       	std	Y+4, r25	; 0x04
    12c2:	ad 83       	std	Y+5, r26	; 0x05
    12c4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    12c6:	8b 81       	ldd	r24, Y+3	; 0x03
    12c8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ca:	ad 81       	ldd	r26, Y+5	; 0x05
    12cc:	be 81       	ldd	r27, Y+6	; 0x06
    12ce:	01 97       	sbiw	r24, 0x01	; 1
    12d0:	a1 09       	sbc	r26, r1
    12d2:	b1 09       	sbc	r27, r1
    12d4:	8b 83       	std	Y+3, r24	; 0x03
    12d6:	9c 83       	std	Y+4, r25	; 0x04
    12d8:	ad 83       	std	Y+5, r26	; 0x05
    12da:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    12dc:	8b 81       	ldd	r24, Y+3	; 0x03
    12de:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    12e0:	8b 81       	ldd	r24, Y+3	; 0x03
    12e2:	9c 81       	ldd	r25, Y+4	; 0x04
    12e4:	ad 81       	ldd	r26, Y+5	; 0x05
    12e6:	be 81       	ldd	r27, Y+6	; 0x06
    12e8:	89 2f       	mov	r24, r25
    12ea:	9a 2f       	mov	r25, r26
    12ec:	ab 2f       	mov	r26, r27
    12ee:	bb 27       	eor	r27, r27
    12f0:	8b 83       	std	Y+3, r24	; 0x03
    12f2:	9c 83       	std	Y+4, r25	; 0x04
    12f4:	ad 83       	std	Y+5, r26	; 0x05
    12f6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    12f8:	8b 81       	ldd	r24, Y+3	; 0x03
    12fa:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    12fc:	eb e4       	ldi	r30, 0x4B	; 75
    12fe:	f0 e0       	ldi	r31, 0x00	; 0
    1300:	8a 81       	ldd	r24, Y+2	; 0x02
    1302:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1304:	ea e4       	ldi	r30, 0x4A	; 74
    1306:	f0 e0       	ldi	r31, 0x00	; 0
    1308:	89 81       	ldd	r24, Y+1	; 0x01
    130a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    130c:	8b e0       	ldi	r24, 0x0B	; 11
    130e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1310:	ee e4       	ldi	r30, 0x4E	; 78
    1312:	f0 e0       	ldi	r31, 0x00	; 0
    1314:	89 81       	ldd	r24, Y+1	; 0x01
    1316:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1318:	e9 e5       	ldi	r30, 0x59	; 89
    131a:	f0 e0       	ldi	r31, 0x00	; 0
    131c:	80 81       	ld	r24, Z
    131e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1320:	89 81       	ldd	r24, Y+1	; 0x01
    1322:	80 61       	ori	r24, 0x10	; 16
    1324:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1326:	e9 e5       	ldi	r30, 0x59	; 89
    1328:	f0 e0       	ldi	r31, 0x00	; 0
    132a:	89 81       	ldd	r24, Y+1	; 0x01
    132c:	80 83       	st	Z, r24
}
    132e:	26 96       	adiw	r28, 0x06	; 6
    1330:	0f b6       	in	r0, 0x3f	; 63
    1332:	f8 94       	cli
    1334:	de bf       	out	0x3e, r29	; 62
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	cd bf       	out	0x3d, r28	; 61
    133a:	cf 91       	pop	r28
    133c:	df 91       	pop	r29
    133e:	08 95       	ret

00001340 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1340:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vPortYieldFromTick>
		asm volatile ( "reti" );
    1344:	18 95       	reti

00001346 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1346:	df 93       	push	r29
    1348:	cf 93       	push	r28
    134a:	00 d0       	rcall	.+0      	; 0x134c <xEventGroupCreate+0x6>
    134c:	cd b7       	in	r28, 0x3d	; 61
    134e:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1350:	8b e0       	ldi	r24, 0x0B	; 11
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    1358:	9a 83       	std	Y+2, r25	; 0x02
    135a:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    135c:	89 81       	ldd	r24, Y+1	; 0x01
    135e:	9a 81       	ldd	r25, Y+2	; 0x02
    1360:	00 97       	sbiw	r24, 0x00	; 0
    1362:	49 f0       	breq	.+18     	; 0x1376 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1364:	e9 81       	ldd	r30, Y+1	; 0x01
    1366:	fa 81       	ldd	r31, Y+2	; 0x02
    1368:	11 82       	std	Z+1, r1	; 0x01
    136a:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    136c:	89 81       	ldd	r24, Y+1	; 0x01
    136e:	9a 81       	ldd	r25, Y+2	; 0x02
    1370:	02 96       	adiw	r24, 0x02	; 2
    1372:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1376:	89 81       	ldd	r24, Y+1	; 0x01
    1378:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    137a:	0f 90       	pop	r0
    137c:	0f 90       	pop	r0
    137e:	cf 91       	pop	r28
    1380:	df 91       	pop	r29
    1382:	08 95       	ret

00001384 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1384:	df 93       	push	r29
    1386:	cf 93       	push	r28
    1388:	cd b7       	in	r28, 0x3d	; 61
    138a:	de b7       	in	r29, 0x3e	; 62
    138c:	60 97       	sbiw	r28, 0x10	; 16
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	f8 94       	cli
    1392:	de bf       	out	0x3e, r29	; 62
    1394:	0f be       	out	0x3f, r0	; 63
    1396:	cd bf       	out	0x3d, r28	; 61
    1398:	9a 87       	std	Y+10, r25	; 0x0a
    139a:	89 87       	std	Y+9, r24	; 0x09
    139c:	7c 87       	std	Y+12, r23	; 0x0c
    139e:	6b 87       	std	Y+11, r22	; 0x0b
    13a0:	5e 87       	std	Y+14, r21	; 0x0e
    13a2:	4d 87       	std	Y+13, r20	; 0x0d
    13a4:	38 8b       	std	Y+16, r19	; 0x10
    13a6:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    13a8:	89 85       	ldd	r24, Y+9	; 0x09
    13aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    13ac:	9c 83       	std	Y+4, r25	; 0x04
    13ae:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    13b0:	19 82       	std	Y+1, r1	; 0x01
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    13b2:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    13b6:	eb 81       	ldd	r30, Y+3	; 0x03
    13b8:	fc 81       	ldd	r31, Y+4	; 0x04
    13ba:	80 81       	ld	r24, Z
    13bc:	91 81       	ldd	r25, Z+1	; 0x01
    13be:	98 87       	std	Y+8, r25	; 0x08
    13c0:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    13c2:	89 85       	ldd	r24, Y+9	; 0x09
    13c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    13c6:	2b 85       	ldd	r18, Y+11	; 0x0b
    13c8:	3c 85       	ldd	r19, Y+12	; 0x0c
    13ca:	b9 01       	movw	r22, r18
    13cc:	0e 94 99 0b 	call	0x1732	; 0x1732 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    13d0:	2f 81       	ldd	r18, Y+7	; 0x07
    13d2:	38 85       	ldd	r19, Y+8	; 0x08
    13d4:	8b 85       	ldd	r24, Y+11	; 0x0b
    13d6:	9c 85       	ldd	r25, Y+12	; 0x0c
    13d8:	28 2b       	or	r18, r24
    13da:	39 2b       	or	r19, r25
    13dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    13de:	9e 85       	ldd	r25, Y+14	; 0x0e
    13e0:	28 23       	and	r18, r24
    13e2:	39 23       	and	r19, r25
    13e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    13e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    13e8:	28 17       	cp	r18, r24
    13ea:	39 07       	cpc	r19, r25
    13ec:	c9 f4       	brne	.+50     	; 0x1420 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    13ee:	2f 81       	ldd	r18, Y+7	; 0x07
    13f0:	38 85       	ldd	r19, Y+8	; 0x08
    13f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    13f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    13f6:	82 2b       	or	r24, r18
    13f8:	93 2b       	or	r25, r19
    13fa:	9e 83       	std	Y+6, r25	; 0x06
    13fc:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	20 81       	ld	r18, Z
    1404:	31 81       	ldd	r19, Z+1	; 0x01
    1406:	8d 85       	ldd	r24, Y+13	; 0x0d
    1408:	9e 85       	ldd	r25, Y+14	; 0x0e
    140a:	80 95       	com	r24
    140c:	90 95       	com	r25
    140e:	82 23       	and	r24, r18
    1410:	93 23       	and	r25, r19
    1412:	eb 81       	ldd	r30, Y+3	; 0x03
    1414:	fc 81       	ldd	r31, Y+4	; 0x04
    1416:	91 83       	std	Z+1, r25	; 0x01
    1418:	80 83       	st	Z, r24

            xTicksToWait = 0;
    141a:	18 8a       	std	Y+16, r1	; 0x10
    141c:	1f 86       	std	Y+15, r1	; 0x0f
    141e:	1e c0       	rjmp	.+60     	; 0x145c <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1420:	8f 85       	ldd	r24, Y+15	; 0x0f
    1422:	98 89       	ldd	r25, Y+16	; 0x10
    1424:	00 97       	sbiw	r24, 0x00	; 0
    1426:	91 f0       	breq	.+36     	; 0x144c <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1428:	8b 81       	ldd	r24, Y+3	; 0x03
    142a:	9c 81       	ldd	r25, Y+4	; 0x04
    142c:	bc 01       	movw	r22, r24
    142e:	6e 5f       	subi	r22, 0xFE	; 254
    1430:	7f 4f       	sbci	r23, 0xFF	; 255
    1432:	8d 85       	ldd	r24, Y+13	; 0x0d
    1434:	9e 85       	ldd	r25, Y+14	; 0x0e
    1436:	9c 01       	movw	r18, r24
    1438:	35 60       	ori	r19, 0x05	; 5
    143a:	4f 85       	ldd	r20, Y+15	; 0x0f
    143c:	58 89       	ldd	r21, Y+16	; 0x10
    143e:	cb 01       	movw	r24, r22
    1440:	b9 01       	movw	r22, r18
    1442:	0e 94 e2 24 	call	0x49c4	; 0x49c4 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1446:	1e 82       	std	Y+6, r1	; 0x06
    1448:	1d 82       	std	Y+5, r1	; 0x05
    144a:	08 c0       	rjmp	.+16     	; 0x145c <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    144c:	eb 81       	ldd	r30, Y+3	; 0x03
    144e:	fc 81       	ldd	r31, Y+4	; 0x04
    1450:	80 81       	ld	r24, Z
    1452:	91 81       	ldd	r25, Z+1	; 0x01
    1454:	9e 83       	std	Y+6, r25	; 0x06
    1456:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    145c:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    1460:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1462:	8f 85       	ldd	r24, Y+15	; 0x0f
    1464:	98 89       	ldd	r25, Y+16	; 0x10
    1466:	00 97       	sbiw	r24, 0x00	; 0
    1468:	09 f4       	brne	.+2      	; 0x146c <xEventGroupSync+0xe8>
    146a:	3a c0       	rjmp	.+116    	; 0x14e0 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    146c:	8a 81       	ldd	r24, Y+2	; 0x02
    146e:	88 23       	and	r24, r24
    1470:	11 f4       	brne	.+4      	; 0x1476 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1472:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1476:	0e 94 07 29 	call	0x520e	; 0x520e <uxTaskResetEventItemValue>
    147a:	9e 83       	std	Y+6, r25	; 0x06
    147c:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    147e:	8d 81       	ldd	r24, Y+5	; 0x05
    1480:	9e 81       	ldd	r25, Y+6	; 0x06
    1482:	80 70       	andi	r24, 0x00	; 0
    1484:	92 70       	andi	r25, 0x02	; 2
    1486:	00 97       	sbiw	r24, 0x00	; 0
    1488:	31 f5       	brne	.+76     	; 0x14d6 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    148a:	0f b6       	in	r0, 0x3f	; 63
    148c:	f8 94       	cli
    148e:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1490:	eb 81       	ldd	r30, Y+3	; 0x03
    1492:	fc 81       	ldd	r31, Y+4	; 0x04
    1494:	80 81       	ld	r24, Z
    1496:	91 81       	ldd	r25, Z+1	; 0x01
    1498:	9e 83       	std	Y+6, r25	; 0x06
    149a:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    149c:	2d 81       	ldd	r18, Y+5	; 0x05
    149e:	3e 81       	ldd	r19, Y+6	; 0x06
    14a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    14a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    14a4:	28 23       	and	r18, r24
    14a6:	39 23       	and	r19, r25
    14a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    14aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    14ac:	28 17       	cp	r18, r24
    14ae:	39 07       	cpc	r19, r25
    14b0:	71 f4       	brne	.+28     	; 0x14ce <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14b2:	eb 81       	ldd	r30, Y+3	; 0x03
    14b4:	fc 81       	ldd	r31, Y+4	; 0x04
    14b6:	20 81       	ld	r18, Z
    14b8:	31 81       	ldd	r19, Z+1	; 0x01
    14ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    14bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    14be:	80 95       	com	r24
    14c0:	90 95       	com	r25
    14c2:	82 23       	and	r24, r18
    14c4:	93 23       	and	r25, r19
    14c6:	eb 81       	ldd	r30, Y+3	; 0x03
    14c8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ca:	91 83       	std	Z+1, r25	; 0x01
    14cc:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    14ce:	0f 90       	pop	r0
    14d0:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    14d6:	8d 81       	ldd	r24, Y+5	; 0x05
    14d8:	9e 81       	ldd	r25, Y+6	; 0x06
    14da:	90 70       	andi	r25, 0x00	; 0
    14dc:	9e 83       	std	Y+6, r25	; 0x06
    14de:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    14e0:	8d 81       	ldd	r24, Y+5	; 0x05
    14e2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    14e4:	60 96       	adiw	r28, 0x10	; 16
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	f8 94       	cli
    14ea:	de bf       	out	0x3e, r29	; 62
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	cd bf       	out	0x3d, r28	; 61
    14f0:	cf 91       	pop	r28
    14f2:	df 91       	pop	r29
    14f4:	08 95       	ret

000014f6 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	df 93       	push	r29
    14fc:	cf 93       	push	r28
    14fe:	cd b7       	in	r28, 0x3d	; 61
    1500:	de b7       	in	r29, 0x3e	; 62
    1502:	63 97       	sbiw	r28, 0x13	; 19
    1504:	0f b6       	in	r0, 0x3f	; 63
    1506:	f8 94       	cli
    1508:	de bf       	out	0x3e, r29	; 62
    150a:	0f be       	out	0x3f, r0	; 63
    150c:	cd bf       	out	0x3d, r28	; 61
    150e:	9d 87       	std	Y+13, r25	; 0x0d
    1510:	8c 87       	std	Y+12, r24	; 0x0c
    1512:	7f 87       	std	Y+15, r23	; 0x0f
    1514:	6e 87       	std	Y+14, r22	; 0x0e
    1516:	48 8b       	std	Y+16, r20	; 0x10
    1518:	29 8b       	std	Y+17, r18	; 0x11
    151a:	1b 8b       	std	Y+19, r17	; 0x13
    151c:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    151e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1520:	9d 85       	ldd	r25, Y+13	; 0x0d
    1522:	9b 87       	std	Y+11, r25	; 0x0b
    1524:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1526:	1f 82       	std	Y+7, r1	; 0x07
    1528:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    152a:	1b 82       	std	Y+3, r1	; 0x03
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    152c:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1530:	ea 85       	ldd	r30, Y+10	; 0x0a
    1532:	fb 85       	ldd	r31, Y+11	; 0x0b
    1534:	80 81       	ld	r24, Z
    1536:	91 81       	ldd	r25, Z+1	; 0x01
    1538:	9a 83       	std	Y+2, r25	; 0x02
    153a:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	9a 81       	ldd	r25, Y+2	; 0x02
    1540:	2e 85       	ldd	r18, Y+14	; 0x0e
    1542:	3f 85       	ldd	r19, Y+15	; 0x0f
    1544:	b9 01       	movw	r22, r18
    1546:	49 89       	ldd	r20, Y+17	; 0x11
    1548:	0e 94 b6 0c 	call	0x196c	; 0x196c <prvTestWaitCondition>
    154c:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    154e:	8d 81       	ldd	r24, Y+5	; 0x05
    1550:	88 23       	and	r24, r24
    1552:	c1 f0       	breq	.+48     	; 0x1584 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1554:	89 81       	ldd	r24, Y+1	; 0x01
    1556:	9a 81       	ldd	r25, Y+2	; 0x02
    1558:	99 87       	std	Y+9, r25	; 0x09
    155a:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    155c:	1b 8a       	std	Y+19, r1	; 0x13
    155e:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1560:	88 89       	ldd	r24, Y+16	; 0x10
    1562:	88 23       	and	r24, r24
    1564:	e9 f1       	breq	.+122    	; 0x15e0 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1566:	ea 85       	ldd	r30, Y+10	; 0x0a
    1568:	fb 85       	ldd	r31, Y+11	; 0x0b
    156a:	20 81       	ld	r18, Z
    156c:	31 81       	ldd	r19, Z+1	; 0x01
    156e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1570:	9f 85       	ldd	r25, Y+15	; 0x0f
    1572:	80 95       	com	r24
    1574:	90 95       	com	r25
    1576:	82 23       	and	r24, r18
    1578:	93 23       	and	r25, r19
    157a:	ea 85       	ldd	r30, Y+10	; 0x0a
    157c:	fb 85       	ldd	r31, Y+11	; 0x0b
    157e:	91 83       	std	Z+1, r25	; 0x01
    1580:	80 83       	st	Z, r24
    1582:	2e c0       	rjmp	.+92     	; 0x15e0 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1584:	8a 89       	ldd	r24, Y+18	; 0x12
    1586:	9b 89       	ldd	r25, Y+19	; 0x13
    1588:	00 97       	sbiw	r24, 0x00	; 0
    158a:	39 f4       	brne	.+14     	; 0x159a <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    158c:	89 81       	ldd	r24, Y+1	; 0x01
    158e:	9a 81       	ldd	r25, Y+2	; 0x02
    1590:	99 87       	std	Y+9, r25	; 0x09
    1592:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	8b 83       	std	Y+3, r24	; 0x03
    1598:	23 c0       	rjmp	.+70     	; 0x15e0 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    159a:	88 89       	ldd	r24, Y+16	; 0x10
    159c:	88 23       	and	r24, r24
    159e:	29 f0       	breq	.+10     	; 0x15aa <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    15a0:	8e 81       	ldd	r24, Y+6	; 0x06
    15a2:	9f 81       	ldd	r25, Y+7	; 0x07
    15a4:	91 60       	ori	r25, 0x01	; 1
    15a6:	9f 83       	std	Y+7, r25	; 0x07
    15a8:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    15aa:	89 89       	ldd	r24, Y+17	; 0x11
    15ac:	88 23       	and	r24, r24
    15ae:	29 f0       	breq	.+10     	; 0x15ba <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    15b0:	8e 81       	ldd	r24, Y+6	; 0x06
    15b2:	9f 81       	ldd	r25, Y+7	; 0x07
    15b4:	94 60       	ori	r25, 0x04	; 4
    15b6:	9f 83       	std	Y+7, r25	; 0x07
    15b8:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    15ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    15bc:	9b 85       	ldd	r25, Y+11	; 0x0b
    15be:	bc 01       	movw	r22, r24
    15c0:	6e 5f       	subi	r22, 0xFE	; 254
    15c2:	7f 4f       	sbci	r23, 0xFF	; 255
    15c4:	2e 85       	ldd	r18, Y+14	; 0x0e
    15c6:	3f 85       	ldd	r19, Y+15	; 0x0f
    15c8:	8e 81       	ldd	r24, Y+6	; 0x06
    15ca:	9f 81       	ldd	r25, Y+7	; 0x07
    15cc:	28 2b       	or	r18, r24
    15ce:	39 2b       	or	r19, r25
    15d0:	4a 89       	ldd	r20, Y+18	; 0x12
    15d2:	5b 89       	ldd	r21, Y+19	; 0x13
    15d4:	cb 01       	movw	r24, r22
    15d6:	b9 01       	movw	r22, r18
    15d8:	0e 94 e2 24 	call	0x49c4	; 0x49c4 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    15dc:	19 86       	std	Y+9, r1	; 0x09
    15de:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    15e0:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    15e4:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    15e6:	8a 89       	ldd	r24, Y+18	; 0x12
    15e8:	9b 89       	ldd	r25, Y+19	; 0x13
    15ea:	00 97       	sbiw	r24, 0x00	; 0
    15ec:	09 f4       	brne	.+2      	; 0x15f0 <xEventGroupWaitBits+0xfa>
    15ee:	3c c0       	rjmp	.+120    	; 0x1668 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    15f0:	8c 81       	ldd	r24, Y+4	; 0x04
    15f2:	88 23       	and	r24, r24
    15f4:	11 f4       	brne	.+4      	; 0x15fa <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    15f6:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    15fa:	0e 94 07 29 	call	0x520e	; 0x520e <uxTaskResetEventItemValue>
    15fe:	99 87       	std	Y+9, r25	; 0x09
    1600:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1602:	88 85       	ldd	r24, Y+8	; 0x08
    1604:	99 85       	ldd	r25, Y+9	; 0x09
    1606:	80 70       	andi	r24, 0x00	; 0
    1608:	92 70       	andi	r25, 0x02	; 2
    160a:	00 97       	sbiw	r24, 0x00	; 0
    160c:	41 f5       	brne	.+80     	; 0x165e <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1614:	ea 85       	ldd	r30, Y+10	; 0x0a
    1616:	fb 85       	ldd	r31, Y+11	; 0x0b
    1618:	80 81       	ld	r24, Z
    161a:	91 81       	ldd	r25, Z+1	; 0x01
    161c:	99 87       	std	Y+9, r25	; 0x09
    161e:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1620:	88 85       	ldd	r24, Y+8	; 0x08
    1622:	99 85       	ldd	r25, Y+9	; 0x09
    1624:	2e 85       	ldd	r18, Y+14	; 0x0e
    1626:	3f 85       	ldd	r19, Y+15	; 0x0f
    1628:	b9 01       	movw	r22, r18
    162a:	49 89       	ldd	r20, Y+17	; 0x11
    162c:	0e 94 b6 0c 	call	0x196c	; 0x196c <prvTestWaitCondition>
    1630:	88 23       	and	r24, r24
    1632:	89 f0       	breq	.+34     	; 0x1656 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1634:	88 89       	ldd	r24, Y+16	; 0x10
    1636:	88 23       	and	r24, r24
    1638:	71 f0       	breq	.+28     	; 0x1656 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    163a:	ea 85       	ldd	r30, Y+10	; 0x0a
    163c:	fb 85       	ldd	r31, Y+11	; 0x0b
    163e:	20 81       	ld	r18, Z
    1640:	31 81       	ldd	r19, Z+1	; 0x01
    1642:	8e 85       	ldd	r24, Y+14	; 0x0e
    1644:	9f 85       	ldd	r25, Y+15	; 0x0f
    1646:	80 95       	com	r24
    1648:	90 95       	com	r25
    164a:	82 23       	and	r24, r18
    164c:	93 23       	and	r25, r19
    164e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1650:	fb 85       	ldd	r31, Y+11	; 0x0b
    1652:	91 83       	std	Z+1, r25	; 0x01
    1654:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1656:	81 e0       	ldi	r24, 0x01	; 1
    1658:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    165a:	0f 90       	pop	r0
    165c:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    165e:	88 85       	ldd	r24, Y+8	; 0x08
    1660:	99 85       	ldd	r25, Y+9	; 0x09
    1662:	90 70       	andi	r25, 0x00	; 0
    1664:	99 87       	std	Y+9, r25	; 0x09
    1666:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1668:	88 85       	ldd	r24, Y+8	; 0x08
    166a:	99 85       	ldd	r25, Y+9	; 0x09
}
    166c:	63 96       	adiw	r28, 0x13	; 19
    166e:	0f b6       	in	r0, 0x3f	; 63
    1670:	f8 94       	cli
    1672:	de bf       	out	0x3e, r29	; 62
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	cd bf       	out	0x3d, r28	; 61
    1678:	cf 91       	pop	r28
    167a:	df 91       	pop	r29
    167c:	1f 91       	pop	r17
    167e:	0f 91       	pop	r16
    1680:	08 95       	ret

00001682 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1682:	df 93       	push	r29
    1684:	cf 93       	push	r28
    1686:	cd b7       	in	r28, 0x3d	; 61
    1688:	de b7       	in	r29, 0x3e	; 62
    168a:	28 97       	sbiw	r28, 0x08	; 8
    168c:	0f b6       	in	r0, 0x3f	; 63
    168e:	f8 94       	cli
    1690:	de bf       	out	0x3e, r29	; 62
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	cd bf       	out	0x3d, r28	; 61
    1696:	9e 83       	std	Y+6, r25	; 0x06
    1698:	8d 83       	std	Y+5, r24	; 0x05
    169a:	78 87       	std	Y+8, r23	; 0x08
    169c:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    169e:	8d 81       	ldd	r24, Y+5	; 0x05
    16a0:	9e 81       	ldd	r25, Y+6	; 0x06
    16a2:	9c 83       	std	Y+4, r25	; 0x04
    16a4:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    16a6:	0f b6       	in	r0, 0x3f	; 63
    16a8:	f8 94       	cli
    16aa:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    16ac:	eb 81       	ldd	r30, Y+3	; 0x03
    16ae:	fc 81       	ldd	r31, Y+4	; 0x04
    16b0:	80 81       	ld	r24, Z
    16b2:	91 81       	ldd	r25, Z+1	; 0x01
    16b4:	9a 83       	std	Y+2, r25	; 0x02
    16b6:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    16b8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ba:	fc 81       	ldd	r31, Y+4	; 0x04
    16bc:	20 81       	ld	r18, Z
    16be:	31 81       	ldd	r19, Z+1	; 0x01
    16c0:	8f 81       	ldd	r24, Y+7	; 0x07
    16c2:	98 85       	ldd	r25, Y+8	; 0x08
    16c4:	80 95       	com	r24
    16c6:	90 95       	com	r25
    16c8:	82 23       	and	r24, r18
    16ca:	93 23       	and	r25, r19
    16cc:	eb 81       	ldd	r30, Y+3	; 0x03
    16ce:	fc 81       	ldd	r31, Y+4	; 0x04
    16d0:	91 83       	std	Z+1, r25	; 0x01
    16d2:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    16d4:	0f 90       	pop	r0
    16d6:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    16d8:	89 81       	ldd	r24, Y+1	; 0x01
    16da:	9a 81       	ldd	r25, Y+2	; 0x02
}
    16dc:	28 96       	adiw	r28, 0x08	; 8
    16de:	0f b6       	in	r0, 0x3f	; 63
    16e0:	f8 94       	cli
    16e2:	de bf       	out	0x3e, r29	; 62
    16e4:	0f be       	out	0x3f, r0	; 63
    16e6:	cd bf       	out	0x3d, r28	; 61
    16e8:	cf 91       	pop	r28
    16ea:	df 91       	pop	r29
    16ec:	08 95       	ret

000016ee <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    16ee:	df 93       	push	r29
    16f0:	cf 93       	push	r28
    16f2:	cd b7       	in	r28, 0x3d	; 61
    16f4:	de b7       	in	r29, 0x3e	; 62
    16f6:	27 97       	sbiw	r28, 0x07	; 7
    16f8:	0f b6       	in	r0, 0x3f	; 63
    16fa:	f8 94       	cli
    16fc:	de bf       	out	0x3e, r29	; 62
    16fe:	0f be       	out	0x3f, r0	; 63
    1700:	cd bf       	out	0x3d, r28	; 61
    1702:	9f 83       	std	Y+7, r25	; 0x07
    1704:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1706:	8e 81       	ldd	r24, Y+6	; 0x06
    1708:	9f 81       	ldd	r25, Y+7	; 0x07
    170a:	9c 83       	std	Y+4, r25	; 0x04
    170c:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    170e:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1710:	eb 81       	ldd	r30, Y+3	; 0x03
    1712:	fc 81       	ldd	r31, Y+4	; 0x04
    1714:	80 81       	ld	r24, Z
    1716:	91 81       	ldd	r25, Z+1	; 0x01
    1718:	9a 83       	std	Y+2, r25	; 0x02
    171a:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    171c:	89 81       	ldd	r24, Y+1	; 0x01
    171e:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1720:	27 96       	adiw	r28, 0x07	; 7
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	cf 91       	pop	r28
    172e:	df 91       	pop	r29
    1730:	08 95       	ret

00001732 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1732:	df 93       	push	r29
    1734:	cf 93       	push	r28
    1736:	cd b7       	in	r28, 0x3d	; 61
    1738:	de b7       	in	r29, 0x3e	; 62
    173a:	65 97       	sbiw	r28, 0x15	; 21
    173c:	0f b6       	in	r0, 0x3f	; 63
    173e:	f8 94       	cli
    1740:	de bf       	out	0x3e, r29	; 62
    1742:	0f be       	out	0x3f, r0	; 63
    1744:	cd bf       	out	0x3d, r28	; 61
    1746:	9b 8b       	std	Y+19, r25	; 0x13
    1748:	8a 8b       	std	Y+18, r24	; 0x12
    174a:	7d 8b       	std	Y+21, r23	; 0x15
    174c:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    174e:	19 86       	std	Y+9, r1	; 0x09
    1750:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1752:	8a 89       	ldd	r24, Y+18	; 0x12
    1754:	9b 89       	ldd	r25, Y+19	; 0x13
    1756:	9b 83       	std	Y+3, r25	; 0x03
    1758:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    175a:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    175c:	8a 81       	ldd	r24, Y+2	; 0x02
    175e:	9b 81       	ldd	r25, Y+3	; 0x03
    1760:	02 96       	adiw	r24, 0x02	; 2
    1762:	9b 87       	std	Y+11, r25	; 0x0b
    1764:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1766:	8a 85       	ldd	r24, Y+10	; 0x0a
    1768:	9b 85       	ldd	r25, Y+11	; 0x0b
    176a:	03 96       	adiw	r24, 0x03	; 3
    176c:	9d 87       	std	Y+13, r25	; 0x0d
    176e:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1770:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1774:	ea 85       	ldd	r30, Y+10	; 0x0a
    1776:	fb 85       	ldd	r31, Y+11	; 0x0b
    1778:	85 81       	ldd	r24, Z+5	; 0x05
    177a:	96 81       	ldd	r25, Z+6	; 0x06
    177c:	99 8b       	std	Y+17, r25	; 0x11
    177e:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1780:	ea 81       	ldd	r30, Y+2	; 0x02
    1782:	fb 81       	ldd	r31, Y+3	; 0x03
    1784:	20 81       	ld	r18, Z
    1786:	31 81       	ldd	r19, Z+1	; 0x01
    1788:	8c 89       	ldd	r24, Y+20	; 0x14
    178a:	9d 89       	ldd	r25, Y+21	; 0x15
    178c:	82 2b       	or	r24, r18
    178e:	93 2b       	or	r25, r19
    1790:	ea 81       	ldd	r30, Y+2	; 0x02
    1792:	fb 81       	ldd	r31, Y+3	; 0x03
    1794:	91 83       	std	Z+1, r25	; 0x01
    1796:	80 83       	st	Z, r24
    1798:	59 c0       	rjmp	.+178    	; 0x184c <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    179a:	e8 89       	ldd	r30, Y+16	; 0x10
    179c:	f9 89       	ldd	r31, Y+17	; 0x11
    179e:	82 81       	ldd	r24, Z+2	; 0x02
    17a0:	93 81       	ldd	r25, Z+3	; 0x03
    17a2:	9f 87       	std	Y+15, r25	; 0x0f
    17a4:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    17a6:	e8 89       	ldd	r30, Y+16	; 0x10
    17a8:	f9 89       	ldd	r31, Y+17	; 0x11
    17aa:	80 81       	ld	r24, Z
    17ac:	91 81       	ldd	r25, Z+1	; 0x01
    17ae:	9f 83       	std	Y+7, r25	; 0x07
    17b0:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    17b2:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    17b4:	8e 81       	ldd	r24, Y+6	; 0x06
    17b6:	9f 81       	ldd	r25, Y+7	; 0x07
    17b8:	80 70       	andi	r24, 0x00	; 0
    17ba:	9d 83       	std	Y+5, r25	; 0x05
    17bc:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    17be:	8e 81       	ldd	r24, Y+6	; 0x06
    17c0:	9f 81       	ldd	r25, Y+7	; 0x07
    17c2:	90 70       	andi	r25, 0x00	; 0
    17c4:	9f 83       	std	Y+7, r25	; 0x07
    17c6:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    17c8:	8c 81       	ldd	r24, Y+4	; 0x04
    17ca:	9d 81       	ldd	r25, Y+5	; 0x05
    17cc:	80 70       	andi	r24, 0x00	; 0
    17ce:	94 70       	andi	r25, 0x04	; 4
    17d0:	00 97       	sbiw	r24, 0x00	; 0
    17d2:	69 f4       	brne	.+26     	; 0x17ee <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    17d4:	ea 81       	ldd	r30, Y+2	; 0x02
    17d6:	fb 81       	ldd	r31, Y+3	; 0x03
    17d8:	20 81       	ld	r18, Z
    17da:	31 81       	ldd	r19, Z+1	; 0x01
    17dc:	8e 81       	ldd	r24, Y+6	; 0x06
    17de:	9f 81       	ldd	r25, Y+7	; 0x07
    17e0:	82 23       	and	r24, r18
    17e2:	93 23       	and	r25, r19
    17e4:	00 97       	sbiw	r24, 0x00	; 0
    17e6:	91 f0       	breq	.+36     	; 0x180c <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    17e8:	81 e0       	ldi	r24, 0x01	; 1
    17ea:	89 83       	std	Y+1, r24	; 0x01
    17ec:	0f c0       	rjmp	.+30     	; 0x180c <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    17ee:	ea 81       	ldd	r30, Y+2	; 0x02
    17f0:	fb 81       	ldd	r31, Y+3	; 0x03
    17f2:	20 81       	ld	r18, Z
    17f4:	31 81       	ldd	r19, Z+1	; 0x01
    17f6:	8e 81       	ldd	r24, Y+6	; 0x06
    17f8:	9f 81       	ldd	r25, Y+7	; 0x07
    17fa:	28 23       	and	r18, r24
    17fc:	39 23       	and	r19, r25
    17fe:	8e 81       	ldd	r24, Y+6	; 0x06
    1800:	9f 81       	ldd	r25, Y+7	; 0x07
    1802:	28 17       	cp	r18, r24
    1804:	39 07       	cpc	r19, r25
    1806:	11 f4       	brne	.+4      	; 0x180c <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1808:	81 e0       	ldi	r24, 0x01	; 1
    180a:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    180c:	89 81       	ldd	r24, Y+1	; 0x01
    180e:	88 23       	and	r24, r24
    1810:	c9 f0       	breq	.+50     	; 0x1844 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1812:	8c 81       	ldd	r24, Y+4	; 0x04
    1814:	9d 81       	ldd	r25, Y+5	; 0x05
    1816:	80 70       	andi	r24, 0x00	; 0
    1818:	91 70       	andi	r25, 0x01	; 1
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	41 f0       	breq	.+16     	; 0x182e <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    181e:	88 85       	ldd	r24, Y+8	; 0x08
    1820:	99 85       	ldd	r25, Y+9	; 0x09
    1822:	2e 81       	ldd	r18, Y+6	; 0x06
    1824:	3f 81       	ldd	r19, Y+7	; 0x07
    1826:	82 2b       	or	r24, r18
    1828:	93 2b       	or	r25, r19
    182a:	99 87       	std	Y+9, r25	; 0x09
    182c:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    182e:	ea 81       	ldd	r30, Y+2	; 0x02
    1830:	fb 81       	ldd	r31, Y+3	; 0x03
    1832:	80 81       	ld	r24, Z
    1834:	91 81       	ldd	r25, Z+1	; 0x01
    1836:	9c 01       	movw	r18, r24
    1838:	32 60       	ori	r19, 0x02	; 2
    183a:	88 89       	ldd	r24, Y+16	; 0x10
    183c:	99 89       	ldd	r25, Y+17	; 0x11
    183e:	b9 01       	movw	r22, r18
    1840:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1844:	8e 85       	ldd	r24, Y+14	; 0x0e
    1846:	9f 85       	ldd	r25, Y+15	; 0x0f
    1848:	99 8b       	std	Y+17, r25	; 0x11
    184a:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    184c:	28 89       	ldd	r18, Y+16	; 0x10
    184e:	39 89       	ldd	r19, Y+17	; 0x11
    1850:	8c 85       	ldd	r24, Y+12	; 0x0c
    1852:	9d 85       	ldd	r25, Y+13	; 0x0d
    1854:	28 17       	cp	r18, r24
    1856:	39 07       	cpc	r19, r25
    1858:	09 f0       	breq	.+2      	; 0x185c <xEventGroupSetBits+0x12a>
    185a:	9f cf       	rjmp	.-194    	; 0x179a <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    185c:	ea 81       	ldd	r30, Y+2	; 0x02
    185e:	fb 81       	ldd	r31, Y+3	; 0x03
    1860:	20 81       	ld	r18, Z
    1862:	31 81       	ldd	r19, Z+1	; 0x01
    1864:	88 85       	ldd	r24, Y+8	; 0x08
    1866:	99 85       	ldd	r25, Y+9	; 0x09
    1868:	80 95       	com	r24
    186a:	90 95       	com	r25
    186c:	82 23       	and	r24, r18
    186e:	93 23       	and	r25, r19
    1870:	ea 81       	ldd	r30, Y+2	; 0x02
    1872:	fb 81       	ldd	r31, Y+3	; 0x03
    1874:	91 83       	std	Z+1, r25	; 0x01
    1876:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1878:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    187c:	ea 81       	ldd	r30, Y+2	; 0x02
    187e:	fb 81       	ldd	r31, Y+3	; 0x03
    1880:	80 81       	ld	r24, Z
    1882:	91 81       	ldd	r25, Z+1	; 0x01
}
    1884:	65 96       	adiw	r28, 0x15	; 21
    1886:	0f b6       	in	r0, 0x3f	; 63
    1888:	f8 94       	cli
    188a:	de bf       	out	0x3e, r29	; 62
    188c:	0f be       	out	0x3f, r0	; 63
    188e:	cd bf       	out	0x3d, r28	; 61
    1890:	cf 91       	pop	r28
    1892:	df 91       	pop	r29
    1894:	08 95       	ret

00001896 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1896:	df 93       	push	r29
    1898:	cf 93       	push	r28
    189a:	00 d0       	rcall	.+0      	; 0x189c <vEventGroupDelete+0x6>
    189c:	00 d0       	rcall	.+0      	; 0x189e <vEventGroupDelete+0x8>
    189e:	00 d0       	rcall	.+0      	; 0x18a0 <vEventGroupDelete+0xa>
    18a0:	cd b7       	in	r28, 0x3d	; 61
    18a2:	de b7       	in	r29, 0x3e	; 62
    18a4:	9e 83       	std	Y+6, r25	; 0x06
    18a6:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    18a8:	8d 81       	ldd	r24, Y+5	; 0x05
    18aa:	9e 81       	ldd	r25, Y+6	; 0x06
    18ac:	9c 83       	std	Y+4, r25	; 0x04
    18ae:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    18b0:	8b 81       	ldd	r24, Y+3	; 0x03
    18b2:	9c 81       	ldd	r25, Y+4	; 0x04
    18b4:	02 96       	adiw	r24, 0x02	; 2
    18b6:	9a 83       	std	Y+2, r25	; 0x02
    18b8:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    18ba:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
    18be:	08 c0       	rjmp	.+16     	; 0x18d0 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    18c0:	e9 81       	ldd	r30, Y+1	; 0x01
    18c2:	fa 81       	ldd	r31, Y+2	; 0x02
    18c4:	85 81       	ldd	r24, Z+5	; 0x05
    18c6:	96 81       	ldd	r25, Z+6	; 0x06
    18c8:	60 e0       	ldi	r22, 0x00	; 0
    18ca:	72 e0       	ldi	r23, 0x02	; 2
    18cc:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    18d0:	e9 81       	ldd	r30, Y+1	; 0x01
    18d2:	fa 81       	ldd	r31, Y+2	; 0x02
    18d4:	80 81       	ld	r24, Z
    18d6:	88 23       	and	r24, r24
    18d8:	99 f7       	brne	.-26     	; 0x18c0 <vEventGroupDelete+0x2a>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
    18da:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
    18de:	8b 81       	ldd	r24, Y+3	; 0x03
    18e0:	9c 81       	ldd	r25, Y+4	; 0x04
    18e2:	0e 94 a9 06 	call	0xd52	; 0xd52 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    18e6:	26 96       	adiw	r28, 0x06	; 6
    18e8:	0f b6       	in	r0, 0x3f	; 63
    18ea:	f8 94       	cli
    18ec:	de bf       	out	0x3e, r29	; 62
    18ee:	0f be       	out	0x3f, r0	; 63
    18f0:	cd bf       	out	0x3d, r28	; 61
    18f2:	cf 91       	pop	r28
    18f4:	df 91       	pop	r29
    18f6:	08 95       	ret

000018f8 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    18f8:	df 93       	push	r29
    18fa:	cf 93       	push	r28
    18fc:	00 d0       	rcall	.+0      	; 0x18fe <vEventGroupSetBitsCallback+0x6>
    18fe:	00 d0       	rcall	.+0      	; 0x1900 <vEventGroupSetBitsCallback+0x8>
    1900:	00 d0       	rcall	.+0      	; 0x1902 <vEventGroupSetBitsCallback+0xa>
    1902:	cd b7       	in	r28, 0x3d	; 61
    1904:	de b7       	in	r29, 0x3e	; 62
    1906:	9a 83       	std	Y+2, r25	; 0x02
    1908:	89 83       	std	Y+1, r24	; 0x01
    190a:	4b 83       	std	Y+3, r20	; 0x03
    190c:	5c 83       	std	Y+4, r21	; 0x04
    190e:	6d 83       	std	Y+5, r22	; 0x05
    1910:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1912:	89 81       	ldd	r24, Y+1	; 0x01
    1914:	9a 81       	ldd	r25, Y+2	; 0x02
    1916:	2b 81       	ldd	r18, Y+3	; 0x03
    1918:	3c 81       	ldd	r19, Y+4	; 0x04
    191a:	b9 01       	movw	r22, r18
    191c:	0e 94 99 0b 	call	0x1732	; 0x1732 <xEventGroupSetBits>
}
    1920:	26 96       	adiw	r28, 0x06	; 6
    1922:	0f b6       	in	r0, 0x3f	; 63
    1924:	f8 94       	cli
    1926:	de bf       	out	0x3e, r29	; 62
    1928:	0f be       	out	0x3f, r0	; 63
    192a:	cd bf       	out	0x3d, r28	; 61
    192c:	cf 91       	pop	r28
    192e:	df 91       	pop	r29
    1930:	08 95       	ret

00001932 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1932:	df 93       	push	r29
    1934:	cf 93       	push	r28
    1936:	00 d0       	rcall	.+0      	; 0x1938 <vEventGroupClearBitsCallback+0x6>
    1938:	00 d0       	rcall	.+0      	; 0x193a <vEventGroupClearBitsCallback+0x8>
    193a:	00 d0       	rcall	.+0      	; 0x193c <vEventGroupClearBitsCallback+0xa>
    193c:	cd b7       	in	r28, 0x3d	; 61
    193e:	de b7       	in	r29, 0x3e	; 62
    1940:	9a 83       	std	Y+2, r25	; 0x02
    1942:	89 83       	std	Y+1, r24	; 0x01
    1944:	4b 83       	std	Y+3, r20	; 0x03
    1946:	5c 83       	std	Y+4, r21	; 0x04
    1948:	6d 83       	std	Y+5, r22	; 0x05
    194a:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	9a 81       	ldd	r25, Y+2	; 0x02
    1950:	2b 81       	ldd	r18, Y+3	; 0x03
    1952:	3c 81       	ldd	r19, Y+4	; 0x04
    1954:	b9 01       	movw	r22, r18
    1956:	0e 94 41 0b 	call	0x1682	; 0x1682 <xEventGroupClearBits>
}
    195a:	26 96       	adiw	r28, 0x06	; 6
    195c:	0f b6       	in	r0, 0x3f	; 63
    195e:	f8 94       	cli
    1960:	de bf       	out	0x3e, r29	; 62
    1962:	0f be       	out	0x3f, r0	; 63
    1964:	cd bf       	out	0x3d, r28	; 61
    1966:	cf 91       	pop	r28
    1968:	df 91       	pop	r29
    196a:	08 95       	ret

0000196c <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    196c:	df 93       	push	r29
    196e:	cf 93       	push	r28
    1970:	00 d0       	rcall	.+0      	; 0x1972 <prvTestWaitCondition+0x6>
    1972:	00 d0       	rcall	.+0      	; 0x1974 <prvTestWaitCondition+0x8>
    1974:	00 d0       	rcall	.+0      	; 0x1976 <prvTestWaitCondition+0xa>
    1976:	cd b7       	in	r28, 0x3d	; 61
    1978:	de b7       	in	r29, 0x3e	; 62
    197a:	9b 83       	std	Y+3, r25	; 0x03
    197c:	8a 83       	std	Y+2, r24	; 0x02
    197e:	7d 83       	std	Y+5, r23	; 0x05
    1980:	6c 83       	std	Y+4, r22	; 0x04
    1982:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1984:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1986:	8e 81       	ldd	r24, Y+6	; 0x06
    1988:	88 23       	and	r24, r24
    198a:	59 f4       	brne	.+22     	; 0x19a2 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    198c:	8a 81       	ldd	r24, Y+2	; 0x02
    198e:	9b 81       	ldd	r25, Y+3	; 0x03
    1990:	2c 81       	ldd	r18, Y+4	; 0x04
    1992:	3d 81       	ldd	r19, Y+5	; 0x05
    1994:	82 23       	and	r24, r18
    1996:	93 23       	and	r25, r19
    1998:	00 97       	sbiw	r24, 0x00	; 0
    199a:	81 f0       	breq	.+32     	; 0x19bc <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	89 83       	std	Y+1, r24	; 0x01
    19a0:	0d c0       	rjmp	.+26     	; 0x19bc <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    19a2:	2a 81       	ldd	r18, Y+2	; 0x02
    19a4:	3b 81       	ldd	r19, Y+3	; 0x03
    19a6:	8c 81       	ldd	r24, Y+4	; 0x04
    19a8:	9d 81       	ldd	r25, Y+5	; 0x05
    19aa:	28 23       	and	r18, r24
    19ac:	39 23       	and	r19, r25
    19ae:	8c 81       	ldd	r24, Y+4	; 0x04
    19b0:	9d 81       	ldd	r25, Y+5	; 0x05
    19b2:	28 17       	cp	r18, r24
    19b4:	39 07       	cpc	r19, r25
    19b6:	11 f4       	brne	.+4      	; 0x19bc <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    19bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    19be:	26 96       	adiw	r28, 0x06	; 6
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	de bf       	out	0x3e, r29	; 62
    19c6:	0f be       	out	0x3f, r0	; 63
    19c8:	cd bf       	out	0x3d, r28	; 61
    19ca:	cf 91       	pop	r28
    19cc:	df 91       	pop	r29
    19ce:	08 95       	ret

000019d0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    19d0:	df 93       	push	r29
    19d2:	cf 93       	push	r28
    19d4:	00 d0       	rcall	.+0      	; 0x19d6 <vListInitialise+0x6>
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
    19da:	9a 83       	std	Y+2, r25	; 0x02
    19dc:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    19de:	89 81       	ldd	r24, Y+1	; 0x01
    19e0:	9a 81       	ldd	r25, Y+2	; 0x02
    19e2:	03 96       	adiw	r24, 0x03	; 3
    19e4:	e9 81       	ldd	r30, Y+1	; 0x01
    19e6:	fa 81       	ldd	r31, Y+2	; 0x02
    19e8:	92 83       	std	Z+2, r25	; 0x02
    19ea:	81 83       	std	Z+1, r24	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    19ec:	e9 81       	ldd	r30, Y+1	; 0x01
    19ee:	fa 81       	ldd	r31, Y+2	; 0x02
    19f0:	8f ef       	ldi	r24, 0xFF	; 255
    19f2:	9f ef       	ldi	r25, 0xFF	; 255
    19f4:	94 83       	std	Z+4, r25	; 0x04
    19f6:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    19f8:	89 81       	ldd	r24, Y+1	; 0x01
    19fa:	9a 81       	ldd	r25, Y+2	; 0x02
    19fc:	03 96       	adiw	r24, 0x03	; 3
    19fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1a00:	fa 81       	ldd	r31, Y+2	; 0x02
    1a02:	96 83       	std	Z+6, r25	; 0x06
    1a04:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
    1a08:	9a 81       	ldd	r25, Y+2	; 0x02
    1a0a:	03 96       	adiw	r24, 0x03	; 3
    1a0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a10:	90 87       	std	Z+8, r25	; 0x08
    1a12:	87 83       	std	Z+7, r24	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1a14:	e9 81       	ldd	r30, Y+1	; 0x01
    1a16:	fa 81       	ldd	r31, Y+2	; 0x02
    1a18:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1a1a:	0f 90       	pop	r0
    1a1c:	0f 90       	pop	r0
    1a1e:	cf 91       	pop	r28
    1a20:	df 91       	pop	r29
    1a22:	08 95       	ret

00001a24 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1a24:	df 93       	push	r29
    1a26:	cf 93       	push	r28
    1a28:	00 d0       	rcall	.+0      	; 0x1a2a <vListInitialiseItem+0x6>
    1a2a:	cd b7       	in	r28, 0x3d	; 61
    1a2c:	de b7       	in	r29, 0x3e	; 62
    1a2e:	9a 83       	std	Y+2, r25	; 0x02
    1a30:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1a32:	e9 81       	ldd	r30, Y+1	; 0x01
    1a34:	fa 81       	ldd	r31, Y+2	; 0x02
    1a36:	11 86       	std	Z+9, r1	; 0x09
    1a38:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1a3a:	0f 90       	pop	r0
    1a3c:	0f 90       	pop	r0
    1a3e:	cf 91       	pop	r28
    1a40:	df 91       	pop	r29
    1a42:	08 95       	ret

00001a44 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1a44:	df 93       	push	r29
    1a46:	cf 93       	push	r28
    1a48:	00 d0       	rcall	.+0      	; 0x1a4a <vListInsertEnd+0x6>
    1a4a:	00 d0       	rcall	.+0      	; 0x1a4c <vListInsertEnd+0x8>
    1a4c:	00 d0       	rcall	.+0      	; 0x1a4e <vListInsertEnd+0xa>
    1a4e:	cd b7       	in	r28, 0x3d	; 61
    1a50:	de b7       	in	r29, 0x3e	; 62
    1a52:	9c 83       	std	Y+4, r25	; 0x04
    1a54:	8b 83       	std	Y+3, r24	; 0x03
    1a56:	7e 83       	std	Y+6, r23	; 0x06
    1a58:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a5e:	81 81       	ldd	r24, Z+1	; 0x01
    1a60:	92 81       	ldd	r25, Z+2	; 0x02
    1a62:	9a 83       	std	Y+2, r25	; 0x02
    1a64:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1a66:	ed 81       	ldd	r30, Y+5	; 0x05
    1a68:	fe 81       	ldd	r31, Y+6	; 0x06
    1a6a:	89 81       	ldd	r24, Y+1	; 0x01
    1a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6e:	93 83       	std	Z+3, r25	; 0x03
    1a70:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1a72:	e9 81       	ldd	r30, Y+1	; 0x01
    1a74:	fa 81       	ldd	r31, Y+2	; 0x02
    1a76:	84 81       	ldd	r24, Z+4	; 0x04
    1a78:	95 81       	ldd	r25, Z+5	; 0x05
    1a7a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a7c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a7e:	95 83       	std	Z+5, r25	; 0x05
    1a80:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1a82:	e9 81       	ldd	r30, Y+1	; 0x01
    1a84:	fa 81       	ldd	r31, Y+2	; 0x02
    1a86:	04 80       	ldd	r0, Z+4	; 0x04
    1a88:	f5 81       	ldd	r31, Z+5	; 0x05
    1a8a:	e0 2d       	mov	r30, r0
    1a8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a90:	93 83       	std	Z+3, r25	; 0x03
    1a92:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1a94:	e9 81       	ldd	r30, Y+1	; 0x01
    1a96:	fa 81       	ldd	r31, Y+2	; 0x02
    1a98:	8d 81       	ldd	r24, Y+5	; 0x05
    1a9a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a9c:	95 83       	std	Z+5, r25	; 0x05
    1a9e:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1aa0:	ed 81       	ldd	r30, Y+5	; 0x05
    1aa2:	fe 81       	ldd	r31, Y+6	; 0x06
    1aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa6:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa8:	91 87       	std	Z+9, r25	; 0x09
    1aaa:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1aac:	eb 81       	ldd	r30, Y+3	; 0x03
    1aae:	fc 81       	ldd	r31, Y+4	; 0x04
    1ab0:	80 81       	ld	r24, Z
    1ab2:	8f 5f       	subi	r24, 0xFF	; 255
    1ab4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ab6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ab8:	80 83       	st	Z, r24
}
    1aba:	26 96       	adiw	r28, 0x06	; 6
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	de bf       	out	0x3e, r29	; 62
    1ac2:	0f be       	out	0x3f, r0	; 63
    1ac4:	cd bf       	out	0x3d, r28	; 61
    1ac6:	cf 91       	pop	r28
    1ac8:	df 91       	pop	r29
    1aca:	08 95       	ret

00001acc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1acc:	df 93       	push	r29
    1ace:	cf 93       	push	r28
    1ad0:	cd b7       	in	r28, 0x3d	; 61
    1ad2:	de b7       	in	r29, 0x3e	; 62
    1ad4:	28 97       	sbiw	r28, 0x08	; 8
    1ad6:	0f b6       	in	r0, 0x3f	; 63
    1ad8:	f8 94       	cli
    1ada:	de bf       	out	0x3e, r29	; 62
    1adc:	0f be       	out	0x3f, r0	; 63
    1ade:	cd bf       	out	0x3d, r28	; 61
    1ae0:	9e 83       	std	Y+6, r25	; 0x06
    1ae2:	8d 83       	std	Y+5, r24	; 0x05
    1ae4:	78 87       	std	Y+8, r23	; 0x08
    1ae6:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1ae8:	ef 81       	ldd	r30, Y+7	; 0x07
    1aea:	f8 85       	ldd	r31, Y+8	; 0x08
    1aec:	80 81       	ld	r24, Z
    1aee:	91 81       	ldd	r25, Z+1	; 0x01
    1af0:	9a 83       	std	Y+2, r25	; 0x02
    1af2:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	9a 81       	ldd	r25, Y+2	; 0x02
    1af8:	2f ef       	ldi	r18, 0xFF	; 255
    1afa:	8f 3f       	cpi	r24, 0xFF	; 255
    1afc:	92 07       	cpc	r25, r18
    1afe:	39 f4       	brne	.+14     	; 0x1b0e <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1b00:	ed 81       	ldd	r30, Y+5	; 0x05
    1b02:	fe 81       	ldd	r31, Y+6	; 0x06
    1b04:	87 81       	ldd	r24, Z+7	; 0x07
    1b06:	90 85       	ldd	r25, Z+8	; 0x08
    1b08:	9c 83       	std	Y+4, r25	; 0x04
    1b0a:	8b 83       	std	Y+3, r24	; 0x03
    1b0c:	18 c0       	rjmp	.+48     	; 0x1b3e <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1b0e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b10:	9e 81       	ldd	r25, Y+6	; 0x06
    1b12:	03 96       	adiw	r24, 0x03	; 3
    1b14:	9c 83       	std	Y+4, r25	; 0x04
    1b16:	8b 83       	std	Y+3, r24	; 0x03
    1b18:	06 c0       	rjmp	.+12     	; 0x1b26 <vListInsert+0x5a>
    1b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b1e:	82 81       	ldd	r24, Z+2	; 0x02
    1b20:	93 81       	ldd	r25, Z+3	; 0x03
    1b22:	9c 83       	std	Y+4, r25	; 0x04
    1b24:	8b 83       	std	Y+3, r24	; 0x03
    1b26:	eb 81       	ldd	r30, Y+3	; 0x03
    1b28:	fc 81       	ldd	r31, Y+4	; 0x04
    1b2a:	02 80       	ldd	r0, Z+2	; 0x02
    1b2c:	f3 81       	ldd	r31, Z+3	; 0x03
    1b2e:	e0 2d       	mov	r30, r0
    1b30:	20 81       	ld	r18, Z
    1b32:	31 81       	ldd	r19, Z+1	; 0x01
    1b34:	89 81       	ldd	r24, Y+1	; 0x01
    1b36:	9a 81       	ldd	r25, Y+2	; 0x02
    1b38:	82 17       	cp	r24, r18
    1b3a:	93 07       	cpc	r25, r19
    1b3c:	70 f7       	brcc	.-36     	; 0x1b1a <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1b3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b40:	fc 81       	ldd	r31, Y+4	; 0x04
    1b42:	82 81       	ldd	r24, Z+2	; 0x02
    1b44:	93 81       	ldd	r25, Z+3	; 0x03
    1b46:	ef 81       	ldd	r30, Y+7	; 0x07
    1b48:	f8 85       	ldd	r31, Y+8	; 0x08
    1b4a:	93 83       	std	Z+3, r25	; 0x03
    1b4c:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1b4e:	ef 81       	ldd	r30, Y+7	; 0x07
    1b50:	f8 85       	ldd	r31, Y+8	; 0x08
    1b52:	02 80       	ldd	r0, Z+2	; 0x02
    1b54:	f3 81       	ldd	r31, Z+3	; 0x03
    1b56:	e0 2d       	mov	r30, r0
    1b58:	8f 81       	ldd	r24, Y+7	; 0x07
    1b5a:	98 85       	ldd	r25, Y+8	; 0x08
    1b5c:	95 83       	std	Z+5, r25	; 0x05
    1b5e:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1b60:	ef 81       	ldd	r30, Y+7	; 0x07
    1b62:	f8 85       	ldd	r31, Y+8	; 0x08
    1b64:	8b 81       	ldd	r24, Y+3	; 0x03
    1b66:	9c 81       	ldd	r25, Y+4	; 0x04
    1b68:	95 83       	std	Z+5, r25	; 0x05
    1b6a:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b70:	8f 81       	ldd	r24, Y+7	; 0x07
    1b72:	98 85       	ldd	r25, Y+8	; 0x08
    1b74:	93 83       	std	Z+3, r25	; 0x03
    1b76:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1b78:	ef 81       	ldd	r30, Y+7	; 0x07
    1b7a:	f8 85       	ldd	r31, Y+8	; 0x08
    1b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b80:	91 87       	std	Z+9, r25	; 0x09
    1b82:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1b84:	ed 81       	ldd	r30, Y+5	; 0x05
    1b86:	fe 81       	ldd	r31, Y+6	; 0x06
    1b88:	80 81       	ld	r24, Z
    1b8a:	8f 5f       	subi	r24, 0xFF	; 255
    1b8c:	ed 81       	ldd	r30, Y+5	; 0x05
    1b8e:	fe 81       	ldd	r31, Y+6	; 0x06
    1b90:	80 83       	st	Z, r24
}
    1b92:	28 96       	adiw	r28, 0x08	; 8
    1b94:	0f b6       	in	r0, 0x3f	; 63
    1b96:	f8 94       	cli
    1b98:	de bf       	out	0x3e, r29	; 62
    1b9a:	0f be       	out	0x3f, r0	; 63
    1b9c:	cd bf       	out	0x3d, r28	; 61
    1b9e:	cf 91       	pop	r28
    1ba0:	df 91       	pop	r29
    1ba2:	08 95       	ret

00001ba4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1ba4:	df 93       	push	r29
    1ba6:	cf 93       	push	r28
    1ba8:	00 d0       	rcall	.+0      	; 0x1baa <uxListRemove+0x6>
    1baa:	00 d0       	rcall	.+0      	; 0x1bac <uxListRemove+0x8>
    1bac:	cd b7       	in	r28, 0x3d	; 61
    1bae:	de b7       	in	r29, 0x3e	; 62
    1bb0:	9c 83       	std	Y+4, r25	; 0x04
    1bb2:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb8:	80 85       	ldd	r24, Z+8	; 0x08
    1bba:	91 85       	ldd	r25, Z+9	; 0x09
    1bbc:	9a 83       	std	Y+2, r25	; 0x02
    1bbe:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1bc0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bc2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bc4:	a2 81       	ldd	r26, Z+2	; 0x02
    1bc6:	b3 81       	ldd	r27, Z+3	; 0x03
    1bc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bca:	fc 81       	ldd	r31, Y+4	; 0x04
    1bcc:	84 81       	ldd	r24, Z+4	; 0x04
    1bce:	95 81       	ldd	r25, Z+5	; 0x05
    1bd0:	15 96       	adiw	r26, 0x05	; 5
    1bd2:	9c 93       	st	X, r25
    1bd4:	8e 93       	st	-X, r24
    1bd6:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bda:	fc 81       	ldd	r31, Y+4	; 0x04
    1bdc:	a4 81       	ldd	r26, Z+4	; 0x04
    1bde:	b5 81       	ldd	r27, Z+5	; 0x05
    1be0:	eb 81       	ldd	r30, Y+3	; 0x03
    1be2:	fc 81       	ldd	r31, Y+4	; 0x04
    1be4:	82 81       	ldd	r24, Z+2	; 0x02
    1be6:	93 81       	ldd	r25, Z+3	; 0x03
    1be8:	13 96       	adiw	r26, 0x03	; 3
    1bea:	9c 93       	st	X, r25
    1bec:	8e 93       	st	-X, r24
    1bee:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf4:	21 81       	ldd	r18, Z+1	; 0x01
    1bf6:	32 81       	ldd	r19, Z+2	; 0x02
    1bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    1bfc:	28 17       	cp	r18, r24
    1bfe:	39 07       	cpc	r19, r25
    1c00:	41 f4       	brne	.+16     	; 0x1c12 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c02:	eb 81       	ldd	r30, Y+3	; 0x03
    1c04:	fc 81       	ldd	r31, Y+4	; 0x04
    1c06:	84 81       	ldd	r24, Z+4	; 0x04
    1c08:	95 81       	ldd	r25, Z+5	; 0x05
    1c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c0e:	92 83       	std	Z+2, r25	; 0x02
    1c10:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1c12:	eb 81       	ldd	r30, Y+3	; 0x03
    1c14:	fc 81       	ldd	r31, Y+4	; 0x04
    1c16:	11 86       	std	Z+9, r1	; 0x09
    1c18:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1c1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c1e:	80 81       	ld	r24, Z
    1c20:	81 50       	subi	r24, 0x01	; 1
    1c22:	e9 81       	ldd	r30, Y+1	; 0x01
    1c24:	fa 81       	ldd	r31, Y+2	; 0x02
    1c26:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    1c28:	e9 81       	ldd	r30, Y+1	; 0x01
    1c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c2c:	80 81       	ld	r24, Z
}
    1c2e:	0f 90       	pop	r0
    1c30:	0f 90       	pop	r0
    1c32:	0f 90       	pop	r0
    1c34:	0f 90       	pop	r0
    1c36:	cf 91       	pop	r28
    1c38:	df 91       	pop	r29
    1c3a:	08 95       	ret

00001c3c <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1c3c:	df 93       	push	r29
    1c3e:	cf 93       	push	r28
    1c40:	00 d0       	rcall	.+0      	; 0x1c42 <xQueueGenericReset+0x6>
    1c42:	00 d0       	rcall	.+0      	; 0x1c44 <xQueueGenericReset+0x8>
    1c44:	00 d0       	rcall	.+0      	; 0x1c46 <xQueueGenericReset+0xa>
    1c46:	cd b7       	in	r28, 0x3d	; 61
    1c48:	de b7       	in	r29, 0x3e	; 62
    1c4a:	9d 83       	std	Y+5, r25	; 0x05
    1c4c:	8c 83       	std	Y+4, r24	; 0x04
    1c4e:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1c50:	81 e0       	ldi	r24, 0x01	; 1
    1c52:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1c54:	8c 81       	ldd	r24, Y+4	; 0x04
    1c56:	9d 81       	ldd	r25, Y+5	; 0x05
    1c58:	9a 83       	std	Y+2, r25	; 0x02
    1c5a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1c5c:	89 81       	ldd	r24, Y+1	; 0x01
    1c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c60:	00 97       	sbiw	r24, 0x00	; 0
    1c62:	09 f4       	brne	.+2      	; 0x1c66 <xQueueGenericReset+0x2a>
    1c64:	8b c0       	rjmp	.+278    	; 0x1d7c <xQueueGenericReset+0x140>
    1c66:	e9 81       	ldd	r30, Y+1	; 0x01
    1c68:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c6c:	88 23       	and	r24, r24
    1c6e:	09 f4       	brne	.+2      	; 0x1c72 <xQueueGenericReset+0x36>
    1c70:	85 c0       	rjmp	.+266    	; 0x1d7c <xQueueGenericReset+0x140>
    1c72:	e9 81       	ldd	r30, Y+1	; 0x01
    1c74:	fa 81       	ldd	r31, Y+2	; 0x02
    1c76:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c78:	28 2f       	mov	r18, r24
    1c7a:	30 e0       	ldi	r19, 0x00	; 0
    1c7c:	8f ef       	ldi	r24, 0xFF	; 255
    1c7e:	9f e7       	ldi	r25, 0x7F	; 127
    1c80:	b9 01       	movw	r22, r18
    1c82:	0e 94 73 3d 	call	0x7ae6	; 0x7ae6 <__udivmodhi4>
    1c86:	cb 01       	movw	r24, r22
    1c88:	9c 01       	movw	r18, r24
    1c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c90:	88 2f       	mov	r24, r24
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	28 17       	cp	r18, r24
    1c96:	39 07       	cpc	r19, r25
    1c98:	08 f4       	brcc	.+2      	; 0x1c9c <xQueueGenericReset+0x60>
    1c9a:	70 c0       	rjmp	.+224    	; 0x1d7c <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1c9c:	0f b6       	in	r0, 0x3f	; 63
    1c9e:	f8 94       	cli
    1ca0:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca6:	40 81       	ld	r20, Z
    1ca8:	51 81       	ldd	r21, Z+1	; 0x01
    1caa:	e9 81       	ldd	r30, Y+1	; 0x01
    1cac:	fa 81       	ldd	r31, Y+2	; 0x02
    1cae:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cb0:	28 2f       	mov	r18, r24
    1cb2:	30 e0       	ldi	r19, 0x00	; 0
    1cb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cba:	88 2f       	mov	r24, r24
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	bc 01       	movw	r22, r24
    1cc0:	26 9f       	mul	r18, r22
    1cc2:	c0 01       	movw	r24, r0
    1cc4:	27 9f       	mul	r18, r23
    1cc6:	90 0d       	add	r25, r0
    1cc8:	36 9f       	mul	r19, r22
    1cca:	90 0d       	add	r25, r0
    1ccc:	11 24       	eor	r1, r1
    1cce:	84 0f       	add	r24, r20
    1cd0:	95 1f       	adc	r25, r21
    1cd2:	e9 81       	ldd	r30, Y+1	; 0x01
    1cd4:	fa 81       	ldd	r31, Y+2	; 0x02
    1cd6:	95 83       	std	Z+5, r25	; 0x05
    1cd8:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1ce0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce4:	80 81       	ld	r24, Z
    1ce6:	91 81       	ldd	r25, Z+1	; 0x01
    1ce8:	e9 81       	ldd	r30, Y+1	; 0x01
    1cea:	fa 81       	ldd	r31, Y+2	; 0x02
    1cec:	93 83       	std	Z+3, r25	; 0x03
    1cee:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1cf0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf4:	40 81       	ld	r20, Z
    1cf6:	51 81       	ldd	r21, Z+1	; 0x01
    1cf8:	e9 81       	ldd	r30, Y+1	; 0x01
    1cfa:	fa 81       	ldd	r31, Y+2	; 0x02
    1cfc:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cfe:	88 2f       	mov	r24, r24
    1d00:	90 e0       	ldi	r25, 0x00	; 0
    1d02:	9c 01       	movw	r18, r24
    1d04:	21 50       	subi	r18, 0x01	; 1
    1d06:	30 40       	sbci	r19, 0x00	; 0
    1d08:	e9 81       	ldd	r30, Y+1	; 0x01
    1d0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d0c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d0e:	88 2f       	mov	r24, r24
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	bc 01       	movw	r22, r24
    1d14:	26 9f       	mul	r18, r22
    1d16:	c0 01       	movw	r24, r0
    1d18:	27 9f       	mul	r18, r23
    1d1a:	90 0d       	add	r25, r0
    1d1c:	36 9f       	mul	r19, r22
    1d1e:	90 0d       	add	r25, r0
    1d20:	11 24       	eor	r1, r1
    1d22:	84 0f       	add	r24, r20
    1d24:	95 1f       	adc	r25, r21
    1d26:	e9 81       	ldd	r30, Y+1	; 0x01
    1d28:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2a:	97 83       	std	Z+7, r25	; 0x07
    1d2c:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1d2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d30:	fa 81       	ldd	r31, Y+2	; 0x02
    1d32:	8f ef       	ldi	r24, 0xFF	; 255
    1d34:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1d36:	e9 81       	ldd	r30, Y+1	; 0x01
    1d38:	fa 81       	ldd	r31, Y+2	; 0x02
    1d3a:	8f ef       	ldi	r24, 0xFF	; 255
    1d3c:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1d3e:	8e 81       	ldd	r24, Y+6	; 0x06
    1d40:	88 23       	and	r24, r24
    1d42:	79 f4       	brne	.+30     	; 0x1d62 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d44:	e9 81       	ldd	r30, Y+1	; 0x01
    1d46:	fa 81       	ldd	r31, Y+2	; 0x02
    1d48:	80 85       	ldd	r24, Z+8	; 0x08
    1d4a:	88 23       	and	r24, r24
    1d4c:	a1 f0       	breq	.+40     	; 0x1d76 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d4e:	89 81       	ldd	r24, Y+1	; 0x01
    1d50:	9a 81       	ldd	r25, Y+2	; 0x02
    1d52:	08 96       	adiw	r24, 0x08	; 8
    1d54:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    1d58:	88 23       	and	r24, r24
    1d5a:	69 f0       	breq	.+26     	; 0x1d76 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1d5c:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    1d60:	0a c0       	rjmp	.+20     	; 0x1d76 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1d62:	89 81       	ldd	r24, Y+1	; 0x01
    1d64:	9a 81       	ldd	r25, Y+2	; 0x02
    1d66:	08 96       	adiw	r24, 0x08	; 8
    1d68:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1d6c:	89 81       	ldd	r24, Y+1	; 0x01
    1d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d70:	41 96       	adiw	r24, 0x11	; 17
    1d72:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1d76:	0f 90       	pop	r0
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	01 c0       	rjmp	.+2      	; 0x1d7e <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1d7c:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1d7e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1d80:	26 96       	adiw	r28, 0x06	; 6
    1d82:	0f b6       	in	r0, 0x3f	; 63
    1d84:	f8 94       	cli
    1d86:	de bf       	out	0x3e, r29	; 62
    1d88:	0f be       	out	0x3f, r0	; 63
    1d8a:	cd bf       	out	0x3d, r28	; 61
    1d8c:	cf 91       	pop	r28
    1d8e:	df 91       	pop	r29
    1d90:	08 95       	ret

00001d92 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1d92:	0f 93       	push	r16
    1d94:	1f 93       	push	r17
    1d96:	df 93       	push	r29
    1d98:	cf 93       	push	r28
    1d9a:	cd b7       	in	r28, 0x3d	; 61
    1d9c:	de b7       	in	r29, 0x3e	; 62
    1d9e:	29 97       	sbiw	r28, 0x09	; 9
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	f8 94       	cli
    1da4:	de bf       	out	0x3e, r29	; 62
    1da6:	0f be       	out	0x3f, r0	; 63
    1da8:	cd bf       	out	0x3d, r28	; 61
    1daa:	8f 83       	std	Y+7, r24	; 0x07
    1dac:	68 87       	std	Y+8, r22	; 0x08
    1dae:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    1db0:	1e 82       	std	Y+6, r1	; 0x06
    1db2:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1db4:	8f 81       	ldd	r24, Y+7	; 0x07
    1db6:	88 23       	and	r24, r24
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <xQueueGenericCreate+0x2a>
    1dba:	52 c0       	rjmp	.+164    	; 0x1e60 <xQueueGenericCreate+0xce>
    1dbc:	8f 81       	ldd	r24, Y+7	; 0x07
    1dbe:	28 2f       	mov	r18, r24
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	8f ef       	ldi	r24, 0xFF	; 255
    1dc4:	9f e7       	ldi	r25, 0x7F	; 127
    1dc6:	b9 01       	movw	r22, r18
    1dc8:	0e 94 73 3d 	call	0x7ae6	; 0x7ae6 <__udivmodhi4>
    1dcc:	cb 01       	movw	r24, r22
    1dce:	9c 01       	movw	r18, r24
    1dd0:	88 85       	ldd	r24, Y+8	; 0x08
    1dd2:	88 2f       	mov	r24, r24
    1dd4:	90 e0       	ldi	r25, 0x00	; 0
    1dd6:	28 17       	cp	r18, r24
    1dd8:	39 07       	cpc	r19, r25
    1dda:	08 f4       	brcc	.+2      	; 0x1dde <xQueueGenericCreate+0x4c>
    1ddc:	41 c0       	rjmp	.+130    	; 0x1e60 <xQueueGenericCreate+0xce>
    1dde:	8f 81       	ldd	r24, Y+7	; 0x07
    1de0:	28 2f       	mov	r18, r24
    1de2:	30 e0       	ldi	r19, 0x00	; 0
    1de4:	88 85       	ldd	r24, Y+8	; 0x08
    1de6:	88 2f       	mov	r24, r24
    1de8:	90 e0       	ldi	r25, 0x00	; 0
    1dea:	ac 01       	movw	r20, r24
    1dec:	24 9f       	mul	r18, r20
    1dee:	c0 01       	movw	r24, r0
    1df0:	25 9f       	mul	r18, r21
    1df2:	90 0d       	add	r25, r0
    1df4:	34 9f       	mul	r19, r20
    1df6:	90 0d       	add	r25, r0
    1df8:	11 24       	eor	r1, r1
    1dfa:	5f e7       	ldi	r21, 0x7F	; 127
    1dfc:	81 3e       	cpi	r24, 0xE1	; 225
    1dfe:	95 07       	cpc	r25, r21
    1e00:	78 f5       	brcc	.+94     	; 0x1e60 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e02:	8f 81       	ldd	r24, Y+7	; 0x07
    1e04:	28 2f       	mov	r18, r24
    1e06:	30 e0       	ldi	r19, 0x00	; 0
    1e08:	88 85       	ldd	r24, Y+8	; 0x08
    1e0a:	88 2f       	mov	r24, r24
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	ac 01       	movw	r20, r24
    1e10:	24 9f       	mul	r18, r20
    1e12:	c0 01       	movw	r24, r0
    1e14:	25 9f       	mul	r18, r21
    1e16:	90 0d       	add	r25, r0
    1e18:	34 9f       	mul	r19, r20
    1e1a:	90 0d       	add	r25, r0
    1e1c:	11 24       	eor	r1, r1
    1e1e:	9c 83       	std	Y+4, r25	; 0x04
    1e20:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1e22:	8b 81       	ldd	r24, Y+3	; 0x03
    1e24:	9c 81       	ldd	r25, Y+4	; 0x04
    1e26:	4f 96       	adiw	r24, 0x1f	; 31
    1e28:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    1e2c:	9e 83       	std	Y+6, r25	; 0x06
    1e2e:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1e30:	8d 81       	ldd	r24, Y+5	; 0x05
    1e32:	9e 81       	ldd	r25, Y+6	; 0x06
    1e34:	00 97       	sbiw	r24, 0x00	; 0
    1e36:	a1 f0       	breq	.+40     	; 0x1e60 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1e38:	8d 81       	ldd	r24, Y+5	; 0x05
    1e3a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e3c:	9a 83       	std	Y+2, r25	; 0x02
    1e3e:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e40:	89 81       	ldd	r24, Y+1	; 0x01
    1e42:	9a 81       	ldd	r25, Y+2	; 0x02
    1e44:	4f 96       	adiw	r24, 0x1f	; 31
    1e46:	9a 83       	std	Y+2, r25	; 0x02
    1e48:	89 83       	std	Y+1, r24	; 0x01
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1e4a:	29 81       	ldd	r18, Y+1	; 0x01
    1e4c:	3a 81       	ldd	r19, Y+2	; 0x02
    1e4e:	ed 81       	ldd	r30, Y+5	; 0x05
    1e50:	fe 81       	ldd	r31, Y+6	; 0x06
    1e52:	8f 81       	ldd	r24, Y+7	; 0x07
    1e54:	68 85       	ldd	r22, Y+8	; 0x08
    1e56:	a9 01       	movw	r20, r18
    1e58:	29 85       	ldd	r18, Y+9	; 0x09
    1e5a:	8f 01       	movw	r16, r30
    1e5c:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1e60:	8d 81       	ldd	r24, Y+5	; 0x05
    1e62:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1e64:	29 96       	adiw	r28, 0x09	; 9
    1e66:	0f b6       	in	r0, 0x3f	; 63
    1e68:	f8 94       	cli
    1e6a:	de bf       	out	0x3e, r29	; 62
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	cd bf       	out	0x3d, r28	; 61
    1e70:	cf 91       	pop	r28
    1e72:	df 91       	pop	r29
    1e74:	1f 91       	pop	r17
    1e76:	0f 91       	pop	r16
    1e78:	08 95       	ret

00001e7a <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    1e7a:	0f 93       	push	r16
    1e7c:	1f 93       	push	r17
    1e7e:	df 93       	push	r29
    1e80:	cf 93       	push	r28
    1e82:	cd b7       	in	r28, 0x3d	; 61
    1e84:	de b7       	in	r29, 0x3e	; 62
    1e86:	27 97       	sbiw	r28, 0x07	; 7
    1e88:	0f b6       	in	r0, 0x3f	; 63
    1e8a:	f8 94       	cli
    1e8c:	de bf       	out	0x3e, r29	; 62
    1e8e:	0f be       	out	0x3f, r0	; 63
    1e90:	cd bf       	out	0x3d, r28	; 61
    1e92:	89 83       	std	Y+1, r24	; 0x01
    1e94:	6a 83       	std	Y+2, r22	; 0x02
    1e96:	5c 83       	std	Y+4, r21	; 0x04
    1e98:	4b 83       	std	Y+3, r20	; 0x03
    1e9a:	2d 83       	std	Y+5, r18	; 0x05
    1e9c:	1f 83       	std	Y+7, r17	; 0x07
    1e9e:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1ea0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea2:	88 23       	and	r24, r24
    1ea4:	39 f4       	brne	.+14     	; 0x1eb4 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1ea6:	8e 81       	ldd	r24, Y+6	; 0x06
    1ea8:	9f 81       	ldd	r25, Y+7	; 0x07
    1eaa:	ee 81       	ldd	r30, Y+6	; 0x06
    1eac:	ff 81       	ldd	r31, Y+7	; 0x07
    1eae:	91 83       	std	Z+1, r25	; 0x01
    1eb0:	80 83       	st	Z, r24
    1eb2:	06 c0       	rjmp	.+12     	; 0x1ec0 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb8:	ee 81       	ldd	r30, Y+6	; 0x06
    1eba:	ff 81       	ldd	r31, Y+7	; 0x07
    1ebc:	91 83       	std	Z+1, r25	; 0x01
    1ebe:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1ec0:	ee 81       	ldd	r30, Y+6	; 0x06
    1ec2:	ff 81       	ldd	r31, Y+7	; 0x07
    1ec4:	89 81       	ldd	r24, Y+1	; 0x01
    1ec6:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    1ec8:	ee 81       	ldd	r30, Y+6	; 0x06
    1eca:	ff 81       	ldd	r31, Y+7	; 0x07
    1ecc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ece:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ed0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ed2:	9f 81       	ldd	r25, Y+7	; 0x07
    1ed4:	61 e0       	ldi	r22, 0x01	; 1
    1ed6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    1eda:	27 96       	adiw	r28, 0x07	; 7
    1edc:	0f b6       	in	r0, 0x3f	; 63
    1ede:	f8 94       	cli
    1ee0:	de bf       	out	0x3e, r29	; 62
    1ee2:	0f be       	out	0x3f, r0	; 63
    1ee4:	cd bf       	out	0x3d, r28	; 61
    1ee6:	cf 91       	pop	r28
    1ee8:	df 91       	pop	r29
    1eea:	1f 91       	pop	r17
    1eec:	0f 91       	pop	r16
    1eee:	08 95       	ret

00001ef0 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    1ef0:	df 93       	push	r29
    1ef2:	cf 93       	push	r28
    1ef4:	cd b7       	in	r28, 0x3d	; 61
    1ef6:	de b7       	in	r29, 0x3e	; 62
    1ef8:	2f 97       	sbiw	r28, 0x0f	; 15
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	f8 94       	cli
    1efe:	de bf       	out	0x3e, r29	; 62
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	cd bf       	out	0x3d, r28	; 61
    1f04:	99 87       	std	Y+9, r25	; 0x09
    1f06:	88 87       	std	Y+8, r24	; 0x08
    1f08:	7b 87       	std	Y+11, r23	; 0x0b
    1f0a:	6a 87       	std	Y+10, r22	; 0x0a
    1f0c:	5d 87       	std	Y+13, r21	; 0x0d
    1f0e:	4c 87       	std	Y+12, r20	; 0x0c
    1f10:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1f12:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1f14:	88 85       	ldd	r24, Y+8	; 0x08
    1f16:	99 85       	ldd	r25, Y+9	; 0x09
    1f18:	9a 83       	std	Y+2, r25	; 0x02
    1f1a:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1f1c:	0f b6       	in	r0, 0x3f	; 63
    1f1e:	f8 94       	cli
    1f20:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1f22:	e9 81       	ldd	r30, Y+1	; 0x01
    1f24:	fa 81       	ldd	r31, Y+2	; 0x02
    1f26:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f28:	e9 81       	ldd	r30, Y+1	; 0x01
    1f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f2c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f2e:	98 17       	cp	r25, r24
    1f30:	18 f0       	brcs	.+6      	; 0x1f38 <xQueueGenericSend+0x48>
    1f32:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f34:	82 30       	cpi	r24, 0x02	; 2
    1f36:	11 f5       	brne	.+68     	; 0x1f7c <xQueueGenericSend+0x8c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1f38:	89 81       	ldd	r24, Y+1	; 0x01
    1f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3c:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f3e:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f40:	b9 01       	movw	r22, r18
    1f42:	4e 85       	ldd	r20, Y+14	; 0x0e
    1f44:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <prvCopyDataToQueue>
    1f48:	8b 83       	std	Y+3, r24	; 0x03

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f4e:	81 89       	ldd	r24, Z+17	; 0x11
    1f50:	88 23       	and	r24, r24
    1f52:	51 f0       	breq	.+20     	; 0x1f68 <xQueueGenericSend+0x78>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f54:	89 81       	ldd	r24, Y+1	; 0x01
    1f56:	9a 81       	ldd	r25, Y+2	; 0x02
    1f58:	41 96       	adiw	r24, 0x11	; 17
    1f5a:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    1f5e:	88 23       	and	r24, r24
    1f60:	41 f0       	breq	.+16     	; 0x1f72 <xQueueGenericSend+0x82>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    1f62:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    1f66:	05 c0       	rjmp	.+10     	; 0x1f72 <xQueueGenericSend+0x82>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    1f68:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6a:	88 23       	and	r24, r24
    1f6c:	11 f0       	breq	.+4      	; 0x1f72 <xQueueGenericSend+0x82>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1f6e:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1f72:	0f 90       	pop	r0
    1f74:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1f76:	81 e0       	ldi	r24, 0x01	; 1
    1f78:	8f 87       	std	Y+15, r24	; 0x0f
    1f7a:	5c c0       	rjmp	.+184    	; 0x2034 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1f7c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f7e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f80:	00 97       	sbiw	r24, 0x00	; 0
    1f82:	21 f4       	brne	.+8      	; 0x1f8c <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1f84:	0f 90       	pop	r0
    1f86:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    1f88:	1f 86       	std	Y+15, r1	; 0x0f
    1f8a:	54 c0       	rjmp	.+168    	; 0x2034 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    1f8c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f8e:	88 23       	and	r24, r24
    1f90:	31 f4       	brne	.+12     	; 0x1f9e <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1f92:	ce 01       	movw	r24, r28
    1f94:	05 96       	adiw	r24, 0x05	; 5
    1f96:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1f9a:	81 e0       	ldi	r24, 0x01	; 1
    1f9c:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1f9e:	0f 90       	pop	r0
    1fa0:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1fa2:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1fa6:	0f b6       	in	r0, 0x3f	; 63
    1fa8:	f8 94       	cli
    1faa:	0f 92       	push	r0
    1fac:	e9 81       	ldd	r30, Y+1	; 0x01
    1fae:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fb2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fb4:	19 f4       	brne	.+6      	; 0x1fbc <xQueueGenericSend+0xcc>
    1fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fba:	15 8e       	std	Z+29, r1	; 0x1d
    1fbc:	e9 81       	ldd	r30, Y+1	; 0x01
    1fbe:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fc2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fc4:	19 f4       	brne	.+6      	; 0x1fcc <xQueueGenericSend+0xdc>
    1fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fca:	16 8e       	std	Z+30, r1	; 0x1e
    1fcc:	0f 90       	pop	r0
    1fce:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fd0:	ce 01       	movw	r24, r28
    1fd2:	05 96       	adiw	r24, 0x05	; 5
    1fd4:	9e 01       	movw	r18, r28
    1fd6:	24 5f       	subi	r18, 0xF4	; 244
    1fd8:	3f 4f       	sbci	r19, 0xFF	; 255
    1fda:	b9 01       	movw	r22, r18
    1fdc:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <xTaskCheckForTimeOut>
    1fe0:	88 23       	and	r24, r24
    1fe2:	09 f5       	brne	.+66     	; 0x2026 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1fe4:	89 81       	ldd	r24, Y+1	; 0x01
    1fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe8:	0e 94 5f 15 	call	0x2abe	; 0x2abe <prvIsQueueFull>
    1fec:	88 23       	and	r24, r24
    1fee:	a1 f0       	breq	.+40     	; 0x2018 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ff0:	89 81       	ldd	r24, Y+1	; 0x01
    1ff2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff4:	08 96       	adiw	r24, 0x08	; 8
    1ff6:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ff8:	3d 85       	ldd	r19, Y+13	; 0x0d
    1ffa:	b9 01       	movw	r22, r18
    1ffc:	0e 94 c0 24 	call	0x4980	; 0x4980 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2000:	89 81       	ldd	r24, Y+1	; 0x01
    2002:	9a 81       	ldd	r25, Y+2	; 0x02
    2004:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2008:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    200c:	88 23       	and	r24, r24
    200e:	09 f0       	breq	.+2      	; 0x2012 <xQueueGenericSend+0x122>
    2010:	85 cf       	rjmp	.-246    	; 0x1f1c <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2012:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    2016:	82 cf       	rjmp	.-252    	; 0x1f1c <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    2018:	89 81       	ldd	r24, Y+1	; 0x01
    201a:	9a 81       	ldd	r25, Y+2	; 0x02
    201c:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2020:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    2024:	7b cf       	rjmp	.-266    	; 0x1f1c <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2026:	89 81       	ldd	r24, Y+1	; 0x01
    2028:	9a 81       	ldd	r25, Y+2	; 0x02
    202a:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    202e:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    2032:	1f 86       	std	Y+15, r1	; 0x0f
    2034:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    2036:	2f 96       	adiw	r28, 0x0f	; 15
    2038:	0f b6       	in	r0, 0x3f	; 63
    203a:	f8 94       	cli
    203c:	de bf       	out	0x3e, r29	; 62
    203e:	0f be       	out	0x3f, r0	; 63
    2040:	cd bf       	out	0x3d, r28	; 61
    2042:	cf 91       	pop	r28
    2044:	df 91       	pop	r29
    2046:	08 95       	ret

00002048 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    2048:	df 93       	push	r29
    204a:	cf 93       	push	r28
    204c:	cd b7       	in	r28, 0x3d	; 61
    204e:	de b7       	in	r29, 0x3e	; 62
    2050:	2e 97       	sbiw	r28, 0x0e	; 14
    2052:	0f b6       	in	r0, 0x3f	; 63
    2054:	f8 94       	cli
    2056:	de bf       	out	0x3e, r29	; 62
    2058:	0f be       	out	0x3f, r0	; 63
    205a:	cd bf       	out	0x3d, r28	; 61
    205c:	99 87       	std	Y+9, r25	; 0x09
    205e:	88 87       	std	Y+8, r24	; 0x08
    2060:	7b 87       	std	Y+11, r23	; 0x0b
    2062:	6a 87       	std	Y+10, r22	; 0x0a
    2064:	5d 87       	std	Y+13, r21	; 0x0d
    2066:	4c 87       	std	Y+12, r20	; 0x0c
    2068:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    206a:	88 85       	ldd	r24, Y+8	; 0x08
    206c:	99 85       	ldd	r25, Y+9	; 0x09
    206e:	9d 83       	std	Y+5, r25	; 0x05
    2070:	8c 83       	std	Y+4, r24	; 0x04
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2072:	1e 82       	std	Y+6, r1	; 0x06
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2074:	ec 81       	ldd	r30, Y+4	; 0x04
    2076:	fd 81       	ldd	r31, Y+5	; 0x05
    2078:	92 8d       	ldd	r25, Z+26	; 0x1a
    207a:	ec 81       	ldd	r30, Y+4	; 0x04
    207c:	fd 81       	ldd	r31, Y+5	; 0x05
    207e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2080:	98 17       	cp	r25, r24
    2082:	18 f0       	brcs	.+6      	; 0x208a <xQueueGenericSendFromISR+0x42>
    2084:	8e 85       	ldd	r24, Y+14	; 0x0e
    2086:	82 30       	cpi	r24, 0x02	; 2
    2088:	b9 f5       	brne	.+110    	; 0x20f8 <xQueueGenericSendFromISR+0xb0>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    208a:	ec 81       	ldd	r30, Y+4	; 0x04
    208c:	fd 81       	ldd	r31, Y+5	; 0x05
    208e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2090:	8b 83       	std	Y+3, r24	; 0x03
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2092:	ec 81       	ldd	r30, Y+4	; 0x04
    2094:	fd 81       	ldd	r31, Y+5	; 0x05
    2096:	82 8d       	ldd	r24, Z+26	; 0x1a
    2098:	8a 83       	std	Y+2, r24	; 0x02
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    209a:	8c 81       	ldd	r24, Y+4	; 0x04
    209c:	9d 81       	ldd	r25, Y+5	; 0x05
    209e:	2a 85       	ldd	r18, Y+10	; 0x0a
    20a0:	3b 85       	ldd	r19, Y+11	; 0x0b
    20a2:	b9 01       	movw	r22, r18
    20a4:	4e 85       	ldd	r20, Y+14	; 0x0e
    20a6:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    20aa:	8b 81       	ldd	r24, Y+3	; 0x03
    20ac:	8f 3f       	cpi	r24, 0xFF	; 255
    20ae:	a9 f4       	brne	.+42     	; 0x20da <xQueueGenericSendFromISR+0x92>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20b0:	ec 81       	ldd	r30, Y+4	; 0x04
    20b2:	fd 81       	ldd	r31, Y+5	; 0x05
    20b4:	81 89       	ldd	r24, Z+17	; 0x11
    20b6:	88 23       	and	r24, r24
    20b8:	e1 f0       	breq	.+56     	; 0x20f2 <xQueueGenericSendFromISR+0xaa>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20ba:	8c 81       	ldd	r24, Y+4	; 0x04
    20bc:	9d 81       	ldd	r25, Y+5	; 0x05
    20be:	41 96       	adiw	r24, 0x11	; 17
    20c0:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    20c4:	88 23       	and	r24, r24
    20c6:	a9 f0       	breq	.+42     	; 0x20f2 <xQueueGenericSendFromISR+0xaa>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    20c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    20ca:	9d 85       	ldd	r25, Y+13	; 0x0d
    20cc:	00 97       	sbiw	r24, 0x00	; 0
    20ce:	89 f0       	breq	.+34     	; 0x20f2 <xQueueGenericSendFromISR+0xaa>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    20d0:	ec 85       	ldd	r30, Y+12	; 0x0c
    20d2:	fd 85       	ldd	r31, Y+13	; 0x0d
    20d4:	81 e0       	ldi	r24, 0x01	; 1
    20d6:	80 83       	st	Z, r24
    20d8:	0c c0       	rjmp	.+24     	; 0x20f2 <xQueueGenericSendFromISR+0xaa>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    20da:	0e 94 66 22 	call	0x44cc	; 0x44cc <uxTaskGetNumberOfTasks>
    20de:	89 83       	std	Y+1, r24	; 0x01
    20e0:	9b 81       	ldd	r25, Y+3	; 0x03
    20e2:	89 81       	ldd	r24, Y+1	; 0x01
    20e4:	98 17       	cp	r25, r24
    20e6:	28 f4       	brcc	.+10     	; 0x20f2 <xQueueGenericSendFromISR+0xaa>
    20e8:	8b 81       	ldd	r24, Y+3	; 0x03
    20ea:	8f 5f       	subi	r24, 0xFF	; 255
    20ec:	ec 81       	ldd	r30, Y+4	; 0x04
    20ee:	fd 81       	ldd	r31, Y+5	; 0x05
    20f0:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    20f2:	81 e0       	ldi	r24, 0x01	; 1
    20f4:	8f 83       	std	Y+7, r24	; 0x07
    20f6:	01 c0       	rjmp	.+2      	; 0x20fa <xQueueGenericSendFromISR+0xb2>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    20f8:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    20fa:	8f 81       	ldd	r24, Y+7	; 0x07
}
    20fc:	2e 96       	adiw	r28, 0x0e	; 14
    20fe:	0f b6       	in	r0, 0x3f	; 63
    2100:	f8 94       	cli
    2102:	de bf       	out	0x3e, r29	; 62
    2104:	0f be       	out	0x3f, r0	; 63
    2106:	cd bf       	out	0x3d, r28	; 61
    2108:	cf 91       	pop	r28
    210a:	df 91       	pop	r29
    210c:	08 95       	ret

0000210e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    210e:	df 93       	push	r29
    2110:	cf 93       	push	r28
    2112:	cd b7       	in	r28, 0x3d	; 61
    2114:	de b7       	in	r29, 0x3e	; 62
    2116:	2b 97       	sbiw	r28, 0x0b	; 11
    2118:	0f b6       	in	r0, 0x3f	; 63
    211a:	f8 94       	cli
    211c:	de bf       	out	0x3e, r29	; 62
    211e:	0f be       	out	0x3f, r0	; 63
    2120:	cd bf       	out	0x3d, r28	; 61
    2122:	99 87       	std	Y+9, r25	; 0x09
    2124:	88 87       	std	Y+8, r24	; 0x08
    2126:	7b 87       	std	Y+11, r23	; 0x0b
    2128:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    212a:	88 85       	ldd	r24, Y+8	; 0x08
    212c:	99 85       	ldd	r25, Y+9	; 0x09
    212e:	9d 83       	std	Y+5, r25	; 0x05
    2130:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2132:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2134:	ec 81       	ldd	r30, Y+4	; 0x04
    2136:	fd 81       	ldd	r31, Y+5	; 0x05
    2138:	82 8d       	ldd	r24, Z+26	; 0x1a
    213a:	8b 83       	std	Y+3, r24	; 0x03

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    213c:	ec 81       	ldd	r30, Y+4	; 0x04
    213e:	fd 81       	ldd	r31, Y+5	; 0x05
    2140:	93 8d       	ldd	r25, Z+27	; 0x1b
    2142:	8b 81       	ldd	r24, Y+3	; 0x03
    2144:	89 17       	cp	r24, r25
    2146:	80 f5       	brcc	.+96     	; 0x21a8 <xQueueGiveFromISR+0x9a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2148:	ec 81       	ldd	r30, Y+4	; 0x04
    214a:	fd 81       	ldd	r31, Y+5	; 0x05
    214c:	86 8d       	ldd	r24, Z+30	; 0x1e
    214e:	8a 83       	std	Y+2, r24	; 0x02
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2150:	8b 81       	ldd	r24, Y+3	; 0x03
    2152:	8f 5f       	subi	r24, 0xFF	; 255
    2154:	ec 81       	ldd	r30, Y+4	; 0x04
    2156:	fd 81       	ldd	r31, Y+5	; 0x05
    2158:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    215a:	8a 81       	ldd	r24, Y+2	; 0x02
    215c:	8f 3f       	cpi	r24, 0xFF	; 255
    215e:	a9 f4       	brne	.+42     	; 0x218a <xQueueGiveFromISR+0x7c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2160:	ec 81       	ldd	r30, Y+4	; 0x04
    2162:	fd 81       	ldd	r31, Y+5	; 0x05
    2164:	81 89       	ldd	r24, Z+17	; 0x11
    2166:	88 23       	and	r24, r24
    2168:	e1 f0       	breq	.+56     	; 0x21a2 <xQueueGiveFromISR+0x94>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    216a:	8c 81       	ldd	r24, Y+4	; 0x04
    216c:	9d 81       	ldd	r25, Y+5	; 0x05
    216e:	41 96       	adiw	r24, 0x11	; 17
    2170:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    2174:	88 23       	and	r24, r24
    2176:	a9 f0       	breq	.+42     	; 0x21a2 <xQueueGiveFromISR+0x94>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    2178:	8a 85       	ldd	r24, Y+10	; 0x0a
    217a:	9b 85       	ldd	r25, Y+11	; 0x0b
    217c:	00 97       	sbiw	r24, 0x00	; 0
    217e:	89 f0       	breq	.+34     	; 0x21a2 <xQueueGiveFromISR+0x94>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    2180:	ea 85       	ldd	r30, Y+10	; 0x0a
    2182:	fb 85       	ldd	r31, Y+11	; 0x0b
    2184:	81 e0       	ldi	r24, 0x01	; 1
    2186:	80 83       	st	Z, r24
    2188:	0c c0       	rjmp	.+24     	; 0x21a2 <xQueueGiveFromISR+0x94>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    218a:	0e 94 66 22 	call	0x44cc	; 0x44cc <uxTaskGetNumberOfTasks>
    218e:	89 83       	std	Y+1, r24	; 0x01
    2190:	9a 81       	ldd	r25, Y+2	; 0x02
    2192:	89 81       	ldd	r24, Y+1	; 0x01
    2194:	98 17       	cp	r25, r24
    2196:	28 f4       	brcc	.+10     	; 0x21a2 <xQueueGiveFromISR+0x94>
    2198:	8a 81       	ldd	r24, Y+2	; 0x02
    219a:	8f 5f       	subi	r24, 0xFF	; 255
    219c:	ec 81       	ldd	r30, Y+4	; 0x04
    219e:	fd 81       	ldd	r31, Y+5	; 0x05
    21a0:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    21a2:	81 e0       	ldi	r24, 0x01	; 1
    21a4:	8f 83       	std	Y+7, r24	; 0x07
    21a6:	01 c0       	rjmp	.+2      	; 0x21aa <xQueueGiveFromISR+0x9c>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    21a8:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    21aa:	8f 81       	ldd	r24, Y+7	; 0x07
}
    21ac:	2b 96       	adiw	r28, 0x0b	; 11
    21ae:	0f b6       	in	r0, 0x3f	; 63
    21b0:	f8 94       	cli
    21b2:	de bf       	out	0x3e, r29	; 62
    21b4:	0f be       	out	0x3f, r0	; 63
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	cf 91       	pop	r28
    21ba:	df 91       	pop	r29
    21bc:	08 95       	ret

000021be <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    21be:	df 93       	push	r29
    21c0:	cf 93       	push	r28
    21c2:	cd b7       	in	r28, 0x3d	; 61
    21c4:	de b7       	in	r29, 0x3e	; 62
    21c6:	2e 97       	sbiw	r28, 0x0e	; 14
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	de bf       	out	0x3e, r29	; 62
    21ce:	0f be       	out	0x3f, r0	; 63
    21d0:	cd bf       	out	0x3d, r28	; 61
    21d2:	99 87       	std	Y+9, r25	; 0x09
    21d4:	88 87       	std	Y+8, r24	; 0x08
    21d6:	7b 87       	std	Y+11, r23	; 0x0b
    21d8:	6a 87       	std	Y+10, r22	; 0x0a
    21da:	5d 87       	std	Y+13, r21	; 0x0d
    21dc:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    21de:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    21e0:	88 85       	ldd	r24, Y+8	; 0x08
    21e2:	99 85       	ldd	r25, Y+9	; 0x09
    21e4:	9b 83       	std	Y+3, r25	; 0x03
    21e6:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    21e8:	0f b6       	in	r0, 0x3f	; 63
    21ea:	f8 94       	cli
    21ec:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21ee:	ea 81       	ldd	r30, Y+2	; 0x02
    21f0:	fb 81       	ldd	r31, Y+3	; 0x03
    21f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    21f4:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21f6:	89 81       	ldd	r24, Y+1	; 0x01
    21f8:	88 23       	and	r24, r24
    21fa:	f9 f0       	breq	.+62     	; 0x223a <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    21fc:	8a 81       	ldd	r24, Y+2	; 0x02
    21fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2200:	2a 85       	ldd	r18, Y+10	; 0x0a
    2202:	3b 85       	ldd	r19, Y+11	; 0x0b
    2204:	b9 01       	movw	r22, r18
    2206:	0e 94 89 14 	call	0x2912	; 0x2912 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    220a:	89 81       	ldd	r24, Y+1	; 0x01
    220c:	81 50       	subi	r24, 0x01	; 1
    220e:	ea 81       	ldd	r30, Y+2	; 0x02
    2210:	fb 81       	ldd	r31, Y+3	; 0x03
    2212:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2214:	ea 81       	ldd	r30, Y+2	; 0x02
    2216:	fb 81       	ldd	r31, Y+3	; 0x03
    2218:	80 85       	ldd	r24, Z+8	; 0x08
    221a:	88 23       	and	r24, r24
    221c:	49 f0       	breq	.+18     	; 0x2230 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    221e:	8a 81       	ldd	r24, Y+2	; 0x02
    2220:	9b 81       	ldd	r25, Y+3	; 0x03
    2222:	08 96       	adiw	r24, 0x08	; 8
    2224:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    2228:	88 23       	and	r24, r24
    222a:	11 f0       	breq	.+4      	; 0x2230 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    222c:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2230:	0f 90       	pop	r0
    2232:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2234:	81 e0       	ldi	r24, 0x01	; 1
    2236:	8e 87       	std	Y+14, r24	; 0x0e
    2238:	63 c0       	rjmp	.+198    	; 0x2300 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    223a:	8c 85       	ldd	r24, Y+12	; 0x0c
    223c:	9d 85       	ldd	r25, Y+13	; 0x0d
    223e:	00 97       	sbiw	r24, 0x00	; 0
    2240:	21 f4       	brne	.+8      	; 0x224a <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2242:	0f 90       	pop	r0
    2244:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2246:	1e 86       	std	Y+14, r1	; 0x0e
    2248:	5b c0       	rjmp	.+182    	; 0x2300 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    224a:	8c 81       	ldd	r24, Y+4	; 0x04
    224c:	88 23       	and	r24, r24
    224e:	31 f4       	brne	.+12     	; 0x225c <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2250:	ce 01       	movw	r24, r28
    2252:	05 96       	adiw	r24, 0x05	; 5
    2254:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    225c:	0f 90       	pop	r0
    225e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2260:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2264:	0f b6       	in	r0, 0x3f	; 63
    2266:	f8 94       	cli
    2268:	0f 92       	push	r0
    226a:	ea 81       	ldd	r30, Y+2	; 0x02
    226c:	fb 81       	ldd	r31, Y+3	; 0x03
    226e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2270:	8f 3f       	cpi	r24, 0xFF	; 255
    2272:	19 f4       	brne	.+6      	; 0x227a <xQueueReceive+0xbc>
    2274:	ea 81       	ldd	r30, Y+2	; 0x02
    2276:	fb 81       	ldd	r31, Y+3	; 0x03
    2278:	15 8e       	std	Z+29, r1	; 0x1d
    227a:	ea 81       	ldd	r30, Y+2	; 0x02
    227c:	fb 81       	ldd	r31, Y+3	; 0x03
    227e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2280:	8f 3f       	cpi	r24, 0xFF	; 255
    2282:	19 f4       	brne	.+6      	; 0x228a <xQueueReceive+0xcc>
    2284:	ea 81       	ldd	r30, Y+2	; 0x02
    2286:	fb 81       	ldd	r31, Y+3	; 0x03
    2288:	16 8e       	std	Z+30, r1	; 0x1e
    228a:	0f 90       	pop	r0
    228c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    228e:	ce 01       	movw	r24, r28
    2290:	05 96       	adiw	r24, 0x05	; 5
    2292:	9e 01       	movw	r18, r28
    2294:	24 5f       	subi	r18, 0xF4	; 244
    2296:	3f 4f       	sbci	r19, 0xFF	; 255
    2298:	b9 01       	movw	r22, r18
    229a:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <xTaskCheckForTimeOut>
    229e:	88 23       	and	r24, r24
    22a0:	09 f5       	brne	.+66     	; 0x22e4 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22a2:	8a 81       	ldd	r24, Y+2	; 0x02
    22a4:	9b 81       	ldd	r25, Y+3	; 0x03
    22a6:	0e 94 23 15 	call	0x2a46	; 0x2a46 <prvIsQueueEmpty>
    22aa:	88 23       	and	r24, r24
    22ac:	a1 f0       	breq	.+40     	; 0x22d6 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22ae:	8a 81       	ldd	r24, Y+2	; 0x02
    22b0:	9b 81       	ldd	r25, Y+3	; 0x03
    22b2:	41 96       	adiw	r24, 0x11	; 17
    22b4:	2c 85       	ldd	r18, Y+12	; 0x0c
    22b6:	3d 85       	ldd	r19, Y+13	; 0x0d
    22b8:	b9 01       	movw	r22, r18
    22ba:	0e 94 c0 24 	call	0x4980	; 0x4980 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    22be:	8a 81       	ldd	r24, Y+2	; 0x02
    22c0:	9b 81       	ldd	r25, Y+3	; 0x03
    22c2:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    22c6:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    22ca:	88 23       	and	r24, r24
    22cc:	09 f0       	breq	.+2      	; 0x22d0 <xQueueReceive+0x112>
    22ce:	8c cf       	rjmp	.-232    	; 0x21e8 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    22d0:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    22d4:	89 cf       	rjmp	.-238    	; 0x21e8 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    22d6:	8a 81       	ldd	r24, Y+2	; 0x02
    22d8:	9b 81       	ldd	r25, Y+3	; 0x03
    22da:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    22de:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    22e2:	82 cf       	rjmp	.-252    	; 0x21e8 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    22e4:	8a 81       	ldd	r24, Y+2	; 0x02
    22e6:	9b 81       	ldd	r25, Y+3	; 0x03
    22e8:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    22ec:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22f0:	8a 81       	ldd	r24, Y+2	; 0x02
    22f2:	9b 81       	ldd	r25, Y+3	; 0x03
    22f4:	0e 94 23 15 	call	0x2a46	; 0x2a46 <prvIsQueueEmpty>
    22f8:	88 23       	and	r24, r24
    22fa:	09 f4       	brne	.+2      	; 0x22fe <xQueueReceive+0x140>
    22fc:	75 cf       	rjmp	.-278    	; 0x21e8 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    22fe:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2300:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2302:	2e 96       	adiw	r28, 0x0e	; 14
    2304:	0f b6       	in	r0, 0x3f	; 63
    2306:	f8 94       	cli
    2308:	de bf       	out	0x3e, r29	; 62
    230a:	0f be       	out	0x3f, r0	; 63
    230c:	cd bf       	out	0x3d, r28	; 61
    230e:	cf 91       	pop	r28
    2310:	df 91       	pop	r29
    2312:	08 95       	ret

00002314 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2314:	df 93       	push	r29
    2316:	cf 93       	push	r28
    2318:	cd b7       	in	r28, 0x3d	; 61
    231a:	de b7       	in	r29, 0x3e	; 62
    231c:	2c 97       	sbiw	r28, 0x0c	; 12
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	f8 94       	cli
    2322:	de bf       	out	0x3e, r29	; 62
    2324:	0f be       	out	0x3f, r0	; 63
    2326:	cd bf       	out	0x3d, r28	; 61
    2328:	99 87       	std	Y+9, r25	; 0x09
    232a:	88 87       	std	Y+8, r24	; 0x08
    232c:	7b 87       	std	Y+11, r23	; 0x0b
    232e:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2330:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2332:	88 85       	ldd	r24, Y+8	; 0x08
    2334:	99 85       	ldd	r25, Y+9	; 0x09
    2336:	9b 83       	std	Y+3, r25	; 0x03
    2338:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    233a:	0f b6       	in	r0, 0x3f	; 63
    233c:	f8 94       	cli
    233e:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2340:	ea 81       	ldd	r30, Y+2	; 0x02
    2342:	fb 81       	ldd	r31, Y+3	; 0x03
    2344:	82 8d       	ldd	r24, Z+26	; 0x1a
    2346:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2348:	89 81       	ldd	r24, Y+1	; 0x01
    234a:	88 23       	and	r24, r24
    234c:	c1 f0       	breq	.+48     	; 0x237e <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    234e:	89 81       	ldd	r24, Y+1	; 0x01
    2350:	81 50       	subi	r24, 0x01	; 1
    2352:	ea 81       	ldd	r30, Y+2	; 0x02
    2354:	fb 81       	ldd	r31, Y+3	; 0x03
    2356:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2358:	ea 81       	ldd	r30, Y+2	; 0x02
    235a:	fb 81       	ldd	r31, Y+3	; 0x03
    235c:	80 85       	ldd	r24, Z+8	; 0x08
    235e:	88 23       	and	r24, r24
    2360:	49 f0       	breq	.+18     	; 0x2374 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2362:	8a 81       	ldd	r24, Y+2	; 0x02
    2364:	9b 81       	ldd	r25, Y+3	; 0x03
    2366:	08 96       	adiw	r24, 0x08	; 8
    2368:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    236c:	88 23       	and	r24, r24
    236e:	11 f0       	breq	.+4      	; 0x2374 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2370:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2374:	0f 90       	pop	r0
    2376:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2378:	81 e0       	ldi	r24, 0x01	; 1
    237a:	8c 87       	std	Y+12, r24	; 0x0c
    237c:	63 c0       	rjmp	.+198    	; 0x2444 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    237e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2380:	9b 85       	ldd	r25, Y+11	; 0x0b
    2382:	00 97       	sbiw	r24, 0x00	; 0
    2384:	21 f4       	brne	.+8      	; 0x238e <xQueueSemaphoreTake+0x7a>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2386:	0f 90       	pop	r0
    2388:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    238a:	1c 86       	std	Y+12, r1	; 0x0c
    238c:	5b c0       	rjmp	.+182    	; 0x2444 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    238e:	8c 81       	ldd	r24, Y+4	; 0x04
    2390:	88 23       	and	r24, r24
    2392:	31 f4       	brne	.+12     	; 0x23a0 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2394:	ce 01       	movw	r24, r28
    2396:	05 96       	adiw	r24, 0x05	; 5
    2398:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    239c:	81 e0       	ldi	r24, 0x01	; 1
    239e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    23a0:	0f 90       	pop	r0
    23a2:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    23a4:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    23a8:	0f b6       	in	r0, 0x3f	; 63
    23aa:	f8 94       	cli
    23ac:	0f 92       	push	r0
    23ae:	ea 81       	ldd	r30, Y+2	; 0x02
    23b0:	fb 81       	ldd	r31, Y+3	; 0x03
    23b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    23b4:	8f 3f       	cpi	r24, 0xFF	; 255
    23b6:	19 f4       	brne	.+6      	; 0x23be <xQueueSemaphoreTake+0xaa>
    23b8:	ea 81       	ldd	r30, Y+2	; 0x02
    23ba:	fb 81       	ldd	r31, Y+3	; 0x03
    23bc:	15 8e       	std	Z+29, r1	; 0x1d
    23be:	ea 81       	ldd	r30, Y+2	; 0x02
    23c0:	fb 81       	ldd	r31, Y+3	; 0x03
    23c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    23c4:	8f 3f       	cpi	r24, 0xFF	; 255
    23c6:	19 f4       	brne	.+6      	; 0x23ce <xQueueSemaphoreTake+0xba>
    23c8:	ea 81       	ldd	r30, Y+2	; 0x02
    23ca:	fb 81       	ldd	r31, Y+3	; 0x03
    23cc:	16 8e       	std	Z+30, r1	; 0x1e
    23ce:	0f 90       	pop	r0
    23d0:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23d2:	ce 01       	movw	r24, r28
    23d4:	05 96       	adiw	r24, 0x05	; 5
    23d6:	9e 01       	movw	r18, r28
    23d8:	26 5f       	subi	r18, 0xF6	; 246
    23da:	3f 4f       	sbci	r19, 0xFF	; 255
    23dc:	b9 01       	movw	r22, r18
    23de:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <xTaskCheckForTimeOut>
    23e2:	88 23       	and	r24, r24
    23e4:	09 f5       	brne	.+66     	; 0x2428 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23e6:	8a 81       	ldd	r24, Y+2	; 0x02
    23e8:	9b 81       	ldd	r25, Y+3	; 0x03
    23ea:	0e 94 23 15 	call	0x2a46	; 0x2a46 <prvIsQueueEmpty>
    23ee:	88 23       	and	r24, r24
    23f0:	a1 f0       	breq	.+40     	; 0x241a <xQueueSemaphoreTake+0x106>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23f2:	8a 81       	ldd	r24, Y+2	; 0x02
    23f4:	9b 81       	ldd	r25, Y+3	; 0x03
    23f6:	41 96       	adiw	r24, 0x11	; 17
    23f8:	2a 85       	ldd	r18, Y+10	; 0x0a
    23fa:	3b 85       	ldd	r19, Y+11	; 0x0b
    23fc:	b9 01       	movw	r22, r18
    23fe:	0e 94 c0 24 	call	0x4980	; 0x4980 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2402:	8a 81       	ldd	r24, Y+2	; 0x02
    2404:	9b 81       	ldd	r25, Y+3	; 0x03
    2406:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    240a:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    240e:	88 23       	and	r24, r24
    2410:	09 f0       	breq	.+2      	; 0x2414 <xQueueSemaphoreTake+0x100>
    2412:	93 cf       	rjmp	.-218    	; 0x233a <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2414:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    2418:	90 cf       	rjmp	.-224    	; 0x233a <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    241a:	8a 81       	ldd	r24, Y+2	; 0x02
    241c:	9b 81       	ldd	r25, Y+3	; 0x03
    241e:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2422:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    2426:	89 cf       	rjmp	.-238    	; 0x233a <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2428:	8a 81       	ldd	r24, Y+2	; 0x02
    242a:	9b 81       	ldd	r25, Y+3	; 0x03
    242c:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2430:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2434:	8a 81       	ldd	r24, Y+2	; 0x02
    2436:	9b 81       	ldd	r25, Y+3	; 0x03
    2438:	0e 94 23 15 	call	0x2a46	; 0x2a46 <prvIsQueueEmpty>
    243c:	88 23       	and	r24, r24
    243e:	09 f4       	brne	.+2      	; 0x2442 <xQueueSemaphoreTake+0x12e>
    2440:	7c cf       	rjmp	.-264    	; 0x233a <xQueueSemaphoreTake+0x26>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2442:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2444:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2446:	2c 96       	adiw	r28, 0x0c	; 12
    2448:	0f b6       	in	r0, 0x3f	; 63
    244a:	f8 94       	cli
    244c:	de bf       	out	0x3e, r29	; 62
    244e:	0f be       	out	0x3f, r0	; 63
    2450:	cd bf       	out	0x3d, r28	; 61
    2452:	cf 91       	pop	r28
    2454:	df 91       	pop	r29
    2456:	08 95       	ret

00002458 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2458:	df 93       	push	r29
    245a:	cf 93       	push	r28
    245c:	cd b7       	in	r28, 0x3d	; 61
    245e:	de b7       	in	r29, 0x3e	; 62
    2460:	60 97       	sbiw	r28, 0x10	; 16
    2462:	0f b6       	in	r0, 0x3f	; 63
    2464:	f8 94       	cli
    2466:	de bf       	out	0x3e, r29	; 62
    2468:	0f be       	out	0x3f, r0	; 63
    246a:	cd bf       	out	0x3d, r28	; 61
    246c:	9b 87       	std	Y+11, r25	; 0x0b
    246e:	8a 87       	std	Y+10, r24	; 0x0a
    2470:	7d 87       	std	Y+13, r23	; 0x0d
    2472:	6c 87       	std	Y+12, r22	; 0x0c
    2474:	5f 87       	std	Y+15, r21	; 0x0f
    2476:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2478:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    247a:	8a 85       	ldd	r24, Y+10	; 0x0a
    247c:	9b 85       	ldd	r25, Y+11	; 0x0b
    247e:	9b 83       	std	Y+3, r25	; 0x03
    2480:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2482:	0f b6       	in	r0, 0x3f	; 63
    2484:	f8 94       	cli
    2486:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2488:	ea 81       	ldd	r30, Y+2	; 0x02
    248a:	fb 81       	ldd	r31, Y+3	; 0x03
    248c:	82 8d       	ldd	r24, Z+26	; 0x1a
    248e:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2490:	89 81       	ldd	r24, Y+1	; 0x01
    2492:	88 23       	and	r24, r24
    2494:	31 f1       	breq	.+76     	; 0x24e2 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2496:	ea 81       	ldd	r30, Y+2	; 0x02
    2498:	fb 81       	ldd	r31, Y+3	; 0x03
    249a:	86 81       	ldd	r24, Z+6	; 0x06
    249c:	97 81       	ldd	r25, Z+7	; 0x07
    249e:	9d 83       	std	Y+5, r25	; 0x05
    24a0:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    24a2:	8a 81       	ldd	r24, Y+2	; 0x02
    24a4:	9b 81       	ldd	r25, Y+3	; 0x03
    24a6:	2c 85       	ldd	r18, Y+12	; 0x0c
    24a8:	3d 85       	ldd	r19, Y+13	; 0x0d
    24aa:	b9 01       	movw	r22, r18
    24ac:	0e 94 89 14 	call	0x2912	; 0x2912 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    24b0:	ea 81       	ldd	r30, Y+2	; 0x02
    24b2:	fb 81       	ldd	r31, Y+3	; 0x03
    24b4:	8c 81       	ldd	r24, Y+4	; 0x04
    24b6:	9d 81       	ldd	r25, Y+5	; 0x05
    24b8:	97 83       	std	Z+7, r25	; 0x07
    24ba:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24bc:	ea 81       	ldd	r30, Y+2	; 0x02
    24be:	fb 81       	ldd	r31, Y+3	; 0x03
    24c0:	81 89       	ldd	r24, Z+17	; 0x11
    24c2:	88 23       	and	r24, r24
    24c4:	49 f0       	breq	.+18     	; 0x24d8 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24c6:	8a 81       	ldd	r24, Y+2	; 0x02
    24c8:	9b 81       	ldd	r25, Y+3	; 0x03
    24ca:	41 96       	adiw	r24, 0x11	; 17
    24cc:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    24d0:	88 23       	and	r24, r24
    24d2:	11 f0       	breq	.+4      	; 0x24d8 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    24d4:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    24d8:	0f 90       	pop	r0
    24da:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    24dc:	81 e0       	ldi	r24, 0x01	; 1
    24de:	88 8b       	std	Y+16, r24	; 0x10
    24e0:	63 c0       	rjmp	.+198    	; 0x25a8 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    24e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    24e4:	9f 85       	ldd	r25, Y+15	; 0x0f
    24e6:	00 97       	sbiw	r24, 0x00	; 0
    24e8:	21 f4       	brne	.+8      	; 0x24f2 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    24ea:	0f 90       	pop	r0
    24ec:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    24ee:	18 8a       	std	Y+16, r1	; 0x10
    24f0:	5b c0       	rjmp	.+182    	; 0x25a8 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    24f2:	8e 81       	ldd	r24, Y+6	; 0x06
    24f4:	88 23       	and	r24, r24
    24f6:	31 f4       	brne	.+12     	; 0x2504 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    24f8:	ce 01       	movw	r24, r28
    24fa:	07 96       	adiw	r24, 0x07	; 7
    24fc:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2500:	81 e0       	ldi	r24, 0x01	; 1
    2502:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2504:	0f 90       	pop	r0
    2506:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2508:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    250c:	0f b6       	in	r0, 0x3f	; 63
    250e:	f8 94       	cli
    2510:	0f 92       	push	r0
    2512:	ea 81       	ldd	r30, Y+2	; 0x02
    2514:	fb 81       	ldd	r31, Y+3	; 0x03
    2516:	85 8d       	ldd	r24, Z+29	; 0x1d
    2518:	8f 3f       	cpi	r24, 0xFF	; 255
    251a:	19 f4       	brne	.+6      	; 0x2522 <xQueuePeek+0xca>
    251c:	ea 81       	ldd	r30, Y+2	; 0x02
    251e:	fb 81       	ldd	r31, Y+3	; 0x03
    2520:	15 8e       	std	Z+29, r1	; 0x1d
    2522:	ea 81       	ldd	r30, Y+2	; 0x02
    2524:	fb 81       	ldd	r31, Y+3	; 0x03
    2526:	86 8d       	ldd	r24, Z+30	; 0x1e
    2528:	8f 3f       	cpi	r24, 0xFF	; 255
    252a:	19 f4       	brne	.+6      	; 0x2532 <xQueuePeek+0xda>
    252c:	ea 81       	ldd	r30, Y+2	; 0x02
    252e:	fb 81       	ldd	r31, Y+3	; 0x03
    2530:	16 8e       	std	Z+30, r1	; 0x1e
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2536:	ce 01       	movw	r24, r28
    2538:	07 96       	adiw	r24, 0x07	; 7
    253a:	9e 01       	movw	r18, r28
    253c:	22 5f       	subi	r18, 0xF2	; 242
    253e:	3f 4f       	sbci	r19, 0xFF	; 255
    2540:	b9 01       	movw	r22, r18
    2542:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <xTaskCheckForTimeOut>
    2546:	88 23       	and	r24, r24
    2548:	09 f5       	brne	.+66     	; 0x258c <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    254a:	8a 81       	ldd	r24, Y+2	; 0x02
    254c:	9b 81       	ldd	r25, Y+3	; 0x03
    254e:	0e 94 23 15 	call	0x2a46	; 0x2a46 <prvIsQueueEmpty>
    2552:	88 23       	and	r24, r24
    2554:	a1 f0       	breq	.+40     	; 0x257e <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2556:	8a 81       	ldd	r24, Y+2	; 0x02
    2558:	9b 81       	ldd	r25, Y+3	; 0x03
    255a:	41 96       	adiw	r24, 0x11	; 17
    255c:	2e 85       	ldd	r18, Y+14	; 0x0e
    255e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2560:	b9 01       	movw	r22, r18
    2562:	0e 94 c0 24 	call	0x4980	; 0x4980 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2566:	8a 81       	ldd	r24, Y+2	; 0x02
    2568:	9b 81       	ldd	r25, Y+3	; 0x03
    256a:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    256e:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    2572:	88 23       	and	r24, r24
    2574:	09 f0       	breq	.+2      	; 0x2578 <xQueuePeek+0x120>
    2576:	85 cf       	rjmp	.-246    	; 0x2482 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2578:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    257c:	82 cf       	rjmp	.-252    	; 0x2482 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    257e:	8a 81       	ldd	r24, Y+2	; 0x02
    2580:	9b 81       	ldd	r25, Y+3	; 0x03
    2582:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2586:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    258a:	7b cf       	rjmp	.-266    	; 0x2482 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    258c:	8a 81       	ldd	r24, Y+2	; 0x02
    258e:	9b 81       	ldd	r25, Y+3	; 0x03
    2590:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2594:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2598:	8a 81       	ldd	r24, Y+2	; 0x02
    259a:	9b 81       	ldd	r25, Y+3	; 0x03
    259c:	0e 94 23 15 	call	0x2a46	; 0x2a46 <prvIsQueueEmpty>
    25a0:	88 23       	and	r24, r24
    25a2:	09 f4       	brne	.+2      	; 0x25a6 <xQueuePeek+0x14e>
    25a4:	6e cf       	rjmp	.-292    	; 0x2482 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    25a6:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    25a8:	88 89       	ldd	r24, Y+16	; 0x10
}
    25aa:	60 96       	adiw	r28, 0x10	; 16
    25ac:	0f b6       	in	r0, 0x3f	; 63
    25ae:	f8 94       	cli
    25b0:	de bf       	out	0x3e, r29	; 62
    25b2:	0f be       	out	0x3f, r0	; 63
    25b4:	cd bf       	out	0x3d, r28	; 61
    25b6:	cf 91       	pop	r28
    25b8:	df 91       	pop	r29
    25ba:	08 95       	ret

000025bc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    25bc:	df 93       	push	r29
    25be:	cf 93       	push	r28
    25c0:	cd b7       	in	r28, 0x3d	; 61
    25c2:	de b7       	in	r29, 0x3e	; 62
    25c4:	2d 97       	sbiw	r28, 0x0d	; 13
    25c6:	0f b6       	in	r0, 0x3f	; 63
    25c8:	f8 94       	cli
    25ca:	de bf       	out	0x3e, r29	; 62
    25cc:	0f be       	out	0x3f, r0	; 63
    25ce:	cd bf       	out	0x3d, r28	; 61
    25d0:	99 87       	std	Y+9, r25	; 0x09
    25d2:	88 87       	std	Y+8, r24	; 0x08
    25d4:	7b 87       	std	Y+11, r23	; 0x0b
    25d6:	6a 87       	std	Y+10, r22	; 0x0a
    25d8:	5d 87       	std	Y+13, r21	; 0x0d
    25da:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    25dc:	88 85       	ldd	r24, Y+8	; 0x08
    25de:	99 85       	ldd	r25, Y+9	; 0x09
    25e0:	9d 83       	std	Y+5, r25	; 0x05
    25e2:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    25e4:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25e6:	ec 81       	ldd	r30, Y+4	; 0x04
    25e8:	fd 81       	ldd	r31, Y+5	; 0x05
    25ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    25ec:	8b 83       	std	Y+3, r24	; 0x03

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    25ee:	8b 81       	ldd	r24, Y+3	; 0x03
    25f0:	88 23       	and	r24, r24
    25f2:	b9 f1       	breq	.+110    	; 0x2662 <xQueueReceiveFromISR+0xa6>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    25f4:	ec 81       	ldd	r30, Y+4	; 0x04
    25f6:	fd 81       	ldd	r31, Y+5	; 0x05
    25f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    25fa:	8a 83       	std	Y+2, r24	; 0x02

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    25fc:	8c 81       	ldd	r24, Y+4	; 0x04
    25fe:	9d 81       	ldd	r25, Y+5	; 0x05
    2600:	2a 85       	ldd	r18, Y+10	; 0x0a
    2602:	3b 85       	ldd	r19, Y+11	; 0x0b
    2604:	b9 01       	movw	r22, r18
    2606:	0e 94 89 14 	call	0x2912	; 0x2912 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    260a:	8b 81       	ldd	r24, Y+3	; 0x03
    260c:	81 50       	subi	r24, 0x01	; 1
    260e:	ec 81       	ldd	r30, Y+4	; 0x04
    2610:	fd 81       	ldd	r31, Y+5	; 0x05
    2612:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2614:	8a 81       	ldd	r24, Y+2	; 0x02
    2616:	8f 3f       	cpi	r24, 0xFF	; 255
    2618:	a9 f4       	brne	.+42     	; 0x2644 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    261a:	ec 81       	ldd	r30, Y+4	; 0x04
    261c:	fd 81       	ldd	r31, Y+5	; 0x05
    261e:	80 85       	ldd	r24, Z+8	; 0x08
    2620:	88 23       	and	r24, r24
    2622:	e1 f0       	breq	.+56     	; 0x265c <xQueueReceiveFromISR+0xa0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2624:	8c 81       	ldd	r24, Y+4	; 0x04
    2626:	9d 81       	ldd	r25, Y+5	; 0x05
    2628:	08 96       	adiw	r24, 0x08	; 8
    262a:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    262e:	88 23       	and	r24, r24
    2630:	a9 f0       	breq	.+42     	; 0x265c <xQueueReceiveFromISR+0xa0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2632:	8c 85       	ldd	r24, Y+12	; 0x0c
    2634:	9d 85       	ldd	r25, Y+13	; 0x0d
    2636:	00 97       	sbiw	r24, 0x00	; 0
    2638:	89 f0       	breq	.+34     	; 0x265c <xQueueReceiveFromISR+0xa0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    263a:	ec 85       	ldd	r30, Y+12	; 0x0c
    263c:	fd 85       	ldd	r31, Y+13	; 0x0d
    263e:	81 e0       	ldi	r24, 0x01	; 1
    2640:	80 83       	st	Z, r24
    2642:	0c c0       	rjmp	.+24     	; 0x265c <xQueueReceiveFromISR+0xa0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    2644:	0e 94 66 22 	call	0x44cc	; 0x44cc <uxTaskGetNumberOfTasks>
    2648:	89 83       	std	Y+1, r24	; 0x01
    264a:	9a 81       	ldd	r25, Y+2	; 0x02
    264c:	89 81       	ldd	r24, Y+1	; 0x01
    264e:	98 17       	cp	r25, r24
    2650:	28 f4       	brcc	.+10     	; 0x265c <xQueueReceiveFromISR+0xa0>
    2652:	8a 81       	ldd	r24, Y+2	; 0x02
    2654:	8f 5f       	subi	r24, 0xFF	; 255
    2656:	ec 81       	ldd	r30, Y+4	; 0x04
    2658:	fd 81       	ldd	r31, Y+5	; 0x05
    265a:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    265c:	81 e0       	ldi	r24, 0x01	; 1
    265e:	8f 83       	std	Y+7, r24	; 0x07
    2660:	01 c0       	rjmp	.+2      	; 0x2664 <xQueueReceiveFromISR+0xa8>
        }
        else
        {
            xReturn = pdFAIL;
    2662:	1f 82       	std	Y+7, r1	; 0x07
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2664:	8f 81       	ldd	r24, Y+7	; 0x07
}
    2666:	2d 96       	adiw	r28, 0x0d	; 13
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	de bf       	out	0x3e, r29	; 62
    266e:	0f be       	out	0x3f, r0	; 63
    2670:	cd bf       	out	0x3d, r28	; 61
    2672:	cf 91       	pop	r28
    2674:	df 91       	pop	r29
    2676:	08 95       	ret

00002678 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2678:	df 93       	push	r29
    267a:	cf 93       	push	r28
    267c:	cd b7       	in	r28, 0x3d	; 61
    267e:	de b7       	in	r29, 0x3e	; 62
    2680:	2a 97       	sbiw	r28, 0x0a	; 10
    2682:	0f b6       	in	r0, 0x3f	; 63
    2684:	f8 94       	cli
    2686:	de bf       	out	0x3e, r29	; 62
    2688:	0f be       	out	0x3f, r0	; 63
    268a:	cd bf       	out	0x3d, r28	; 61
    268c:	98 87       	std	Y+8, r25	; 0x08
    268e:	8f 83       	std	Y+7, r24	; 0x07
    2690:	7a 87       	std	Y+10, r23	; 0x0a
    2692:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2694:	8f 81       	ldd	r24, Y+7	; 0x07
    2696:	98 85       	ldd	r25, Y+8	; 0x08
    2698:	9a 83       	std	Y+2, r25	; 0x02
    269a:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    269c:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    269e:	e9 81       	ldd	r30, Y+1	; 0x01
    26a0:	fa 81       	ldd	r31, Y+2	; 0x02
    26a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    26a4:	88 23       	and	r24, r24
    26a6:	b1 f0       	breq	.+44     	; 0x26d4 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    26a8:	e9 81       	ldd	r30, Y+1	; 0x01
    26aa:	fa 81       	ldd	r31, Y+2	; 0x02
    26ac:	86 81       	ldd	r24, Z+6	; 0x06
    26ae:	97 81       	ldd	r25, Z+7	; 0x07
    26b0:	9c 83       	std	Y+4, r25	; 0x04
    26b2:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    26b4:	89 81       	ldd	r24, Y+1	; 0x01
    26b6:	9a 81       	ldd	r25, Y+2	; 0x02
    26b8:	29 85       	ldd	r18, Y+9	; 0x09
    26ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    26bc:	b9 01       	movw	r22, r18
    26be:	0e 94 89 14 	call	0x2912	; 0x2912 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    26c2:	e9 81       	ldd	r30, Y+1	; 0x01
    26c4:	fa 81       	ldd	r31, Y+2	; 0x02
    26c6:	8b 81       	ldd	r24, Y+3	; 0x03
    26c8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ca:	97 83       	std	Z+7, r25	; 0x07
    26cc:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	8e 83       	std	Y+6, r24	; 0x06
    26d2:	01 c0       	rjmp	.+2      	; 0x26d6 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    26d4:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    26d6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    26d8:	2a 96       	adiw	r28, 0x0a	; 10
    26da:	0f b6       	in	r0, 0x3f	; 63
    26dc:	f8 94       	cli
    26de:	de bf       	out	0x3e, r29	; 62
    26e0:	0f be       	out	0x3f, r0	; 63
    26e2:	cd bf       	out	0x3d, r28	; 61
    26e4:	cf 91       	pop	r28
    26e6:	df 91       	pop	r29
    26e8:	08 95       	ret

000026ea <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    26ea:	df 93       	push	r29
    26ec:	cf 93       	push	r28
    26ee:	00 d0       	rcall	.+0      	; 0x26f0 <uxQueueMessagesWaiting+0x6>
    26f0:	0f 92       	push	r0
    26f2:	cd b7       	in	r28, 0x3d	; 61
    26f4:	de b7       	in	r29, 0x3e	; 62
    26f6:	9b 83       	std	Y+3, r25	; 0x03
    26f8:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2700:	ea 81       	ldd	r30, Y+2	; 0x02
    2702:	fb 81       	ldd	r31, Y+3	; 0x03
    2704:	82 8d       	ldd	r24, Z+26	; 0x1a
    2706:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2708:	0f 90       	pop	r0
    270a:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    270c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	cf 91       	pop	r28
    2716:	df 91       	pop	r29
    2718:	08 95       	ret

0000271a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    271a:	df 93       	push	r29
    271c:	cf 93       	push	r28
    271e:	00 d0       	rcall	.+0      	; 0x2720 <uxQueueSpacesAvailable+0x6>
    2720:	00 d0       	rcall	.+0      	; 0x2722 <uxQueueSpacesAvailable+0x8>
    2722:	0f 92       	push	r0
    2724:	cd b7       	in	r28, 0x3d	; 61
    2726:	de b7       	in	r29, 0x3e	; 62
    2728:	9d 83       	std	Y+5, r25	; 0x05
    272a:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    272c:	8c 81       	ldd	r24, Y+4	; 0x04
    272e:	9d 81       	ldd	r25, Y+5	; 0x05
    2730:	9a 83       	std	Y+2, r25	; 0x02
    2732:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2734:	0f b6       	in	r0, 0x3f	; 63
    2736:	f8 94       	cli
    2738:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    273a:	e9 81       	ldd	r30, Y+1	; 0x01
    273c:	fa 81       	ldd	r31, Y+2	; 0x02
    273e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2740:	e9 81       	ldd	r30, Y+1	; 0x01
    2742:	fa 81       	ldd	r31, Y+2	; 0x02
    2744:	82 8d       	ldd	r24, Z+26	; 0x1a
    2746:	29 2f       	mov	r18, r25
    2748:	28 1b       	sub	r18, r24
    274a:	82 2f       	mov	r24, r18
    274c:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    274e:	0f 90       	pop	r0
    2750:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2752:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2754:	0f 90       	pop	r0
    2756:	0f 90       	pop	r0
    2758:	0f 90       	pop	r0
    275a:	0f 90       	pop	r0
    275c:	0f 90       	pop	r0
    275e:	cf 91       	pop	r28
    2760:	df 91       	pop	r29
    2762:	08 95       	ret

00002764 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2764:	df 93       	push	r29
    2766:	cf 93       	push	r28
    2768:	00 d0       	rcall	.+0      	; 0x276a <uxQueueMessagesWaitingFromISR+0x6>
    276a:	00 d0       	rcall	.+0      	; 0x276c <uxQueueMessagesWaitingFromISR+0x8>
    276c:	0f 92       	push	r0
    276e:	cd b7       	in	r28, 0x3d	; 61
    2770:	de b7       	in	r29, 0x3e	; 62
    2772:	9d 83       	std	Y+5, r25	; 0x05
    2774:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2776:	8c 81       	ldd	r24, Y+4	; 0x04
    2778:	9d 81       	ldd	r25, Y+5	; 0x05
    277a:	9a 83       	std	Y+2, r25	; 0x02
    277c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    277e:	e9 81       	ldd	r30, Y+1	; 0x01
    2780:	fa 81       	ldd	r31, Y+2	; 0x02
    2782:	82 8d       	ldd	r24, Z+26	; 0x1a
    2784:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    2786:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2788:	0f 90       	pop	r0
    278a:	0f 90       	pop	r0
    278c:	0f 90       	pop	r0
    278e:	0f 90       	pop	r0
    2790:	0f 90       	pop	r0
    2792:	cf 91       	pop	r28
    2794:	df 91       	pop	r29
    2796:	08 95       	ret

00002798 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2798:	df 93       	push	r29
    279a:	cf 93       	push	r28
    279c:	00 d0       	rcall	.+0      	; 0x279e <vQueueDelete+0x6>
    279e:	00 d0       	rcall	.+0      	; 0x27a0 <vQueueDelete+0x8>
    27a0:	cd b7       	in	r28, 0x3d	; 61
    27a2:	de b7       	in	r29, 0x3e	; 62
    27a4:	9c 83       	std	Y+4, r25	; 0x04
    27a6:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    27a8:	8b 81       	ldd	r24, Y+3	; 0x03
    27aa:	9c 81       	ldd	r25, Y+4	; 0x04
    27ac:	9a 83       	std	Y+2, r25	; 0x02
    27ae:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    27b0:	89 81       	ldd	r24, Y+1	; 0x01
    27b2:	9a 81       	ldd	r25, Y+2	; 0x02
    27b4:	0e 94 a9 06 	call	0xd52	; 0xd52 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    27b8:	0f 90       	pop	r0
    27ba:	0f 90       	pop	r0
    27bc:	0f 90       	pop	r0
    27be:	0f 90       	pop	r0
    27c0:	cf 91       	pop	r28
    27c2:	df 91       	pop	r29
    27c4:	08 95       	ret

000027c6 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    27c6:	df 93       	push	r29
    27c8:	cf 93       	push	r28
    27ca:	cd b7       	in	r28, 0x3d	; 61
    27cc:	de b7       	in	r29, 0x3e	; 62
    27ce:	27 97       	sbiw	r28, 0x07	; 7
    27d0:	0f b6       	in	r0, 0x3f	; 63
    27d2:	f8 94       	cli
    27d4:	de bf       	out	0x3e, r29	; 62
    27d6:	0f be       	out	0x3f, r0	; 63
    27d8:	cd bf       	out	0x3d, r28	; 61
    27da:	9c 83       	std	Y+4, r25	; 0x04
    27dc:	8b 83       	std	Y+3, r24	; 0x03
    27de:	7e 83       	std	Y+6, r23	; 0x06
    27e0:	6d 83       	std	Y+5, r22	; 0x05
    27e2:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    27e4:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    27e6:	eb 81       	ldd	r30, Y+3	; 0x03
    27e8:	fc 81       	ldd	r31, Y+4	; 0x04
    27ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    27ec:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    27ee:	eb 81       	ldd	r30, Y+3	; 0x03
    27f0:	fc 81       	ldd	r31, Y+4	; 0x04
    27f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    27f4:	88 23       	and	r24, r24
    27f6:	09 f4       	brne	.+2      	; 0x27fa <prvCopyDataToQueue+0x34>
    27f8:	7d c0       	rjmp	.+250    	; 0x28f4 <prvCopyDataToQueue+0x12e>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    27fa:	8f 81       	ldd	r24, Y+7	; 0x07
    27fc:	88 23       	and	r24, r24
    27fe:	99 f5       	brne	.+102    	; 0x2866 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2800:	eb 81       	ldd	r30, Y+3	; 0x03
    2802:	fc 81       	ldd	r31, Y+4	; 0x04
    2804:	62 81       	ldd	r22, Z+2	; 0x02
    2806:	73 81       	ldd	r23, Z+3	; 0x03
    2808:	eb 81       	ldd	r30, Y+3	; 0x03
    280a:	fc 81       	ldd	r31, Y+4	; 0x04
    280c:	84 8d       	ldd	r24, Z+28	; 0x1c
    280e:	48 2f       	mov	r20, r24
    2810:	50 e0       	ldi	r21, 0x00	; 0
    2812:	2d 81       	ldd	r18, Y+5	; 0x05
    2814:	3e 81       	ldd	r19, Y+6	; 0x06
    2816:	cb 01       	movw	r24, r22
    2818:	b9 01       	movw	r22, r18
    281a:	0e 94 e0 3d 	call	0x7bc0	; 0x7bc0 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    281e:	eb 81       	ldd	r30, Y+3	; 0x03
    2820:	fc 81       	ldd	r31, Y+4	; 0x04
    2822:	22 81       	ldd	r18, Z+2	; 0x02
    2824:	33 81       	ldd	r19, Z+3	; 0x03
    2826:	eb 81       	ldd	r30, Y+3	; 0x03
    2828:	fc 81       	ldd	r31, Y+4	; 0x04
    282a:	84 8d       	ldd	r24, Z+28	; 0x1c
    282c:	88 2f       	mov	r24, r24
    282e:	90 e0       	ldi	r25, 0x00	; 0
    2830:	82 0f       	add	r24, r18
    2832:	93 1f       	adc	r25, r19
    2834:	eb 81       	ldd	r30, Y+3	; 0x03
    2836:	fc 81       	ldd	r31, Y+4	; 0x04
    2838:	93 83       	std	Z+3, r25	; 0x03
    283a:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    283c:	eb 81       	ldd	r30, Y+3	; 0x03
    283e:	fc 81       	ldd	r31, Y+4	; 0x04
    2840:	22 81       	ldd	r18, Z+2	; 0x02
    2842:	33 81       	ldd	r19, Z+3	; 0x03
    2844:	eb 81       	ldd	r30, Y+3	; 0x03
    2846:	fc 81       	ldd	r31, Y+4	; 0x04
    2848:	84 81       	ldd	r24, Z+4	; 0x04
    284a:	95 81       	ldd	r25, Z+5	; 0x05
    284c:	28 17       	cp	r18, r24
    284e:	39 07       	cpc	r19, r25
    2850:	08 f4       	brcc	.+2      	; 0x2854 <prvCopyDataToQueue+0x8e>
    2852:	50 c0       	rjmp	.+160    	; 0x28f4 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2854:	eb 81       	ldd	r30, Y+3	; 0x03
    2856:	fc 81       	ldd	r31, Y+4	; 0x04
    2858:	80 81       	ld	r24, Z
    285a:	91 81       	ldd	r25, Z+1	; 0x01
    285c:	eb 81       	ldd	r30, Y+3	; 0x03
    285e:	fc 81       	ldd	r31, Y+4	; 0x04
    2860:	93 83       	std	Z+3, r25	; 0x03
    2862:	82 83       	std	Z+2, r24	; 0x02
    2864:	47 c0       	rjmp	.+142    	; 0x28f4 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2866:	eb 81       	ldd	r30, Y+3	; 0x03
    2868:	fc 81       	ldd	r31, Y+4	; 0x04
    286a:	66 81       	ldd	r22, Z+6	; 0x06
    286c:	77 81       	ldd	r23, Z+7	; 0x07
    286e:	eb 81       	ldd	r30, Y+3	; 0x03
    2870:	fc 81       	ldd	r31, Y+4	; 0x04
    2872:	84 8d       	ldd	r24, Z+28	; 0x1c
    2874:	48 2f       	mov	r20, r24
    2876:	50 e0       	ldi	r21, 0x00	; 0
    2878:	2d 81       	ldd	r18, Y+5	; 0x05
    287a:	3e 81       	ldd	r19, Y+6	; 0x06
    287c:	cb 01       	movw	r24, r22
    287e:	b9 01       	movw	r22, r18
    2880:	0e 94 e0 3d 	call	0x7bc0	; 0x7bc0 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2884:	eb 81       	ldd	r30, Y+3	; 0x03
    2886:	fc 81       	ldd	r31, Y+4	; 0x04
    2888:	26 81       	ldd	r18, Z+6	; 0x06
    288a:	37 81       	ldd	r19, Z+7	; 0x07
    288c:	eb 81       	ldd	r30, Y+3	; 0x03
    288e:	fc 81       	ldd	r31, Y+4	; 0x04
    2890:	84 8d       	ldd	r24, Z+28	; 0x1c
    2892:	88 2f       	mov	r24, r24
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	90 95       	com	r25
    2898:	81 95       	neg	r24
    289a:	9f 4f       	sbci	r25, 0xFF	; 255
    289c:	82 0f       	add	r24, r18
    289e:	93 1f       	adc	r25, r19
    28a0:	eb 81       	ldd	r30, Y+3	; 0x03
    28a2:	fc 81       	ldd	r31, Y+4	; 0x04
    28a4:	97 83       	std	Z+7, r25	; 0x07
    28a6:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    28a8:	eb 81       	ldd	r30, Y+3	; 0x03
    28aa:	fc 81       	ldd	r31, Y+4	; 0x04
    28ac:	26 81       	ldd	r18, Z+6	; 0x06
    28ae:	37 81       	ldd	r19, Z+7	; 0x07
    28b0:	eb 81       	ldd	r30, Y+3	; 0x03
    28b2:	fc 81       	ldd	r31, Y+4	; 0x04
    28b4:	80 81       	ld	r24, Z
    28b6:	91 81       	ldd	r25, Z+1	; 0x01
    28b8:	28 17       	cp	r18, r24
    28ba:	39 07       	cpc	r19, r25
    28bc:	90 f4       	brcc	.+36     	; 0x28e2 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    28be:	eb 81       	ldd	r30, Y+3	; 0x03
    28c0:	fc 81       	ldd	r31, Y+4	; 0x04
    28c2:	24 81       	ldd	r18, Z+4	; 0x04
    28c4:	35 81       	ldd	r19, Z+5	; 0x05
    28c6:	eb 81       	ldd	r30, Y+3	; 0x03
    28c8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    28cc:	88 2f       	mov	r24, r24
    28ce:	90 e0       	ldi	r25, 0x00	; 0
    28d0:	90 95       	com	r25
    28d2:	81 95       	neg	r24
    28d4:	9f 4f       	sbci	r25, 0xFF	; 255
    28d6:	82 0f       	add	r24, r18
    28d8:	93 1f       	adc	r25, r19
    28da:	eb 81       	ldd	r30, Y+3	; 0x03
    28dc:	fc 81       	ldd	r31, Y+4	; 0x04
    28de:	97 83       	std	Z+7, r25	; 0x07
    28e0:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    28e2:	8f 81       	ldd	r24, Y+7	; 0x07
    28e4:	82 30       	cpi	r24, 0x02	; 2
    28e6:	31 f4       	brne	.+12     	; 0x28f4 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    28e8:	89 81       	ldd	r24, Y+1	; 0x01
    28ea:	88 23       	and	r24, r24
    28ec:	19 f0       	breq	.+6      	; 0x28f4 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    28ee:	89 81       	ldd	r24, Y+1	; 0x01
    28f0:	81 50       	subi	r24, 0x01	; 1
    28f2:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    28f4:	89 81       	ldd	r24, Y+1	; 0x01
    28f6:	8f 5f       	subi	r24, 0xFF	; 255
    28f8:	eb 81       	ldd	r30, Y+3	; 0x03
    28fa:	fc 81       	ldd	r31, Y+4	; 0x04
    28fc:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    28fe:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2900:	27 96       	adiw	r28, 0x07	; 7
    2902:	0f b6       	in	r0, 0x3f	; 63
    2904:	f8 94       	cli
    2906:	de bf       	out	0x3e, r29	; 62
    2908:	0f be       	out	0x3f, r0	; 63
    290a:	cd bf       	out	0x3d, r28	; 61
    290c:	cf 91       	pop	r28
    290e:	df 91       	pop	r29
    2910:	08 95       	ret

00002912 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2912:	df 93       	push	r29
    2914:	cf 93       	push	r28
    2916:	00 d0       	rcall	.+0      	; 0x2918 <prvCopyDataFromQueue+0x6>
    2918:	00 d0       	rcall	.+0      	; 0x291a <prvCopyDataFromQueue+0x8>
    291a:	cd b7       	in	r28, 0x3d	; 61
    291c:	de b7       	in	r29, 0x3e	; 62
    291e:	9a 83       	std	Y+2, r25	; 0x02
    2920:	89 83       	std	Y+1, r24	; 0x01
    2922:	7c 83       	std	Y+4, r23	; 0x04
    2924:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2926:	e9 81       	ldd	r30, Y+1	; 0x01
    2928:	fa 81       	ldd	r31, Y+2	; 0x02
    292a:	84 8d       	ldd	r24, Z+28	; 0x1c
    292c:	88 23       	and	r24, r24
    292e:	89 f1       	breq	.+98     	; 0x2992 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2930:	e9 81       	ldd	r30, Y+1	; 0x01
    2932:	fa 81       	ldd	r31, Y+2	; 0x02
    2934:	26 81       	ldd	r18, Z+6	; 0x06
    2936:	37 81       	ldd	r19, Z+7	; 0x07
    2938:	e9 81       	ldd	r30, Y+1	; 0x01
    293a:	fa 81       	ldd	r31, Y+2	; 0x02
    293c:	84 8d       	ldd	r24, Z+28	; 0x1c
    293e:	88 2f       	mov	r24, r24
    2940:	90 e0       	ldi	r25, 0x00	; 0
    2942:	82 0f       	add	r24, r18
    2944:	93 1f       	adc	r25, r19
    2946:	e9 81       	ldd	r30, Y+1	; 0x01
    2948:	fa 81       	ldd	r31, Y+2	; 0x02
    294a:	97 83       	std	Z+7, r25	; 0x07
    294c:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    294e:	e9 81       	ldd	r30, Y+1	; 0x01
    2950:	fa 81       	ldd	r31, Y+2	; 0x02
    2952:	26 81       	ldd	r18, Z+6	; 0x06
    2954:	37 81       	ldd	r19, Z+7	; 0x07
    2956:	e9 81       	ldd	r30, Y+1	; 0x01
    2958:	fa 81       	ldd	r31, Y+2	; 0x02
    295a:	84 81       	ldd	r24, Z+4	; 0x04
    295c:	95 81       	ldd	r25, Z+5	; 0x05
    295e:	28 17       	cp	r18, r24
    2960:	39 07       	cpc	r19, r25
    2962:	40 f0       	brcs	.+16     	; 0x2974 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2964:	e9 81       	ldd	r30, Y+1	; 0x01
    2966:	fa 81       	ldd	r31, Y+2	; 0x02
    2968:	80 81       	ld	r24, Z
    296a:	91 81       	ldd	r25, Z+1	; 0x01
    296c:	e9 81       	ldd	r30, Y+1	; 0x01
    296e:	fa 81       	ldd	r31, Y+2	; 0x02
    2970:	97 83       	std	Z+7, r25	; 0x07
    2972:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2974:	e9 81       	ldd	r30, Y+1	; 0x01
    2976:	fa 81       	ldd	r31, Y+2	; 0x02
    2978:	46 81       	ldd	r20, Z+6	; 0x06
    297a:	57 81       	ldd	r21, Z+7	; 0x07
    297c:	e9 81       	ldd	r30, Y+1	; 0x01
    297e:	fa 81       	ldd	r31, Y+2	; 0x02
    2980:	84 8d       	ldd	r24, Z+28	; 0x1c
    2982:	28 2f       	mov	r18, r24
    2984:	30 e0       	ldi	r19, 0x00	; 0
    2986:	8b 81       	ldd	r24, Y+3	; 0x03
    2988:	9c 81       	ldd	r25, Y+4	; 0x04
    298a:	ba 01       	movw	r22, r20
    298c:	a9 01       	movw	r20, r18
    298e:	0e 94 e0 3d 	call	0x7bc0	; 0x7bc0 <memcpy>
    }
}
    2992:	0f 90       	pop	r0
    2994:	0f 90       	pop	r0
    2996:	0f 90       	pop	r0
    2998:	0f 90       	pop	r0
    299a:	cf 91       	pop	r28
    299c:	df 91       	pop	r29
    299e:	08 95       	ret

000029a0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    29a0:	df 93       	push	r29
    29a2:	cf 93       	push	r28
    29a4:	00 d0       	rcall	.+0      	; 0x29a6 <prvUnlockQueue+0x6>
    29a6:	00 d0       	rcall	.+0      	; 0x29a8 <prvUnlockQueue+0x8>
    29a8:	cd b7       	in	r28, 0x3d	; 61
    29aa:	de b7       	in	r29, 0x3e	; 62
    29ac:	9c 83       	std	Y+4, r25	; 0x04
    29ae:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    29b0:	0f b6       	in	r0, 0x3f	; 63
    29b2:	f8 94       	cli
    29b4:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    29b6:	eb 81       	ldd	r30, Y+3	; 0x03
    29b8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    29bc:	8a 83       	std	Y+2, r24	; 0x02
    29be:	11 c0       	rjmp	.+34     	; 0x29e2 <prvUnlockQueue+0x42>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    29c0:	eb 81       	ldd	r30, Y+3	; 0x03
    29c2:	fc 81       	ldd	r31, Y+4	; 0x04
    29c4:	81 89       	ldd	r24, Z+17	; 0x11
    29c6:	88 23       	and	r24, r24
    29c8:	79 f0       	breq	.+30     	; 0x29e8 <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    29ca:	8b 81       	ldd	r24, Y+3	; 0x03
    29cc:	9c 81       	ldd	r25, Y+4	; 0x04
    29ce:	41 96       	adiw	r24, 0x11	; 17
    29d0:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    29d4:	88 23       	and	r24, r24
    29d6:	11 f0       	breq	.+4      	; 0x29dc <prvUnlockQueue+0x3c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    29d8:	0e 94 37 28 	call	0x506e	; 0x506e <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    29dc:	8a 81       	ldd	r24, Y+2	; 0x02
    29de:	81 50       	subi	r24, 0x01	; 1
    29e0:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    29e2:	8a 81       	ldd	r24, Y+2	; 0x02
    29e4:	18 16       	cp	r1, r24
    29e6:	64 f3       	brlt	.-40     	; 0x29c0 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    29e8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ea:	fc 81       	ldd	r31, Y+4	; 0x04
    29ec:	8f ef       	ldi	r24, 0xFF	; 255
    29ee:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    29f0:	0f 90       	pop	r0
    29f2:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    29f4:	0f b6       	in	r0, 0x3f	; 63
    29f6:	f8 94       	cli
    29f8:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    29fa:	eb 81       	ldd	r30, Y+3	; 0x03
    29fc:	fc 81       	ldd	r31, Y+4	; 0x04
    29fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a00:	89 83       	std	Y+1, r24	; 0x01
    2a02:	11 c0       	rjmp	.+34     	; 0x2a26 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a04:	eb 81       	ldd	r30, Y+3	; 0x03
    2a06:	fc 81       	ldd	r31, Y+4	; 0x04
    2a08:	80 85       	ldd	r24, Z+8	; 0x08
    2a0a:	88 23       	and	r24, r24
    2a0c:	79 f0       	breq	.+30     	; 0x2a2c <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a10:	9c 81       	ldd	r25, Y+4	; 0x04
    2a12:	08 96       	adiw	r24, 0x08	; 8
    2a14:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <xTaskRemoveFromEventList>
    2a18:	88 23       	and	r24, r24
    2a1a:	11 f0       	breq	.+4      	; 0x2a20 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    2a1c:	0e 94 37 28 	call	0x506e	; 0x506e <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    2a20:	89 81       	ldd	r24, Y+1	; 0x01
    2a22:	81 50       	subi	r24, 0x01	; 1
    2a24:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    2a26:	89 81       	ldd	r24, Y+1	; 0x01
    2a28:	18 16       	cp	r1, r24
    2a2a:	64 f3       	brlt	.-40     	; 0x2a04 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    2a2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a30:	8f ef       	ldi	r24, 0xFF	; 255
    2a32:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    2a34:	0f 90       	pop	r0
    2a36:	0f be       	out	0x3f, r0	; 63
}
    2a38:	0f 90       	pop	r0
    2a3a:	0f 90       	pop	r0
    2a3c:	0f 90       	pop	r0
    2a3e:	0f 90       	pop	r0
    2a40:	cf 91       	pop	r28
    2a42:	df 91       	pop	r29
    2a44:	08 95       	ret

00002a46 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    2a46:	df 93       	push	r29
    2a48:	cf 93       	push	r28
    2a4a:	00 d0       	rcall	.+0      	; 0x2a4c <prvIsQueueEmpty+0x6>
    2a4c:	0f 92       	push	r0
    2a4e:	cd b7       	in	r28, 0x3d	; 61
    2a50:	de b7       	in	r29, 0x3e	; 62
    2a52:	9b 83       	std	Y+3, r25	; 0x03
    2a54:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2a56:	0f b6       	in	r0, 0x3f	; 63
    2a58:	f8 94       	cli
    2a5a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2a5c:	ea 81       	ldd	r30, Y+2	; 0x02
    2a5e:	fb 81       	ldd	r31, Y+3	; 0x03
    2a60:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a62:	88 23       	and	r24, r24
    2a64:	19 f4       	brne	.+6      	; 0x2a6c <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    2a66:	81 e0       	ldi	r24, 0x01	; 1
    2a68:	89 83       	std	Y+1, r24	; 0x01
    2a6a:	01 c0       	rjmp	.+2      	; 0x2a6e <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    2a6c:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2a6e:	0f 90       	pop	r0
    2a70:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2a72:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a74:	0f 90       	pop	r0
    2a76:	0f 90       	pop	r0
    2a78:	0f 90       	pop	r0
    2a7a:	cf 91       	pop	r28
    2a7c:	df 91       	pop	r29
    2a7e:	08 95       	ret

00002a80 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2a80:	df 93       	push	r29
    2a82:	cf 93       	push	r28
    2a84:	00 d0       	rcall	.+0      	; 0x2a86 <xQueueIsQueueEmptyFromISR+0x6>
    2a86:	00 d0       	rcall	.+0      	; 0x2a88 <xQueueIsQueueEmptyFromISR+0x8>
    2a88:	0f 92       	push	r0
    2a8a:	cd b7       	in	r28, 0x3d	; 61
    2a8c:	de b7       	in	r29, 0x3e	; 62
    2a8e:	9d 83       	std	Y+5, r25	; 0x05
    2a90:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2a92:	8c 81       	ldd	r24, Y+4	; 0x04
    2a94:	9d 81       	ldd	r25, Y+5	; 0x05
    2a96:	9a 83       	std	Y+2, r25	; 0x02
    2a98:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2aa0:	88 23       	and	r24, r24
    2aa2:	19 f4       	brne	.+6      	; 0x2aaa <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    2aa4:	81 e0       	ldi	r24, 0x01	; 1
    2aa6:	8b 83       	std	Y+3, r24	; 0x03
    2aa8:	01 c0       	rjmp	.+2      	; 0x2aac <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    2aaa:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2aac:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2aae:	0f 90       	pop	r0
    2ab0:	0f 90       	pop	r0
    2ab2:	0f 90       	pop	r0
    2ab4:	0f 90       	pop	r0
    2ab6:	0f 90       	pop	r0
    2ab8:	cf 91       	pop	r28
    2aba:	df 91       	pop	r29
    2abc:	08 95       	ret

00002abe <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2abe:	df 93       	push	r29
    2ac0:	cf 93       	push	r28
    2ac2:	00 d0       	rcall	.+0      	; 0x2ac4 <prvIsQueueFull+0x6>
    2ac4:	0f 92       	push	r0
    2ac6:	cd b7       	in	r28, 0x3d	; 61
    2ac8:	de b7       	in	r29, 0x3e	; 62
    2aca:	9b 83       	std	Y+3, r25	; 0x03
    2acc:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2ace:	0f b6       	in	r0, 0x3f	; 63
    2ad0:	f8 94       	cli
    2ad2:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2ad4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ad6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ad8:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ada:	ea 81       	ldd	r30, Y+2	; 0x02
    2adc:	fb 81       	ldd	r31, Y+3	; 0x03
    2ade:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ae0:	98 17       	cp	r25, r24
    2ae2:	19 f4       	brne	.+6      	; 0x2aea <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    2ae4:	81 e0       	ldi	r24, 0x01	; 1
    2ae6:	89 83       	std	Y+1, r24	; 0x01
    2ae8:	01 c0       	rjmp	.+2      	; 0x2aec <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    2aea:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2aec:	0f 90       	pop	r0
    2aee:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2af0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2af2:	0f 90       	pop	r0
    2af4:	0f 90       	pop	r0
    2af6:	0f 90       	pop	r0
    2af8:	cf 91       	pop	r28
    2afa:	df 91       	pop	r29
    2afc:	08 95       	ret

00002afe <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2afe:	df 93       	push	r29
    2b00:	cf 93       	push	r28
    2b02:	00 d0       	rcall	.+0      	; 0x2b04 <xQueueIsQueueFullFromISR+0x6>
    2b04:	00 d0       	rcall	.+0      	; 0x2b06 <xQueueIsQueueFullFromISR+0x8>
    2b06:	0f 92       	push	r0
    2b08:	cd b7       	in	r28, 0x3d	; 61
    2b0a:	de b7       	in	r29, 0x3e	; 62
    2b0c:	9d 83       	std	Y+5, r25	; 0x05
    2b0e:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2b10:	8c 81       	ldd	r24, Y+4	; 0x04
    2b12:	9d 81       	ldd	r25, Y+5	; 0x05
    2b14:	9a 83       	std	Y+2, r25	; 0x02
    2b16:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2b18:	e9 81       	ldd	r30, Y+1	; 0x01
    2b1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b20:	fa 81       	ldd	r31, Y+2	; 0x02
    2b22:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b24:	98 17       	cp	r25, r24
    2b26:	19 f4       	brne	.+6      	; 0x2b2e <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    2b28:	81 e0       	ldi	r24, 0x01	; 1
    2b2a:	8b 83       	std	Y+3, r24	; 0x03
    2b2c:	01 c0       	rjmp	.+2      	; 0x2b30 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    2b2e:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2b30:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	0f 90       	pop	r0
    2b38:	0f 90       	pop	r0
    2b3a:	0f 90       	pop	r0
    2b3c:	cf 91       	pop	r28
    2b3e:	df 91       	pop	r29
    2b40:	08 95       	ret

00002b42 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    2b42:	cf 92       	push	r12
    2b44:	df 92       	push	r13
    2b46:	ef 92       	push	r14
    2b48:	ff 92       	push	r15
    2b4a:	0f 93       	push	r16
    2b4c:	1f 93       	push	r17
    2b4e:	df 93       	push	r29
    2b50:	cf 93       	push	r28
    2b52:	cd b7       	in	r28, 0x3d	; 61
    2b54:	de b7       	in	r29, 0x3e	; 62
    2b56:	2c 97       	sbiw	r28, 0x0c	; 12
    2b58:	0f b6       	in	r0, 0x3f	; 63
    2b5a:	f8 94       	cli
    2b5c:	de bf       	out	0x3e, r29	; 62
    2b5e:	0f be       	out	0x3f, r0	; 63
    2b60:	cd bf       	out	0x3d, r28	; 61
    2b62:	9d 83       	std	Y+5, r25	; 0x05
    2b64:	8c 83       	std	Y+4, r24	; 0x04
    2b66:	7f 83       	std	Y+7, r23	; 0x07
    2b68:	6e 83       	std	Y+6, r22	; 0x06
    2b6a:	48 87       	std	Y+8, r20	; 0x08
    2b6c:	3a 87       	std	Y+10, r19	; 0x0a
    2b6e:	29 87       	std	Y+9, r18	; 0x09
    2b70:	1c 87       	std	Y+12, r17	; 0x0c
    2b72:	0b 87       	std	Y+11, r16	; 0x0b

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    2b74:	88 85       	ldd	r24, Y+8	; 0x08
    2b76:	81 30       	cpi	r24, 0x01	; 1
    2b78:	19 f4       	brne	.+6      	; 0x2b80 <xStreamBufferGenericCreate+0x3e>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2b7a:	81 e0       	ldi	r24, 0x01	; 1
    2b7c:	89 83       	std	Y+1, r24	; 0x01
    2b7e:	01 c0       	rjmp	.+2      	; 0x2b82 <xStreamBufferGenericCreate+0x40>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    2b80:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    2b82:	8e 81       	ldd	r24, Y+6	; 0x06
    2b84:	9f 81       	ldd	r25, Y+7	; 0x07
    2b86:	00 97       	sbiw	r24, 0x00	; 0
    2b88:	21 f4       	brne	.+8      	; 0x2b92 <xStreamBufferGenericCreate+0x50>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    2b8a:	81 e0       	ldi	r24, 0x01	; 1
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	9f 83       	std	Y+7, r25	; 0x07
    2b90:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    2b92:	8c 81       	ldd	r24, Y+4	; 0x04
    2b94:	9d 81       	ldd	r25, Y+5	; 0x05
    2b96:	9c 01       	movw	r18, r24
    2b98:	20 5f       	subi	r18, 0xF0	; 240
    2b9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2b9c:	8c 81       	ldd	r24, Y+4	; 0x04
    2b9e:	9d 81       	ldd	r25, Y+5	; 0x05
    2ba0:	82 17       	cp	r24, r18
    2ba2:	93 07       	cpc	r25, r19
    2ba4:	68 f4       	brcc	.+26     	; 0x2bc0 <xStreamBufferGenericCreate+0x7e>
        {
            xBufferSizeBytes++;
    2ba6:	8c 81       	ldd	r24, Y+4	; 0x04
    2ba8:	9d 81       	ldd	r25, Y+5	; 0x05
    2baa:	01 96       	adiw	r24, 0x01	; 1
    2bac:	9d 83       	std	Y+5, r25	; 0x05
    2bae:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2bb0:	8c 81       	ldd	r24, Y+4	; 0x04
    2bb2:	9d 81       	ldd	r25, Y+5	; 0x05
    2bb4:	0f 96       	adiw	r24, 0x0f	; 15
    2bb6:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    2bba:	9b 83       	std	Y+3, r25	; 0x03
    2bbc:	8a 83       	std	Y+2, r24	; 0x02
    2bbe:	02 c0       	rjmp	.+4      	; 0x2bc4 <xStreamBufferGenericCreate+0x82>
        }
        else
        {
            pucAllocatedMemory = NULL;
    2bc0:	1b 82       	std	Y+3, r1	; 0x03
    2bc2:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    2bc4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bc6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bc8:	00 97       	sbiw	r24, 0x00	; 0
    2bca:	b1 f0       	breq	.+44     	; 0x2bf8 <xStreamBufferGenericCreate+0xb6>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2bcc:	6a 81       	ldd	r22, Y+2	; 0x02
    2bce:	7b 81       	ldd	r23, Y+3	; 0x03
    2bd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2bd2:	9b 81       	ldd	r25, Y+3	; 0x03
    2bd4:	9c 01       	movw	r18, r24
    2bd6:	21 5f       	subi	r18, 0xF1	; 241
    2bd8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bda:	4c 81       	ldd	r20, Y+4	; 0x04
    2bdc:	5d 81       	ldd	r21, Y+5	; 0x05
    2bde:	ee 81       	ldd	r30, Y+6	; 0x06
    2be0:	ff 81       	ldd	r31, Y+7	; 0x07
    2be2:	a9 85       	ldd	r26, Y+9	; 0x09
    2be4:	ba 85       	ldd	r27, Y+10	; 0x0a
    2be6:	cb 84       	ldd	r12, Y+11	; 0x0b
    2be8:	dc 84       	ldd	r13, Y+12	; 0x0c
    2bea:	cb 01       	movw	r24, r22
    2bec:	b9 01       	movw	r22, r18
    2bee:	9f 01       	movw	r18, r30
    2bf0:	09 81       	ldd	r16, Y+1	; 0x01
    2bf2:	7d 01       	movw	r14, r26
    2bf4:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfa:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    2bfc:	2c 96       	adiw	r28, 0x0c	; 12
    2bfe:	0f b6       	in	r0, 0x3f	; 63
    2c00:	f8 94       	cli
    2c02:	de bf       	out	0x3e, r29	; 62
    2c04:	0f be       	out	0x3f, r0	; 63
    2c06:	cd bf       	out	0x3d, r28	; 61
    2c08:	cf 91       	pop	r28
    2c0a:	df 91       	pop	r29
    2c0c:	1f 91       	pop	r17
    2c0e:	0f 91       	pop	r16
    2c10:	ff 90       	pop	r15
    2c12:	ef 90       	pop	r14
    2c14:	df 90       	pop	r13
    2c16:	cf 90       	pop	r12
    2c18:	08 95       	ret

00002c1a <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2c1a:	df 93       	push	r29
    2c1c:	cf 93       	push	r28
    2c1e:	00 d0       	rcall	.+0      	; 0x2c20 <vStreamBufferDelete+0x6>
    2c20:	00 d0       	rcall	.+0      	; 0x2c22 <vStreamBufferDelete+0x8>
    2c22:	cd b7       	in	r28, 0x3d	; 61
    2c24:	de b7       	in	r29, 0x3e	; 62
    2c26:	9c 83       	std	Y+4, r25	; 0x04
    2c28:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2e:	9a 83       	std	Y+2, r25	; 0x02
    2c30:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2c32:	e9 81       	ldd	r30, Y+1	; 0x01
    2c34:	fa 81       	ldd	r31, Y+2	; 0x02
    2c36:	86 85       	ldd	r24, Z+14	; 0x0e
    2c38:	88 2f       	mov	r24, r24
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	82 70       	andi	r24, 0x02	; 2
    2c3e:	90 70       	andi	r25, 0x00	; 0
    2c40:	00 97       	sbiw	r24, 0x00	; 0
    2c42:	29 f4       	brne	.+10     	; 0x2c4e <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2c44:	89 81       	ldd	r24, Y+1	; 0x01
    2c46:	9a 81       	ldd	r25, Y+2	; 0x02
    2c48:	0e 94 a9 06 	call	0xd52	; 0xd52 <vPortFree>
    2c4c:	08 c0       	rjmp	.+16     	; 0x2c5e <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2c4e:	89 81       	ldd	r24, Y+1	; 0x01
    2c50:	9a 81       	ldd	r25, Y+2	; 0x02
    2c52:	60 e0       	ldi	r22, 0x00	; 0
    2c54:	70 e0       	ldi	r23, 0x00	; 0
    2c56:	4f e0       	ldi	r20, 0x0F	; 15
    2c58:	50 e0       	ldi	r21, 0x00	; 0
    2c5a:	0e 94 e9 3d 	call	0x7bd2	; 0x7bd2 <memset>
    }
}
    2c5e:	0f 90       	pop	r0
    2c60:	0f 90       	pop	r0
    2c62:	0f 90       	pop	r0
    2c64:	0f 90       	pop	r0
    2c66:	cf 91       	pop	r28
    2c68:	df 91       	pop	r29
    2c6a:	08 95       	ret

00002c6c <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2c6c:	cf 92       	push	r12
    2c6e:	df 92       	push	r13
    2c70:	ef 92       	push	r14
    2c72:	ff 92       	push	r15
    2c74:	0f 93       	push	r16
    2c76:	1f 93       	push	r17
    2c78:	df 93       	push	r29
    2c7a:	cf 93       	push	r28
    2c7c:	cd b7       	in	r28, 0x3d	; 61
    2c7e:	de b7       	in	r29, 0x3e	; 62
    2c80:	29 97       	sbiw	r28, 0x09	; 9
    2c82:	0f b6       	in	r0, 0x3f	; 63
    2c84:	f8 94       	cli
    2c86:	de bf       	out	0x3e, r29	; 62
    2c88:	0f be       	out	0x3f, r0	; 63
    2c8a:	cd bf       	out	0x3d, r28	; 61
    2c8c:	99 87       	std	Y+9, r25	; 0x09
    2c8e:	88 87       	std	Y+8, r24	; 0x08
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c90:	88 85       	ldd	r24, Y+8	; 0x08
    2c92:	99 85       	ldd	r25, Y+9	; 0x09
    2c94:	9f 83       	std	Y+7, r25	; 0x07
    2c96:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn = pdFAIL;
    2c98:	1d 82       	std	Y+5, r1	; 0x05
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
    2c9a:	1c 82       	std	Y+4, r1	; 0x04
    2c9c:	1b 82       	std	Y+3, r1	; 0x03
    2c9e:	1a 82       	std	Y+2, r1	; 0x02
    2ca0:	19 82       	std	Y+1, r1	; 0x01
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    2ca2:	0f b6       	in	r0, 0x3f	; 63
    2ca4:	f8 94       	cli
    2ca6:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    2ca8:	ee 81       	ldd	r30, Y+6	; 0x06
    2caa:	ff 81       	ldd	r31, Y+7	; 0x07
    2cac:	80 85       	ldd	r24, Z+8	; 0x08
    2cae:	91 85       	ldd	r25, Z+9	; 0x09
    2cb0:	00 97       	sbiw	r24, 0x00	; 0
    2cb2:	21 f5       	brne	.+72     	; 0x2cfc <xStreamBufferReset+0x90>
    2cb4:	ee 81       	ldd	r30, Y+6	; 0x06
    2cb6:	ff 81       	ldd	r31, Y+7	; 0x07
    2cb8:	82 85       	ldd	r24, Z+10	; 0x0a
    2cba:	93 85       	ldd	r25, Z+11	; 0x0b
    2cbc:	00 97       	sbiw	r24, 0x00	; 0
    2cbe:	f1 f4       	brne	.+60     	; 0x2cfc <xStreamBufferReset+0x90>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2cc0:	ee 81       	ldd	r30, Y+6	; 0x06
    2cc2:	ff 81       	ldd	r31, Y+7	; 0x07
    2cc4:	44 85       	ldd	r20, Z+12	; 0x0c
    2cc6:	55 85       	ldd	r21, Z+13	; 0x0d
    2cc8:	ee 81       	ldd	r30, Y+6	; 0x06
    2cca:	ff 81       	ldd	r31, Y+7	; 0x07
    2ccc:	24 81       	ldd	r18, Z+4	; 0x04
    2cce:	35 81       	ldd	r19, Z+5	; 0x05
    2cd0:	ee 81       	ldd	r30, Y+6	; 0x06
    2cd2:	ff 81       	ldd	r31, Y+7	; 0x07
    2cd4:	a6 81       	ldd	r26, Z+6	; 0x06
    2cd6:	b7 81       	ldd	r27, Z+7	; 0x07
    2cd8:	ee 81       	ldd	r30, Y+6	; 0x06
    2cda:	ff 81       	ldd	r31, Y+7	; 0x07
    2cdc:	16 85       	ldd	r17, Z+14	; 0x0e
    2cde:	8e 81       	ldd	r24, Y+6	; 0x06
    2ce0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ce2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce6:	c9 80       	ldd	r12, Y+1	; 0x01
    2ce8:	da 80       	ldd	r13, Y+2	; 0x02
    2cea:	ba 01       	movw	r22, r20
    2cec:	a9 01       	movw	r20, r18
    2cee:	9d 01       	movw	r18, r26
    2cf0:	01 2f       	mov	r16, r17
    2cf2:	7f 01       	movw	r14, r30
    2cf4:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
    2cf8:	81 e0       	ldi	r24, 0x01	; 1
    2cfa:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    2cfc:	0f 90       	pop	r0
    2cfe:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2d00:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2d02:	29 96       	adiw	r28, 0x09	; 9
    2d04:	0f b6       	in	r0, 0x3f	; 63
    2d06:	f8 94       	cli
    2d08:	de bf       	out	0x3e, r29	; 62
    2d0a:	0f be       	out	0x3f, r0	; 63
    2d0c:	cd bf       	out	0x3d, r28	; 61
    2d0e:	cf 91       	pop	r28
    2d10:	df 91       	pop	r29
    2d12:	1f 91       	pop	r17
    2d14:	0f 91       	pop	r16
    2d16:	ff 90       	pop	r15
    2d18:	ef 90       	pop	r14
    2d1a:	df 90       	pop	r13
    2d1c:	cf 90       	pop	r12
    2d1e:	08 95       	ret

00002d20 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    2d20:	df 93       	push	r29
    2d22:	cf 93       	push	r28
    2d24:	cd b7       	in	r28, 0x3d	; 61
    2d26:	de b7       	in	r29, 0x3e	; 62
    2d28:	27 97       	sbiw	r28, 0x07	; 7
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	de bf       	out	0x3e, r29	; 62
    2d30:	0f be       	out	0x3f, r0	; 63
    2d32:	cd bf       	out	0x3d, r28	; 61
    2d34:	9d 83       	std	Y+5, r25	; 0x05
    2d36:	8c 83       	std	Y+4, r24	; 0x04
    2d38:	7f 83       	std	Y+7, r23	; 0x07
    2d3a:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2d3c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d3e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d40:	9b 83       	std	Y+3, r25	; 0x03
    2d42:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    2d44:	8e 81       	ldd	r24, Y+6	; 0x06
    2d46:	9f 81       	ldd	r25, Y+7	; 0x07
    2d48:	00 97       	sbiw	r24, 0x00	; 0
    2d4a:	21 f4       	brne	.+8      	; 0x2d54 <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    2d4c:	81 e0       	ldi	r24, 0x01	; 1
    2d4e:	90 e0       	ldi	r25, 0x00	; 0
    2d50:	9f 83       	std	Y+7, r25	; 0x07
    2d52:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    2d54:	ea 81       	ldd	r30, Y+2	; 0x02
    2d56:	fb 81       	ldd	r31, Y+3	; 0x03
    2d58:	24 81       	ldd	r18, Z+4	; 0x04
    2d5a:	35 81       	ldd	r19, Z+5	; 0x05
    2d5c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d5e:	9f 81       	ldd	r25, Y+7	; 0x07
    2d60:	82 17       	cp	r24, r18
    2d62:	93 07       	cpc	r25, r19
    2d64:	48 f4       	brcc	.+18     	; 0x2d78 <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2d66:	ea 81       	ldd	r30, Y+2	; 0x02
    2d68:	fb 81       	ldd	r31, Y+3	; 0x03
    2d6a:	8e 81       	ldd	r24, Y+6	; 0x06
    2d6c:	9f 81       	ldd	r25, Y+7	; 0x07
    2d6e:	97 83       	std	Z+7, r25	; 0x07
    2d70:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    2d72:	81 e0       	ldi	r24, 0x01	; 1
    2d74:	89 83       	std	Y+1, r24	; 0x01
    2d76:	01 c0       	rjmp	.+2      	; 0x2d7a <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    2d78:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    2d7a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d7c:	27 96       	adiw	r28, 0x07	; 7
    2d7e:	0f b6       	in	r0, 0x3f	; 63
    2d80:	f8 94       	cli
    2d82:	de bf       	out	0x3e, r29	; 62
    2d84:	0f be       	out	0x3f, r0	; 63
    2d86:	cd bf       	out	0x3d, r28	; 61
    2d88:	cf 91       	pop	r28
    2d8a:	df 91       	pop	r29
    2d8c:	08 95       	ret

00002d8e <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2d8e:	df 93       	push	r29
    2d90:	cf 93       	push	r28
    2d92:	cd b7       	in	r28, 0x3d	; 61
    2d94:	de b7       	in	r29, 0x3e	; 62
    2d96:	28 97       	sbiw	r28, 0x08	; 8
    2d98:	0f b6       	in	r0, 0x3f	; 63
    2d9a:	f8 94       	cli
    2d9c:	de bf       	out	0x3e, r29	; 62
    2d9e:	0f be       	out	0x3f, r0	; 63
    2da0:	cd bf       	out	0x3d, r28	; 61
    2da2:	98 87       	std	Y+8, r25	; 0x08
    2da4:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2da6:	8f 81       	ldd	r24, Y+7	; 0x07
    2da8:	98 85       	ldd	r25, Y+8	; 0x08
    2daa:	9e 83       	std	Y+6, r25	; 0x06
    2dac:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    2dae:	ed 81       	ldd	r30, Y+5	; 0x05
    2db0:	fe 81       	ldd	r31, Y+6	; 0x06
    2db2:	80 81       	ld	r24, Z
    2db4:	91 81       	ldd	r25, Z+1	; 0x01
    2db6:	9a 83       	std	Y+2, r25	; 0x02
    2db8:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2dba:	ed 81       	ldd	r30, Y+5	; 0x05
    2dbc:	fe 81       	ldd	r31, Y+6	; 0x06
    2dbe:	24 81       	ldd	r18, Z+4	; 0x04
    2dc0:	35 81       	ldd	r19, Z+5	; 0x05
    2dc2:	ed 81       	ldd	r30, Y+5	; 0x05
    2dc4:	fe 81       	ldd	r31, Y+6	; 0x06
    2dc6:	80 81       	ld	r24, Z
    2dc8:	91 81       	ldd	r25, Z+1	; 0x01
    2dca:	82 0f       	add	r24, r18
    2dcc:	93 1f       	adc	r25, r19
    2dce:	9c 83       	std	Y+4, r25	; 0x04
    2dd0:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    2dd2:	ed 81       	ldd	r30, Y+5	; 0x05
    2dd4:	fe 81       	ldd	r31, Y+6	; 0x06
    2dd6:	22 81       	ldd	r18, Z+2	; 0x02
    2dd8:	33 81       	ldd	r19, Z+3	; 0x03
    2dda:	8b 81       	ldd	r24, Y+3	; 0x03
    2ddc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dde:	82 1b       	sub	r24, r18
    2de0:	93 0b       	sbc	r25, r19
    2de2:	9c 83       	std	Y+4, r25	; 0x04
    2de4:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    2de6:	ed 81       	ldd	r30, Y+5	; 0x05
    2de8:	fe 81       	ldd	r31, Y+6	; 0x06
    2dea:	20 81       	ld	r18, Z
    2dec:	31 81       	ldd	r19, Z+1	; 0x01
    2dee:	89 81       	ldd	r24, Y+1	; 0x01
    2df0:	9a 81       	ldd	r25, Y+2	; 0x02
    2df2:	28 17       	cp	r18, r24
    2df4:	39 07       	cpc	r19, r25
    2df6:	d9 f6       	brne	.-74     	; 0x2dae <xStreamBufferSpacesAvailable+0x20>

    xSpace -= ( size_t ) 1;
    2df8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dfa:	9c 81       	ldd	r25, Y+4	; 0x04
    2dfc:	01 97       	sbiw	r24, 0x01	; 1
    2dfe:	9c 83       	std	Y+4, r25	; 0x04
    2e00:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    2e02:	ed 81       	ldd	r30, Y+5	; 0x05
    2e04:	fe 81       	ldd	r31, Y+6	; 0x06
    2e06:	24 81       	ldd	r18, Z+4	; 0x04
    2e08:	35 81       	ldd	r19, Z+5	; 0x05
    2e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0e:	82 17       	cp	r24, r18
    2e10:	93 07       	cpc	r25, r19
    2e12:	50 f0       	brcs	.+20     	; 0x2e28 <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    2e14:	ed 81       	ldd	r30, Y+5	; 0x05
    2e16:	fe 81       	ldd	r31, Y+6	; 0x06
    2e18:	24 81       	ldd	r18, Z+4	; 0x04
    2e1a:	35 81       	ldd	r19, Z+5	; 0x05
    2e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e20:	82 1b       	sub	r24, r18
    2e22:	93 0b       	sbc	r25, r19
    2e24:	9c 83       	std	Y+4, r25	; 0x04
    2e26:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    2e28:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2e2c:	28 96       	adiw	r28, 0x08	; 8
    2e2e:	0f b6       	in	r0, 0x3f	; 63
    2e30:	f8 94       	cli
    2e32:	de bf       	out	0x3e, r29	; 62
    2e34:	0f be       	out	0x3f, r0	; 63
    2e36:	cd bf       	out	0x3d, r28	; 61
    2e38:	cf 91       	pop	r28
    2e3a:	df 91       	pop	r29
    2e3c:	08 95       	ret

00002e3e <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2e3e:	df 93       	push	r29
    2e40:	cf 93       	push	r28
    2e42:	00 d0       	rcall	.+0      	; 0x2e44 <xStreamBufferBytesAvailable+0x6>
    2e44:	00 d0       	rcall	.+0      	; 0x2e46 <xStreamBufferBytesAvailable+0x8>
    2e46:	00 d0       	rcall	.+0      	; 0x2e48 <xStreamBufferBytesAvailable+0xa>
    2e48:	cd b7       	in	r28, 0x3d	; 61
    2e4a:	de b7       	in	r29, 0x3e	; 62
    2e4c:	9e 83       	std	Y+6, r25	; 0x06
    2e4e:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2e50:	8d 81       	ldd	r24, Y+5	; 0x05
    2e52:	9e 81       	ldd	r25, Y+6	; 0x06
    2e54:	9c 83       	std	Y+4, r25	; 0x04
    2e56:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    2e58:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5c:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    2e60:	9a 83       	std	Y+2, r25	; 0x02
    2e62:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    2e64:	89 81       	ldd	r24, Y+1	; 0x01
    2e66:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e68:	26 96       	adiw	r28, 0x06	; 6
    2e6a:	0f b6       	in	r0, 0x3f	; 63
    2e6c:	f8 94       	cli
    2e6e:	de bf       	out	0x3e, r29	; 62
    2e70:	0f be       	out	0x3f, r0	; 63
    2e72:	cd bf       	out	0x3d, r28	; 61
    2e74:	cf 91       	pop	r28
    2e76:	df 91       	pop	r29
    2e78:	08 95       	ret

00002e7a <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    2e7a:	cf 92       	push	r12
    2e7c:	df 92       	push	r13
    2e7e:	ef 92       	push	r14
    2e80:	ff 92       	push	r15
    2e82:	0f 93       	push	r16
    2e84:	1f 93       	push	r17
    2e86:	df 93       	push	r29
    2e88:	cf 93       	push	r28
    2e8a:	cd b7       	in	r28, 0x3d	; 61
    2e8c:	de b7       	in	r29, 0x3e	; 62
    2e8e:	65 97       	sbiw	r28, 0x15	; 21
    2e90:	0f b6       	in	r0, 0x3f	; 63
    2e92:	f8 94       	cli
    2e94:	de bf       	out	0x3e, r29	; 62
    2e96:	0f be       	out	0x3f, r0	; 63
    2e98:	cd bf       	out	0x3d, r28	; 61
    2e9a:	9f 87       	std	Y+15, r25	; 0x0f
    2e9c:	8e 87       	std	Y+14, r24	; 0x0e
    2e9e:	79 8b       	std	Y+17, r23	; 0x11
    2ea0:	68 8b       	std	Y+16, r22	; 0x10
    2ea2:	5b 8b       	std	Y+19, r21	; 0x13
    2ea4:	4a 8b       	std	Y+18, r20	; 0x12
    2ea6:	3d 8b       	std	Y+21, r19	; 0x15
    2ea8:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2eaa:	8e 85       	ldd	r24, Y+14	; 0x0e
    2eac:	9f 85       	ldd	r25, Y+15	; 0x0f
    2eae:	9a 87       	std	Y+10, r25	; 0x0a
    2eb0:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    2eb2:	1e 82       	std	Y+6, r1	; 0x06
    2eb4:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    2eb6:	8a 89       	ldd	r24, Y+18	; 0x12
    2eb8:	9b 89       	ldd	r25, Y+19	; 0x13
    2eba:	9c 83       	std	Y+4, r25	; 0x04
    2ebc:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    2ebe:	1a 82       	std	Y+2, r1	; 0x02
    2ec0:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    2ec2:	e9 85       	ldd	r30, Y+9	; 0x09
    2ec4:	fa 85       	ldd	r31, Y+10	; 0x0a
    2ec6:	84 81       	ldd	r24, Z+4	; 0x04
    2ec8:	95 81       	ldd	r25, Z+5	; 0x05
    2eca:	01 97       	sbiw	r24, 0x01	; 1
    2ecc:	9a 83       	std	Y+2, r25	; 0x02
    2ece:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2ed0:	e9 85       	ldd	r30, Y+9	; 0x09
    2ed2:	fa 85       	ldd	r31, Y+10	; 0x0a
    2ed4:	86 85       	ldd	r24, Z+14	; 0x0e
    2ed6:	88 2f       	mov	r24, r24
    2ed8:	90 e0       	ldi	r25, 0x00	; 0
    2eda:	81 70       	andi	r24, 0x01	; 1
    2edc:	90 70       	andi	r25, 0x00	; 0
    2ede:	88 23       	and	r24, r24
    2ee0:	79 f0       	breq	.+30     	; 0x2f00 <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee6:	02 96       	adiw	r24, 0x02	; 2
    2ee8:	9c 83       	std	Y+4, r25	; 0x04
    2eea:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    2eec:	2b 81       	ldd	r18, Y+3	; 0x03
    2eee:	3c 81       	ldd	r19, Y+4	; 0x04
    2ef0:	89 81       	ldd	r24, Y+1	; 0x01
    2ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef4:	82 17       	cp	r24, r18
    2ef6:	93 07       	cpc	r25, r19
    2ef8:	70 f4       	brcc	.+28     	; 0x2f16 <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    2efa:	1d 8a       	std	Y+21, r1	; 0x15
    2efc:	1c 8a       	std	Y+20, r1	; 0x14
    2efe:	0b c0       	rjmp	.+22     	; 0x2f16 <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    2f00:	2b 81       	ldd	r18, Y+3	; 0x03
    2f02:	3c 81       	ldd	r19, Y+4	; 0x04
    2f04:	89 81       	ldd	r24, Y+1	; 0x01
    2f06:	9a 81       	ldd	r25, Y+2	; 0x02
    2f08:	82 17       	cp	r24, r18
    2f0a:	93 07       	cpc	r25, r19
    2f0c:	20 f4       	brcc	.+8      	; 0x2f16 <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    2f0e:	89 81       	ldd	r24, Y+1	; 0x01
    2f10:	9a 81       	ldd	r25, Y+2	; 0x02
    2f12:	9c 83       	std	Y+4, r25	; 0x04
    2f14:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    2f16:	8c 89       	ldd	r24, Y+20	; 0x14
    2f18:	9d 89       	ldd	r25, Y+21	; 0x15
    2f1a:	00 97       	sbiw	r24, 0x00	; 0
    2f1c:	09 f4       	brne	.+2      	; 0x2f20 <xStreamBufferSend+0xa6>
    2f1e:	43 c0       	rjmp	.+134    	; 0x2fa6 <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    2f20:	ce 01       	movw	r24, r28
    2f22:	0b 96       	adiw	r24, 0x0b	; 11
    2f24:	0e 94 99 27 	call	0x4f32	; 0x4f32 <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    2f28:	0f b6       	in	r0, 0x3f	; 63
    2f2a:	f8 94       	cli
    2f2c:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2f2e:	89 85       	ldd	r24, Y+9	; 0x09
    2f30:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f32:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <xStreamBufferSpacesAvailable>
    2f36:	9e 83       	std	Y+6, r25	; 0x06
    2f38:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    2f3a:	2d 81       	ldd	r18, Y+5	; 0x05
    2f3c:	3e 81       	ldd	r19, Y+6	; 0x06
    2f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f40:	9c 81       	ldd	r25, Y+4	; 0x04
    2f42:	28 17       	cp	r18, r24
    2f44:	39 07       	cpc	r19, r25
    2f46:	68 f5       	brcc	.+90     	; 0x2fa2 <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    2f48:	80 e0       	ldi	r24, 0x00	; 0
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	60 e0       	ldi	r22, 0x00	; 0
    2f4e:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2f52:	0e 94 f5 28 	call	0x51ea	; 0x51ea <xTaskGetCurrentTaskHandle>
    2f56:	e9 85       	ldd	r30, Y+9	; 0x09
    2f58:	fa 85       	ldd	r31, Y+10	; 0x0a
    2f5a:	93 87       	std	Z+11, r25	; 0x0b
    2f5c:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    2f5e:	0f 90       	pop	r0
    2f60:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2f62:	ec 89       	ldd	r30, Y+20	; 0x14
    2f64:	fd 89       	ldd	r31, Y+21	; 0x15
    2f66:	80 e0       	ldi	r24, 0x00	; 0
    2f68:	40 e0       	ldi	r20, 0x00	; 0
    2f6a:	50 e0       	ldi	r21, 0x00	; 0
    2f6c:	60 e0       	ldi	r22, 0x00	; 0
    2f6e:	70 e0       	ldi	r23, 0x00	; 0
    2f70:	00 e0       	ldi	r16, 0x00	; 0
    2f72:	10 e0       	ldi	r17, 0x00	; 0
    2f74:	20 e0       	ldi	r18, 0x00	; 0
    2f76:	30 e0       	ldi	r19, 0x00	; 0
    2f78:	ee 24       	eor	r14, r14
    2f7a:	ff 24       	eor	r15, r15
    2f7c:	6f 01       	movw	r12, r30
    2f7e:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    2f82:	e9 85       	ldd	r30, Y+9	; 0x09
    2f84:	fa 85       	ldd	r31, Y+10	; 0x0a
    2f86:	13 86       	std	Z+11, r1	; 0x0b
    2f88:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2f8a:	ce 01       	movw	r24, r28
    2f8c:	0b 96       	adiw	r24, 0x0b	; 11
    2f8e:	9e 01       	movw	r18, r28
    2f90:	2c 5e       	subi	r18, 0xEC	; 236
    2f92:	3f 4f       	sbci	r19, 0xFF	; 255
    2f94:	b9 01       	movw	r22, r18
    2f96:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <xTaskCheckForTimeOut>
    2f9a:	88 23       	and	r24, r24
    2f9c:	09 f4       	brne	.+2      	; 0x2fa0 <xStreamBufferSend+0x126>
    2f9e:	c4 cf       	rjmp	.-120    	; 0x2f28 <xStreamBufferSend+0xae>
    2fa0:	02 c0       	rjmp	.+4      	; 0x2fa6 <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    2fa2:	0f 90       	pop	r0
    2fa4:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    2fa6:	8d 81       	ldd	r24, Y+5	; 0x05
    2fa8:	9e 81       	ldd	r25, Y+6	; 0x06
    2faa:	00 97       	sbiw	r24, 0x00	; 0
    2fac:	31 f4       	brne	.+12     	; 0x2fba <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2fae:	89 85       	ldd	r24, Y+9	; 0x09
    2fb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fb2:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <xStreamBufferSpacesAvailable>
    2fb6:	9e 83       	std	Y+6, r25	; 0x06
    2fb8:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2fba:	89 85       	ldd	r24, Y+9	; 0x09
    2fbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fbe:	28 89       	ldd	r18, Y+16	; 0x10
    2fc0:	39 89       	ldd	r19, Y+17	; 0x11
    2fc2:	4a 89       	ldd	r20, Y+18	; 0x12
    2fc4:	5b 89       	ldd	r21, Y+19	; 0x13
    2fc6:	ed 81       	ldd	r30, Y+5	; 0x05
    2fc8:	fe 81       	ldd	r31, Y+6	; 0x06
    2fca:	ab 81       	ldd	r26, Y+3	; 0x03
    2fcc:	bc 81       	ldd	r27, Y+4	; 0x04
    2fce:	b9 01       	movw	r22, r18
    2fd0:	9f 01       	movw	r18, r30
    2fd2:	8d 01       	movw	r16, r26
    2fd4:	0e 94 ad 18 	call	0x315a	; 0x315a <prvWriteMessageToBuffer>
    2fd8:	98 87       	std	Y+8, r25	; 0x08
    2fda:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    2fdc:	8f 81       	ldd	r24, Y+7	; 0x07
    2fde:	98 85       	ldd	r25, Y+8	; 0x08
    2fe0:	00 97       	sbiw	r24, 0x00	; 0
    2fe2:	41 f1       	breq	.+80     	; 0x3034 <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2fe4:	89 85       	ldd	r24, Y+9	; 0x09
    2fe6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fe8:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    2fec:	9c 01       	movw	r18, r24
    2fee:	e9 85       	ldd	r30, Y+9	; 0x09
    2ff0:	fa 85       	ldd	r31, Y+10	; 0x0a
    2ff2:	86 81       	ldd	r24, Z+6	; 0x06
    2ff4:	97 81       	ldd	r25, Z+7	; 0x07
    2ff6:	28 17       	cp	r18, r24
    2ff8:	39 07       	cpc	r19, r25
    2ffa:	e0 f0       	brcs	.+56     	; 0x3034 <xStreamBufferSend+0x1ba>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    2ffc:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
    3000:	e9 85       	ldd	r30, Y+9	; 0x09
    3002:	fa 85       	ldd	r31, Y+10	; 0x0a
    3004:	80 85       	ldd	r24, Z+8	; 0x08
    3006:	91 85       	ldd	r25, Z+9	; 0x09
    3008:	00 97       	sbiw	r24, 0x00	; 0
    300a:	91 f0       	breq	.+36     	; 0x3030 <xStreamBufferSend+0x1b6>
    300c:	e9 85       	ldd	r30, Y+9	; 0x09
    300e:	fa 85       	ldd	r31, Y+10	; 0x0a
    3010:	80 85       	ldd	r24, Z+8	; 0x08
    3012:	91 85       	ldd	r25, Z+9	; 0x09
    3014:	60 e0       	ldi	r22, 0x00	; 0
    3016:	20 e0       	ldi	r18, 0x00	; 0
    3018:	30 e0       	ldi	r19, 0x00	; 0
    301a:	40 e0       	ldi	r20, 0x00	; 0
    301c:	50 e0       	ldi	r21, 0x00	; 0
    301e:	00 e0       	ldi	r16, 0x00	; 0
    3020:	ee 24       	eor	r14, r14
    3022:	ff 24       	eor	r15, r15
    3024:	0e 94 db 2a 	call	0x55b6	; 0x55b6 <xTaskGenericNotify>
    3028:	e9 85       	ldd	r30, Y+9	; 0x09
    302a:	fa 85       	ldd	r31, Y+10	; 0x0a
    302c:	11 86       	std	Z+9, r1	; 0x09
    302e:	10 86       	std	Z+8, r1	; 0x08
    3030:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    3034:	8f 81       	ldd	r24, Y+7	; 0x07
    3036:	98 85       	ldd	r25, Y+8	; 0x08
}
    3038:	65 96       	adiw	r28, 0x15	; 21
    303a:	0f b6       	in	r0, 0x3f	; 63
    303c:	f8 94       	cli
    303e:	de bf       	out	0x3e, r29	; 62
    3040:	0f be       	out	0x3f, r0	; 63
    3042:	cd bf       	out	0x3d, r28	; 61
    3044:	cf 91       	pop	r28
    3046:	df 91       	pop	r29
    3048:	1f 91       	pop	r17
    304a:	0f 91       	pop	r16
    304c:	ff 90       	pop	r15
    304e:	ef 90       	pop	r14
    3050:	df 90       	pop	r13
    3052:	cf 90       	pop	r12
    3054:	08 95       	ret

00003056 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3056:	cf 92       	push	r12
    3058:	df 92       	push	r13
    305a:	ef 92       	push	r14
    305c:	ff 92       	push	r15
    305e:	0f 93       	push	r16
    3060:	1f 93       	push	r17
    3062:	df 93       	push	r29
    3064:	cf 93       	push	r28
    3066:	cd b7       	in	r28, 0x3d	; 61
    3068:	de b7       	in	r29, 0x3e	; 62
    306a:	61 97       	sbiw	r28, 0x11	; 17
    306c:	0f b6       	in	r0, 0x3f	; 63
    306e:	f8 94       	cli
    3070:	de bf       	out	0x3e, r29	; 62
    3072:	0f be       	out	0x3f, r0	; 63
    3074:	cd bf       	out	0x3d, r28	; 61
    3076:	9b 87       	std	Y+11, r25	; 0x0b
    3078:	8a 87       	std	Y+10, r24	; 0x0a
    307a:	7d 87       	std	Y+13, r23	; 0x0d
    307c:	6c 87       	std	Y+12, r22	; 0x0c
    307e:	5f 87       	std	Y+15, r21	; 0x0f
    3080:	4e 87       	std	Y+14, r20	; 0x0e
    3082:	39 8b       	std	Y+17, r19	; 0x11
    3084:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3086:	8a 85       	ldd	r24, Y+10	; 0x0a
    3088:	9b 85       	ldd	r25, Y+11	; 0x0b
    308a:	99 87       	std	Y+9, r25	; 0x09
    308c:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    308e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3090:	9f 85       	ldd	r25, Y+15	; 0x0f
    3092:	9b 83       	std	Y+3, r25	; 0x03
    3094:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3096:	e8 85       	ldd	r30, Y+8	; 0x08
    3098:	f9 85       	ldd	r31, Y+9	; 0x09
    309a:	86 85       	ldd	r24, Z+14	; 0x0e
    309c:	88 2f       	mov	r24, r24
    309e:	90 e0       	ldi	r25, 0x00	; 0
    30a0:	81 70       	andi	r24, 0x01	; 1
    30a2:	90 70       	andi	r25, 0x00	; 0
    30a4:	88 23       	and	r24, r24
    30a6:	29 f0       	breq	.+10     	; 0x30b2 <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    30a8:	8a 81       	ldd	r24, Y+2	; 0x02
    30aa:	9b 81       	ldd	r25, Y+3	; 0x03
    30ac:	02 96       	adiw	r24, 0x02	; 2
    30ae:	9b 83       	std	Y+3, r25	; 0x03
    30b0:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    30b2:	88 85       	ldd	r24, Y+8	; 0x08
    30b4:	99 85       	ldd	r25, Y+9	; 0x09
    30b6:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <xStreamBufferSpacesAvailable>
    30ba:	9d 83       	std	Y+5, r25	; 0x05
    30bc:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    30be:	88 85       	ldd	r24, Y+8	; 0x08
    30c0:	99 85       	ldd	r25, Y+9	; 0x09
    30c2:	2c 85       	ldd	r18, Y+12	; 0x0c
    30c4:	3d 85       	ldd	r19, Y+13	; 0x0d
    30c6:	4e 85       	ldd	r20, Y+14	; 0x0e
    30c8:	5f 85       	ldd	r21, Y+15	; 0x0f
    30ca:	ec 81       	ldd	r30, Y+4	; 0x04
    30cc:	fd 81       	ldd	r31, Y+5	; 0x05
    30ce:	aa 81       	ldd	r26, Y+2	; 0x02
    30d0:	bb 81       	ldd	r27, Y+3	; 0x03
    30d2:	b9 01       	movw	r22, r18
    30d4:	9f 01       	movw	r18, r30
    30d6:	8d 01       	movw	r16, r26
    30d8:	0e 94 ad 18 	call	0x315a	; 0x315a <prvWriteMessageToBuffer>
    30dc:	9f 83       	std	Y+7, r25	; 0x07
    30de:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    30e0:	8e 81       	ldd	r24, Y+6	; 0x06
    30e2:	9f 81       	ldd	r25, Y+7	; 0x07
    30e4:	00 97       	sbiw	r24, 0x00	; 0
    30e6:	41 f1       	breq	.+80     	; 0x3138 <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    30e8:	88 85       	ldd	r24, Y+8	; 0x08
    30ea:	99 85       	ldd	r25, Y+9	; 0x09
    30ec:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    30f0:	9c 01       	movw	r18, r24
    30f2:	e8 85       	ldd	r30, Y+8	; 0x08
    30f4:	f9 85       	ldd	r31, Y+9	; 0x09
    30f6:	86 81       	ldd	r24, Z+6	; 0x06
    30f8:	97 81       	ldd	r25, Z+7	; 0x07
    30fa:	28 17       	cp	r18, r24
    30fc:	39 07       	cpc	r19, r25
    30fe:	e0 f0       	brcs	.+56     	; 0x3138 <xStreamBufferSendFromISR+0xe2>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3100:	19 82       	std	Y+1, r1	; 0x01
    3102:	e8 85       	ldd	r30, Y+8	; 0x08
    3104:	f9 85       	ldd	r31, Y+9	; 0x09
    3106:	80 85       	ldd	r24, Z+8	; 0x08
    3108:	91 85       	ldd	r25, Z+9	; 0x09
    310a:	00 97       	sbiw	r24, 0x00	; 0
    310c:	a9 f0       	breq	.+42     	; 0x3138 <xStreamBufferSendFromISR+0xe2>
    310e:	e8 85       	ldd	r30, Y+8	; 0x08
    3110:	f9 85       	ldd	r31, Y+9	; 0x09
    3112:	80 85       	ldd	r24, Z+8	; 0x08
    3114:	91 85       	ldd	r25, Z+9	; 0x09
    3116:	e8 89       	ldd	r30, Y+16	; 0x10
    3118:	f9 89       	ldd	r31, Y+17	; 0x11
    311a:	60 e0       	ldi	r22, 0x00	; 0
    311c:	20 e0       	ldi	r18, 0x00	; 0
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	40 e0       	ldi	r20, 0x00	; 0
    3122:	50 e0       	ldi	r21, 0x00	; 0
    3124:	00 e0       	ldi	r16, 0x00	; 0
    3126:	ee 24       	eor	r14, r14
    3128:	ff 24       	eor	r15, r15
    312a:	6f 01       	movw	r12, r30
    312c:	0e 94 99 2c 	call	0x5932	; 0x5932 <xTaskGenericNotifyFromISR>
    3130:	e8 85       	ldd	r30, Y+8	; 0x08
    3132:	f9 85       	ldd	r31, Y+9	; 0x09
    3134:	11 86       	std	Z+9, r1	; 0x09
    3136:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    3138:	8e 81       	ldd	r24, Y+6	; 0x06
    313a:	9f 81       	ldd	r25, Y+7	; 0x07
}
    313c:	61 96       	adiw	r28, 0x11	; 17
    313e:	0f b6       	in	r0, 0x3f	; 63
    3140:	f8 94       	cli
    3142:	de bf       	out	0x3e, r29	; 62
    3144:	0f be       	out	0x3f, r0	; 63
    3146:	cd bf       	out	0x3d, r28	; 61
    3148:	cf 91       	pop	r28
    314a:	df 91       	pop	r29
    314c:	1f 91       	pop	r17
    314e:	0f 91       	pop	r16
    3150:	ff 90       	pop	r15
    3152:	ef 90       	pop	r14
    3154:	df 90       	pop	r13
    3156:	cf 90       	pop	r12
    3158:	08 95       	ret

0000315a <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    315a:	0f 93       	push	r16
    315c:	1f 93       	push	r17
    315e:	df 93       	push	r29
    3160:	cf 93       	push	r28
    3162:	cd b7       	in	r28, 0x3d	; 61
    3164:	de b7       	in	r29, 0x3e	; 62
    3166:	62 97       	sbiw	r28, 0x12	; 18
    3168:	0f b6       	in	r0, 0x3f	; 63
    316a:	f8 94       	cli
    316c:	de bf       	out	0x3e, r29	; 62
    316e:	0f be       	out	0x3f, r0	; 63
    3170:	cd bf       	out	0x3d, r28	; 61
    3172:	9e 83       	std	Y+6, r25	; 0x06
    3174:	8d 83       	std	Y+5, r24	; 0x05
    3176:	78 87       	std	Y+8, r23	; 0x08
    3178:	6f 83       	std	Y+7, r22	; 0x07
    317a:	5a 87       	std	Y+10, r21	; 0x0a
    317c:	49 87       	std	Y+9, r20	; 0x09
    317e:	3c 87       	std	Y+12, r19	; 0x0c
    3180:	2b 87       	std	Y+11, r18	; 0x0b
    3182:	1e 87       	std	Y+14, r17	; 0x0e
    3184:	0d 87       	std	Y+13, r16	; 0x0d
    size_t xNextHead = pxStreamBuffer->xHead;
    3186:	ed 81       	ldd	r30, Y+5	; 0x05
    3188:	fe 81       	ldd	r31, Y+6	; 0x06
    318a:	82 81       	ldd	r24, Z+2	; 0x02
    318c:	93 81       	ldd	r25, Z+3	; 0x03
    318e:	9a 83       	std	Y+2, r25	; 0x02
    3190:	89 83       	std	Y+1, r24	; 0x01
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3192:	ed 81       	ldd	r30, Y+5	; 0x05
    3194:	fe 81       	ldd	r31, Y+6	; 0x06
    3196:	86 85       	ldd	r24, Z+14	; 0x0e
    3198:	88 2f       	mov	r24, r24
    319a:	90 e0       	ldi	r25, 0x00	; 0
    319c:	81 70       	andi	r24, 0x01	; 1
    319e:	90 70       	andi	r25, 0x00	; 0
    31a0:	88 23       	and	r24, r24
    31a2:	f1 f0       	breq	.+60     	; 0x31e0 <prvWriteMessageToBuffer+0x86>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    31a4:	89 85       	ldd	r24, Y+9	; 0x09
    31a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    31a8:	9c 83       	std	Y+4, r25	; 0x04
    31aa:	8b 83       	std	Y+3, r24	; 0x03

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    31ac:	2b 85       	ldd	r18, Y+11	; 0x0b
    31ae:	3c 85       	ldd	r19, Y+12	; 0x0c
    31b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    31b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    31b4:	28 17       	cp	r18, r24
    31b6:	39 07       	cpc	r19, r25
    31b8:	80 f0       	brcs	.+32     	; 0x31da <prvWriteMessageToBuffer+0x80>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    31ba:	9e 01       	movw	r18, r28
    31bc:	2d 5f       	subi	r18, 0xFD	; 253
    31be:	3f 4f       	sbci	r19, 0xFF	; 255
    31c0:	8d 81       	ldd	r24, Y+5	; 0x05
    31c2:	9e 81       	ldd	r25, Y+6	; 0x06
    31c4:	e9 81       	ldd	r30, Y+1	; 0x01
    31c6:	fa 81       	ldd	r31, Y+2	; 0x02
    31c8:	b9 01       	movw	r22, r18
    31ca:	42 e0       	ldi	r20, 0x02	; 2
    31cc:	50 e0       	ldi	r21, 0x00	; 0
    31ce:	9f 01       	movw	r18, r30
    31d0:	0e 94 17 1c 	call	0x382e	; 0x382e <prvWriteBytesToBuffer>
    31d4:	9a 83       	std	Y+2, r25	; 0x02
    31d6:	89 83       	std	Y+1, r24	; 0x01
    31d8:	1a c0       	rjmp	.+52     	; 0x320e <prvWriteMessageToBuffer+0xb4>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    31da:	1a 86       	std	Y+10, r1	; 0x0a
    31dc:	19 86       	std	Y+9, r1	; 0x09
    31de:	17 c0       	rjmp	.+46     	; 0x320e <prvWriteMessageToBuffer+0xb4>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    31e0:	29 85       	ldd	r18, Y+9	; 0x09
    31e2:	3a 85       	ldd	r19, Y+10	; 0x0a
    31e4:	3a 8b       	std	Y+18, r19	; 0x12
    31e6:	29 8b       	std	Y+17, r18	; 0x11
    31e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    31ea:	9c 85       	ldd	r25, Y+12	; 0x0c
    31ec:	98 8b       	std	Y+16, r25	; 0x10
    31ee:	8f 87       	std	Y+15, r24	; 0x0f
    31f0:	2f 85       	ldd	r18, Y+15	; 0x0f
    31f2:	38 89       	ldd	r19, Y+16	; 0x10
    31f4:	89 89       	ldd	r24, Y+17	; 0x11
    31f6:	9a 89       	ldd	r25, Y+18	; 0x12
    31f8:	82 17       	cp	r24, r18
    31fa:	93 07       	cpc	r25, r19
    31fc:	20 f4       	brcc	.+8      	; 0x3206 <prvWriteMessageToBuffer+0xac>
    31fe:	29 89       	ldd	r18, Y+17	; 0x11
    3200:	3a 89       	ldd	r19, Y+18	; 0x12
    3202:	38 8b       	std	Y+16, r19	; 0x10
    3204:	2f 87       	std	Y+15, r18	; 0x0f
    3206:	8f 85       	ldd	r24, Y+15	; 0x0f
    3208:	98 89       	ldd	r25, Y+16	; 0x10
    320a:	9a 87       	std	Y+10, r25	; 0x0a
    320c:	89 87       	std	Y+9, r24	; 0x09
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    320e:	89 85       	ldd	r24, Y+9	; 0x09
    3210:	9a 85       	ldd	r25, Y+10	; 0x0a
    3212:	00 97       	sbiw	r24, 0x00	; 0
    3214:	89 f0       	breq	.+34     	; 0x3238 <prvWriteMessageToBuffer+0xde>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    3216:	4f 81       	ldd	r20, Y+7	; 0x07
    3218:	58 85       	ldd	r21, Y+8	; 0x08
    321a:	8d 81       	ldd	r24, Y+5	; 0x05
    321c:	9e 81       	ldd	r25, Y+6	; 0x06
    321e:	29 85       	ldd	r18, Y+9	; 0x09
    3220:	3a 85       	ldd	r19, Y+10	; 0x0a
    3222:	e9 81       	ldd	r30, Y+1	; 0x01
    3224:	fa 81       	ldd	r31, Y+2	; 0x02
    3226:	ba 01       	movw	r22, r20
    3228:	a9 01       	movw	r20, r18
    322a:	9f 01       	movw	r18, r30
    322c:	0e 94 17 1c 	call	0x382e	; 0x382e <prvWriteBytesToBuffer>
    3230:	ed 81       	ldd	r30, Y+5	; 0x05
    3232:	fe 81       	ldd	r31, Y+6	; 0x06
    3234:	93 83       	std	Z+3, r25	; 0x03
    3236:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    3238:	89 85       	ldd	r24, Y+9	; 0x09
    323a:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    323c:	62 96       	adiw	r28, 0x12	; 18
    323e:	0f b6       	in	r0, 0x3f	; 63
    3240:	f8 94       	cli
    3242:	de bf       	out	0x3e, r29	; 62
    3244:	0f be       	out	0x3f, r0	; 63
    3246:	cd bf       	out	0x3d, r28	; 61
    3248:	cf 91       	pop	r28
    324a:	df 91       	pop	r29
    324c:	1f 91       	pop	r17
    324e:	0f 91       	pop	r16
    3250:	08 95       	ret

00003252 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    3252:	cf 92       	push	r12
    3254:	df 92       	push	r13
    3256:	ef 92       	push	r14
    3258:	ff 92       	push	r15
    325a:	0f 93       	push	r16
    325c:	1f 93       	push	r17
    325e:	df 93       	push	r29
    3260:	cf 93       	push	r28
    3262:	cd b7       	in	r28, 0x3d	; 61
    3264:	de b7       	in	r29, 0x3e	; 62
    3266:	60 97       	sbiw	r28, 0x10	; 16
    3268:	0f b6       	in	r0, 0x3f	; 63
    326a:	f8 94       	cli
    326c:	de bf       	out	0x3e, r29	; 62
    326e:	0f be       	out	0x3f, r0	; 63
    3270:	cd bf       	out	0x3d, r28	; 61
    3272:	9a 87       	std	Y+10, r25	; 0x0a
    3274:	89 87       	std	Y+9, r24	; 0x09
    3276:	7c 87       	std	Y+12, r23	; 0x0c
    3278:	6b 87       	std	Y+11, r22	; 0x0b
    327a:	5e 87       	std	Y+14, r21	; 0x0e
    327c:	4d 87       	std	Y+13, r20	; 0x0d
    327e:	38 8b       	std	Y+16, r19	; 0x10
    3280:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3282:	89 85       	ldd	r24, Y+9	; 0x09
    3284:	9a 85       	ldd	r25, Y+10	; 0x0a
    3286:	98 87       	std	Y+8, r25	; 0x08
    3288:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    328a:	1e 82       	std	Y+6, r1	; 0x06
    328c:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    328e:	ef 81       	ldd	r30, Y+7	; 0x07
    3290:	f8 85       	ldd	r31, Y+8	; 0x08
    3292:	86 85       	ldd	r24, Z+14	; 0x0e
    3294:	88 2f       	mov	r24, r24
    3296:	90 e0       	ldi	r25, 0x00	; 0
    3298:	81 70       	andi	r24, 0x01	; 1
    329a:	90 70       	andi	r25, 0x00	; 0
    329c:	88 23       	and	r24, r24
    329e:	29 f0       	breq	.+10     	; 0x32aa <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    32a0:	82 e0       	ldi	r24, 0x02	; 2
    32a2:	90 e0       	ldi	r25, 0x00	; 0
    32a4:	9a 83       	std	Y+2, r25	; 0x02
    32a6:	89 83       	std	Y+1, r24	; 0x01
    32a8:	02 c0       	rjmp	.+4      	; 0x32ae <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    32aa:	1a 82       	std	Y+2, r1	; 0x02
    32ac:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    32ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    32b0:	98 89       	ldd	r25, Y+16	; 0x10
    32b2:	00 97       	sbiw	r24, 0x00	; 0
    32b4:	09 f4       	brne	.+2      	; 0x32b8 <xStreamBufferReceive+0x66>
    32b6:	3f c0       	rjmp	.+126    	; 0x3336 <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    32b8:	0f b6       	in	r0, 0x3f	; 63
    32ba:	f8 94       	cli
    32bc:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    32be:	8f 81       	ldd	r24, Y+7	; 0x07
    32c0:	98 85       	ldd	r25, Y+8	; 0x08
    32c2:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    32c6:	9c 83       	std	Y+4, r25	; 0x04
    32c8:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    32ca:	2b 81       	ldd	r18, Y+3	; 0x03
    32cc:	3c 81       	ldd	r19, Y+4	; 0x04
    32ce:	89 81       	ldd	r24, Y+1	; 0x01
    32d0:	9a 81       	ldd	r25, Y+2	; 0x02
    32d2:	82 17       	cp	r24, r18
    32d4:	93 07       	cpc	r25, r19
    32d6:	58 f0       	brcs	.+22     	; 0x32ee <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    32d8:	80 e0       	ldi	r24, 0x00	; 0
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	60 e0       	ldi	r22, 0x00	; 0
    32de:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    32e2:	0e 94 f5 28 	call	0x51ea	; 0x51ea <xTaskGetCurrentTaskHandle>
    32e6:	ef 81       	ldd	r30, Y+7	; 0x07
    32e8:	f8 85       	ldd	r31, Y+8	; 0x08
    32ea:	91 87       	std	Z+9, r25	; 0x09
    32ec:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    32ee:	0f 90       	pop	r0
    32f0:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    32f2:	2b 81       	ldd	r18, Y+3	; 0x03
    32f4:	3c 81       	ldd	r19, Y+4	; 0x04
    32f6:	89 81       	ldd	r24, Y+1	; 0x01
    32f8:	9a 81       	ldd	r25, Y+2	; 0x02
    32fa:	82 17       	cp	r24, r18
    32fc:	93 07       	cpc	r25, r19
    32fe:	08 f1       	brcs	.+66     	; 0x3342 <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3300:	ef 85       	ldd	r30, Y+15	; 0x0f
    3302:	f8 89       	ldd	r31, Y+16	; 0x10
    3304:	80 e0       	ldi	r24, 0x00	; 0
    3306:	40 e0       	ldi	r20, 0x00	; 0
    3308:	50 e0       	ldi	r21, 0x00	; 0
    330a:	60 e0       	ldi	r22, 0x00	; 0
    330c:	70 e0       	ldi	r23, 0x00	; 0
    330e:	00 e0       	ldi	r16, 0x00	; 0
    3310:	10 e0       	ldi	r17, 0x00	; 0
    3312:	20 e0       	ldi	r18, 0x00	; 0
    3314:	30 e0       	ldi	r19, 0x00	; 0
    3316:	ee 24       	eor	r14, r14
    3318:	ff 24       	eor	r15, r15
    331a:	6f 01       	movw	r12, r30
    331c:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3320:	ef 81       	ldd	r30, Y+7	; 0x07
    3322:	f8 85       	ldd	r31, Y+8	; 0x08
    3324:	11 86       	std	Z+9, r1	; 0x09
    3326:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3328:	8f 81       	ldd	r24, Y+7	; 0x07
    332a:	98 85       	ldd	r25, Y+8	; 0x08
    332c:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    3330:	9c 83       	std	Y+4, r25	; 0x04
    3332:	8b 83       	std	Y+3, r24	; 0x03
    3334:	06 c0       	rjmp	.+12     	; 0x3342 <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3336:	8f 81       	ldd	r24, Y+7	; 0x07
    3338:	98 85       	ldd	r25, Y+8	; 0x08
    333a:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    333e:	9c 83       	std	Y+4, r25	; 0x04
    3340:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    3342:	2b 81       	ldd	r18, Y+3	; 0x03
    3344:	3c 81       	ldd	r19, Y+4	; 0x04
    3346:	89 81       	ldd	r24, Y+1	; 0x01
    3348:	9a 81       	ldd	r25, Y+2	; 0x02
    334a:	82 17       	cp	r24, r18
    334c:	93 07       	cpc	r25, r19
    334e:	70 f5       	brcc	.+92     	; 0x33ac <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    3350:	8f 81       	ldd	r24, Y+7	; 0x07
    3352:	98 85       	ldd	r25, Y+8	; 0x08
    3354:	2b 85       	ldd	r18, Y+11	; 0x0b
    3356:	3c 85       	ldd	r19, Y+12	; 0x0c
    3358:	4d 85       	ldd	r20, Y+13	; 0x0d
    335a:	5e 85       	ldd	r21, Y+14	; 0x0e
    335c:	eb 81       	ldd	r30, Y+3	; 0x03
    335e:	fc 81       	ldd	r31, Y+4	; 0x04
    3360:	b9 01       	movw	r22, r18
    3362:	9f 01       	movw	r18, r30
    3364:	0e 94 a8 1a 	call	0x3550	; 0x3550 <prvReadMessageFromBuffer>
    3368:	9e 83       	std	Y+6, r25	; 0x06
    336a:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    336c:	8d 81       	ldd	r24, Y+5	; 0x05
    336e:	9e 81       	ldd	r25, Y+6	; 0x06
    3370:	00 97       	sbiw	r24, 0x00	; 0
    3372:	e1 f0       	breq	.+56     	; 0x33ac <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    3374:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
    3378:	e9 85       	ldd	r30, Y+9	; 0x09
    337a:	fa 85       	ldd	r31, Y+10	; 0x0a
    337c:	82 85       	ldd	r24, Z+10	; 0x0a
    337e:	93 85       	ldd	r25, Z+11	; 0x0b
    3380:	00 97       	sbiw	r24, 0x00	; 0
    3382:	91 f0       	breq	.+36     	; 0x33a8 <xStreamBufferReceive+0x156>
    3384:	e9 85       	ldd	r30, Y+9	; 0x09
    3386:	fa 85       	ldd	r31, Y+10	; 0x0a
    3388:	82 85       	ldd	r24, Z+10	; 0x0a
    338a:	93 85       	ldd	r25, Z+11	; 0x0b
    338c:	60 e0       	ldi	r22, 0x00	; 0
    338e:	20 e0       	ldi	r18, 0x00	; 0
    3390:	30 e0       	ldi	r19, 0x00	; 0
    3392:	40 e0       	ldi	r20, 0x00	; 0
    3394:	50 e0       	ldi	r21, 0x00	; 0
    3396:	00 e0       	ldi	r16, 0x00	; 0
    3398:	ee 24       	eor	r14, r14
    339a:	ff 24       	eor	r15, r15
    339c:	0e 94 db 2a 	call	0x55b6	; 0x55b6 <xTaskGenericNotify>
    33a0:	e9 85       	ldd	r30, Y+9	; 0x09
    33a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    33a4:	13 86       	std	Z+11, r1	; 0x0b
    33a6:	12 86       	std	Z+10, r1	; 0x0a
    33a8:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    33ac:	8d 81       	ldd	r24, Y+5	; 0x05
    33ae:	9e 81       	ldd	r25, Y+6	; 0x06
}
    33b0:	60 96       	adiw	r28, 0x10	; 16
    33b2:	0f b6       	in	r0, 0x3f	; 63
    33b4:	f8 94       	cli
    33b6:	de bf       	out	0x3e, r29	; 62
    33b8:	0f be       	out	0x3f, r0	; 63
    33ba:	cd bf       	out	0x3d, r28	; 61
    33bc:	cf 91       	pop	r28
    33be:	df 91       	pop	r29
    33c0:	1f 91       	pop	r17
    33c2:	0f 91       	pop	r16
    33c4:	ff 90       	pop	r15
    33c6:	ef 90       	pop	r14
    33c8:	df 90       	pop	r13
    33ca:	cf 90       	pop	r12
    33cc:	08 95       	ret

000033ce <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    33ce:	df 93       	push	r29
    33d0:	cf 93       	push	r28
    33d2:	cd b7       	in	r28, 0x3d	; 61
    33d4:	de b7       	in	r29, 0x3e	; 62
    33d6:	2a 97       	sbiw	r28, 0x0a	; 10
    33d8:	0f b6       	in	r0, 0x3f	; 63
    33da:	f8 94       	cli
    33dc:	de bf       	out	0x3e, r29	; 62
    33de:	0f be       	out	0x3f, r0	; 63
    33e0:	cd bf       	out	0x3d, r28	; 61
    33e2:	9a 87       	std	Y+10, r25	; 0x0a
    33e4:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    33e6:	89 85       	ldd	r24, Y+9	; 0x09
    33e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    33ea:	9e 83       	std	Y+6, r25	; 0x06
    33ec:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    33ee:	ed 81       	ldd	r30, Y+5	; 0x05
    33f0:	fe 81       	ldd	r31, Y+6	; 0x06
    33f2:	86 85       	ldd	r24, Z+14	; 0x0e
    33f4:	88 2f       	mov	r24, r24
    33f6:	90 e0       	ldi	r25, 0x00	; 0
    33f8:	81 70       	andi	r24, 0x01	; 1
    33fa:	90 70       	andi	r25, 0x00	; 0
    33fc:	88 23       	and	r24, r24
    33fe:	19 f1       	breq	.+70     	; 0x3446 <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3400:	8d 81       	ldd	r24, Y+5	; 0x05
    3402:	9e 81       	ldd	r25, Y+6	; 0x06
    3404:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    3408:	9a 83       	std	Y+2, r25	; 0x02
    340a:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    340c:	89 81       	ldd	r24, Y+1	; 0x01
    340e:	9a 81       	ldd	r25, Y+2	; 0x02
    3410:	83 30       	cpi	r24, 0x03	; 3
    3412:	91 05       	cpc	r25, r1
    3414:	a8 f0       	brcs	.+42     	; 0x3440 <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    3416:	9e 01       	movw	r18, r28
    3418:	29 5f       	subi	r18, 0xF9	; 249
    341a:	3f 4f       	sbci	r19, 0xFF	; 255
    341c:	ed 81       	ldd	r30, Y+5	; 0x05
    341e:	fe 81       	ldd	r31, Y+6	; 0x06
    3420:	01 90       	ld	r0, Z+
    3422:	f0 81       	ld	r31, Z
    3424:	e0 2d       	mov	r30, r0
    3426:	8d 81       	ldd	r24, Y+5	; 0x05
    3428:	9e 81       	ldd	r25, Y+6	; 0x06
    342a:	b9 01       	movw	r22, r18
    342c:	42 e0       	ldi	r20, 0x02	; 2
    342e:	50 e0       	ldi	r21, 0x00	; 0
    3430:	9f 01       	movw	r18, r30
    3432:	0e 94 9a 1c 	call	0x3934	; 0x3934 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    3436:	8f 81       	ldd	r24, Y+7	; 0x07
    3438:	98 85       	ldd	r25, Y+8	; 0x08
    343a:	9c 83       	std	Y+4, r25	; 0x04
    343c:	8b 83       	std	Y+3, r24	; 0x03
    343e:	05 c0       	rjmp	.+10     	; 0x344a <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    3440:	1c 82       	std	Y+4, r1	; 0x04
    3442:	1b 82       	std	Y+3, r1	; 0x03
    3444:	02 c0       	rjmp	.+4      	; 0x344a <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    3446:	1c 82       	std	Y+4, r1	; 0x04
    3448:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    344a:	8b 81       	ldd	r24, Y+3	; 0x03
    344c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    344e:	2a 96       	adiw	r28, 0x0a	; 10
    3450:	0f b6       	in	r0, 0x3f	; 63
    3452:	f8 94       	cli
    3454:	de bf       	out	0x3e, r29	; 62
    3456:	0f be       	out	0x3f, r0	; 63
    3458:	cd bf       	out	0x3d, r28	; 61
    345a:	cf 91       	pop	r28
    345c:	df 91       	pop	r29
    345e:	08 95       	ret

00003460 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    3460:	cf 92       	push	r12
    3462:	df 92       	push	r13
    3464:	ef 92       	push	r14
    3466:	ff 92       	push	r15
    3468:	0f 93       	push	r16
    346a:	df 93       	push	r29
    346c:	cf 93       	push	r28
    346e:	cd b7       	in	r28, 0x3d	; 61
    3470:	de b7       	in	r29, 0x3e	; 62
    3472:	61 97       	sbiw	r28, 0x11	; 17
    3474:	0f b6       	in	r0, 0x3f	; 63
    3476:	f8 94       	cli
    3478:	de bf       	out	0x3e, r29	; 62
    347a:	0f be       	out	0x3f, r0	; 63
    347c:	cd bf       	out	0x3d, r28	; 61
    347e:	9b 87       	std	Y+11, r25	; 0x0b
    3480:	8a 87       	std	Y+10, r24	; 0x0a
    3482:	7d 87       	std	Y+13, r23	; 0x0d
    3484:	6c 87       	std	Y+12, r22	; 0x0c
    3486:	5f 87       	std	Y+15, r21	; 0x0f
    3488:	4e 87       	std	Y+14, r20	; 0x0e
    348a:	39 8b       	std	Y+17, r19	; 0x11
    348c:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    348e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3490:	9b 85       	ldd	r25, Y+11	; 0x0b
    3492:	99 87       	std	Y+9, r25	; 0x09
    3494:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3496:	1f 82       	std	Y+7, r1	; 0x07
    3498:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    349a:	e8 85       	ldd	r30, Y+8	; 0x08
    349c:	f9 85       	ldd	r31, Y+9	; 0x09
    349e:	86 85       	ldd	r24, Z+14	; 0x0e
    34a0:	88 2f       	mov	r24, r24
    34a2:	90 e0       	ldi	r25, 0x00	; 0
    34a4:	81 70       	andi	r24, 0x01	; 1
    34a6:	90 70       	andi	r25, 0x00	; 0
    34a8:	88 23       	and	r24, r24
    34aa:	29 f0       	breq	.+10     	; 0x34b6 <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    34ac:	82 e0       	ldi	r24, 0x02	; 2
    34ae:	90 e0       	ldi	r25, 0x00	; 0
    34b0:	9b 83       	std	Y+3, r25	; 0x03
    34b2:	8a 83       	std	Y+2, r24	; 0x02
    34b4:	02 c0       	rjmp	.+4      	; 0x34ba <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    34b6:	1b 82       	std	Y+3, r1	; 0x03
    34b8:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    34ba:	88 85       	ldd	r24, Y+8	; 0x08
    34bc:	99 85       	ldd	r25, Y+9	; 0x09
    34be:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <prvBytesInBuffer>
    34c2:	9d 83       	std	Y+5, r25	; 0x05
    34c4:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    34c6:	2c 81       	ldd	r18, Y+4	; 0x04
    34c8:	3d 81       	ldd	r19, Y+5	; 0x05
    34ca:	8a 81       	ldd	r24, Y+2	; 0x02
    34cc:	9b 81       	ldd	r25, Y+3	; 0x03
    34ce:	82 17       	cp	r24, r18
    34d0:	93 07       	cpc	r25, r19
    34d2:	70 f5       	brcc	.+92     	; 0x3530 <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    34d4:	88 85       	ldd	r24, Y+8	; 0x08
    34d6:	99 85       	ldd	r25, Y+9	; 0x09
    34d8:	2c 85       	ldd	r18, Y+12	; 0x0c
    34da:	3d 85       	ldd	r19, Y+13	; 0x0d
    34dc:	4e 85       	ldd	r20, Y+14	; 0x0e
    34de:	5f 85       	ldd	r21, Y+15	; 0x0f
    34e0:	ec 81       	ldd	r30, Y+4	; 0x04
    34e2:	fd 81       	ldd	r31, Y+5	; 0x05
    34e4:	b9 01       	movw	r22, r18
    34e6:	9f 01       	movw	r18, r30
    34e8:	0e 94 a8 1a 	call	0x3550	; 0x3550 <prvReadMessageFromBuffer>
    34ec:	9f 83       	std	Y+7, r25	; 0x07
    34ee:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    34f0:	8e 81       	ldd	r24, Y+6	; 0x06
    34f2:	9f 81       	ldd	r25, Y+7	; 0x07
    34f4:	00 97       	sbiw	r24, 0x00	; 0
    34f6:	e1 f0       	breq	.+56     	; 0x3530 <xStreamBufferReceiveFromISR+0xd0>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    34f8:	19 82       	std	Y+1, r1	; 0x01
    34fa:	e8 85       	ldd	r30, Y+8	; 0x08
    34fc:	f9 85       	ldd	r31, Y+9	; 0x09
    34fe:	82 85       	ldd	r24, Z+10	; 0x0a
    3500:	93 85       	ldd	r25, Z+11	; 0x0b
    3502:	00 97       	sbiw	r24, 0x00	; 0
    3504:	a9 f0       	breq	.+42     	; 0x3530 <xStreamBufferReceiveFromISR+0xd0>
    3506:	e8 85       	ldd	r30, Y+8	; 0x08
    3508:	f9 85       	ldd	r31, Y+9	; 0x09
    350a:	82 85       	ldd	r24, Z+10	; 0x0a
    350c:	93 85       	ldd	r25, Z+11	; 0x0b
    350e:	e8 89       	ldd	r30, Y+16	; 0x10
    3510:	f9 89       	ldd	r31, Y+17	; 0x11
    3512:	60 e0       	ldi	r22, 0x00	; 0
    3514:	20 e0       	ldi	r18, 0x00	; 0
    3516:	30 e0       	ldi	r19, 0x00	; 0
    3518:	40 e0       	ldi	r20, 0x00	; 0
    351a:	50 e0       	ldi	r21, 0x00	; 0
    351c:	00 e0       	ldi	r16, 0x00	; 0
    351e:	ee 24       	eor	r14, r14
    3520:	ff 24       	eor	r15, r15
    3522:	6f 01       	movw	r12, r30
    3524:	0e 94 99 2c 	call	0x5932	; 0x5932 <xTaskGenericNotifyFromISR>
    3528:	e8 85       	ldd	r30, Y+8	; 0x08
    352a:	f9 85       	ldd	r31, Y+9	; 0x09
    352c:	13 86       	std	Z+11, r1	; 0x0b
    352e:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    3530:	8e 81       	ldd	r24, Y+6	; 0x06
    3532:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3534:	61 96       	adiw	r28, 0x11	; 17
    3536:	0f b6       	in	r0, 0x3f	; 63
    3538:	f8 94       	cli
    353a:	de bf       	out	0x3e, r29	; 62
    353c:	0f be       	out	0x3f, r0	; 63
    353e:	cd bf       	out	0x3d, r28	; 61
    3540:	cf 91       	pop	r28
    3542:	df 91       	pop	r29
    3544:	0f 91       	pop	r16
    3546:	ff 90       	pop	r15
    3548:	ef 90       	pop	r14
    354a:	df 90       	pop	r13
    354c:	cf 90       	pop	r12
    354e:	08 95       	ret

00003550 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    3550:	df 93       	push	r29
    3552:	cf 93       	push	r28
    3554:	cd b7       	in	r28, 0x3d	; 61
    3556:	de b7       	in	r29, 0x3e	; 62
    3558:	64 97       	sbiw	r28, 0x14	; 20
    355a:	0f b6       	in	r0, 0x3f	; 63
    355c:	f8 94       	cli
    355e:	de bf       	out	0x3e, r29	; 62
    3560:	0f be       	out	0x3f, r0	; 63
    3562:	cd bf       	out	0x3d, r28	; 61
    3564:	9a 87       	std	Y+10, r25	; 0x0a
    3566:	89 87       	std	Y+9, r24	; 0x09
    3568:	7c 87       	std	Y+12, r23	; 0x0c
    356a:	6b 87       	std	Y+11, r22	; 0x0b
    356c:	5e 87       	std	Y+14, r21	; 0x0e
    356e:	4d 87       	std	Y+13, r20	; 0x0d
    3570:	38 8b       	std	Y+16, r19	; 0x10
    3572:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    3574:	e9 85       	ldd	r30, Y+9	; 0x09
    3576:	fa 85       	ldd	r31, Y+10	; 0x0a
    3578:	80 81       	ld	r24, Z
    357a:	91 81       	ldd	r25, Z+1	; 0x01
    357c:	9a 83       	std	Y+2, r25	; 0x02
    357e:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3580:	e9 85       	ldd	r30, Y+9	; 0x09
    3582:	fa 85       	ldd	r31, Y+10	; 0x0a
    3584:	86 85       	ldd	r24, Z+14	; 0x0e
    3586:	88 2f       	mov	r24, r24
    3588:	90 e0       	ldi	r25, 0x00	; 0
    358a:	81 70       	andi	r24, 0x01	; 1
    358c:	90 70       	andi	r25, 0x00	; 0
    358e:	88 23       	and	r24, r24
    3590:	11 f1       	breq	.+68     	; 0x35d6 <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    3592:	9e 01       	movw	r18, r28
    3594:	29 5f       	subi	r18, 0xF9	; 249
    3596:	3f 4f       	sbci	r19, 0xFF	; 255
    3598:	89 85       	ldd	r24, Y+9	; 0x09
    359a:	9a 85       	ldd	r25, Y+10	; 0x0a
    359c:	e9 81       	ldd	r30, Y+1	; 0x01
    359e:	fa 81       	ldd	r31, Y+2	; 0x02
    35a0:	b9 01       	movw	r22, r18
    35a2:	42 e0       	ldi	r20, 0x02	; 2
    35a4:	50 e0       	ldi	r21, 0x00	; 0
    35a6:	9f 01       	movw	r18, r30
    35a8:	0e 94 9a 1c 	call	0x3934	; 0x3934 <prvReadBytesFromBuffer>
    35ac:	9a 83       	std	Y+2, r25	; 0x02
    35ae:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    35b0:	8f 81       	ldd	r24, Y+7	; 0x07
    35b2:	98 85       	ldd	r25, Y+8	; 0x08
    35b4:	9c 83       	std	Y+4, r25	; 0x04
    35b6:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    35b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    35ba:	98 89       	ldd	r25, Y+16	; 0x10
    35bc:	02 97       	sbiw	r24, 0x02	; 2
    35be:	98 8b       	std	Y+16, r25	; 0x10
    35c0:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    35c2:	2b 81       	ldd	r18, Y+3	; 0x03
    35c4:	3c 81       	ldd	r19, Y+4	; 0x04
    35c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    35c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    35ca:	82 17       	cp	r24, r18
    35cc:	93 07       	cpc	r25, r19
    35ce:	38 f4       	brcc	.+14     	; 0x35de <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    35d0:	1c 82       	std	Y+4, r1	; 0x04
    35d2:	1b 82       	std	Y+3, r1	; 0x03
    35d4:	04 c0       	rjmp	.+8      	; 0x35de <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    35d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    35d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    35da:	9c 83       	std	Y+4, r25	; 0x04
    35dc:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    35de:	2b 81       	ldd	r18, Y+3	; 0x03
    35e0:	3c 81       	ldd	r19, Y+4	; 0x04
    35e2:	3c 8b       	std	Y+20, r19	; 0x14
    35e4:	2b 8b       	std	Y+19, r18	; 0x13
    35e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    35e8:	98 89       	ldd	r25, Y+16	; 0x10
    35ea:	9a 8b       	std	Y+18, r25	; 0x12
    35ec:	89 8b       	std	Y+17, r24	; 0x11
    35ee:	29 89       	ldd	r18, Y+17	; 0x11
    35f0:	3a 89       	ldd	r19, Y+18	; 0x12
    35f2:	8b 89       	ldd	r24, Y+19	; 0x13
    35f4:	9c 89       	ldd	r25, Y+20	; 0x14
    35f6:	82 17       	cp	r24, r18
    35f8:	93 07       	cpc	r25, r19
    35fa:	20 f4       	brcc	.+8      	; 0x3604 <prvReadMessageFromBuffer+0xb4>
    35fc:	2b 89       	ldd	r18, Y+19	; 0x13
    35fe:	3c 89       	ldd	r19, Y+20	; 0x14
    3600:	3a 8b       	std	Y+18, r19	; 0x12
    3602:	29 8b       	std	Y+17, r18	; 0x11
    3604:	89 89       	ldd	r24, Y+17	; 0x11
    3606:	9a 89       	ldd	r25, Y+18	; 0x12
    3608:	9e 83       	std	Y+6, r25	; 0x06
    360a:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    360c:	8d 81       	ldd	r24, Y+5	; 0x05
    360e:	9e 81       	ldd	r25, Y+6	; 0x06
    3610:	00 97       	sbiw	r24, 0x00	; 0
    3612:	89 f0       	breq	.+34     	; 0x3636 <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    3614:	4b 85       	ldd	r20, Y+11	; 0x0b
    3616:	5c 85       	ldd	r21, Y+12	; 0x0c
    3618:	89 85       	ldd	r24, Y+9	; 0x09
    361a:	9a 85       	ldd	r25, Y+10	; 0x0a
    361c:	2d 81       	ldd	r18, Y+5	; 0x05
    361e:	3e 81       	ldd	r19, Y+6	; 0x06
    3620:	e9 81       	ldd	r30, Y+1	; 0x01
    3622:	fa 81       	ldd	r31, Y+2	; 0x02
    3624:	ba 01       	movw	r22, r20
    3626:	a9 01       	movw	r20, r18
    3628:	9f 01       	movw	r18, r30
    362a:	0e 94 9a 1c 	call	0x3934	; 0x3934 <prvReadBytesFromBuffer>
    362e:	e9 85       	ldd	r30, Y+9	; 0x09
    3630:	fa 85       	ldd	r31, Y+10	; 0x0a
    3632:	91 83       	std	Z+1, r25	; 0x01
    3634:	80 83       	st	Z, r24
    }

    return xCount;
    3636:	8d 81       	ldd	r24, Y+5	; 0x05
    3638:	9e 81       	ldd	r25, Y+6	; 0x06
}
    363a:	64 96       	adiw	r28, 0x14	; 20
    363c:	0f b6       	in	r0, 0x3f	; 63
    363e:	f8 94       	cli
    3640:	de bf       	out	0x3e, r29	; 62
    3642:	0f be       	out	0x3f, r0	; 63
    3644:	cd bf       	out	0x3d, r28	; 61
    3646:	cf 91       	pop	r28
    3648:	df 91       	pop	r29
    364a:	08 95       	ret

0000364c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    364c:	df 93       	push	r29
    364e:	cf 93       	push	r28
    3650:	cd b7       	in	r28, 0x3d	; 61
    3652:	de b7       	in	r29, 0x3e	; 62
    3654:	27 97       	sbiw	r28, 0x07	; 7
    3656:	0f b6       	in	r0, 0x3f	; 63
    3658:	f8 94       	cli
    365a:	de bf       	out	0x3e, r29	; 62
    365c:	0f be       	out	0x3f, r0	; 63
    365e:	cd bf       	out	0x3d, r28	; 61
    3660:	9f 83       	std	Y+7, r25	; 0x07
    3662:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3664:	8e 81       	ldd	r24, Y+6	; 0x06
    3666:	9f 81       	ldd	r25, Y+7	; 0x07
    3668:	9d 83       	std	Y+5, r25	; 0x05
    366a:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    366c:	ec 81       	ldd	r30, Y+4	; 0x04
    366e:	fd 81       	ldd	r31, Y+5	; 0x05
    3670:	80 81       	ld	r24, Z
    3672:	91 81       	ldd	r25, Z+1	; 0x01
    3674:	9a 83       	std	Y+2, r25	; 0x02
    3676:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    3678:	ec 81       	ldd	r30, Y+4	; 0x04
    367a:	fd 81       	ldd	r31, Y+5	; 0x05
    367c:	22 81       	ldd	r18, Z+2	; 0x02
    367e:	33 81       	ldd	r19, Z+3	; 0x03
    3680:	89 81       	ldd	r24, Y+1	; 0x01
    3682:	9a 81       	ldd	r25, Y+2	; 0x02
    3684:	28 17       	cp	r18, r24
    3686:	39 07       	cpc	r19, r25
    3688:	19 f4       	brne	.+6      	; 0x3690 <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    368a:	81 e0       	ldi	r24, 0x01	; 1
    368c:	8b 83       	std	Y+3, r24	; 0x03
    368e:	01 c0       	rjmp	.+2      	; 0x3692 <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    3690:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3692:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3694:	27 96       	adiw	r28, 0x07	; 7
    3696:	0f b6       	in	r0, 0x3f	; 63
    3698:	f8 94       	cli
    369a:	de bf       	out	0x3e, r29	; 62
    369c:	0f be       	out	0x3f, r0	; 63
    369e:	cd bf       	out	0x3d, r28	; 61
    36a0:	cf 91       	pop	r28
    36a2:	df 91       	pop	r29
    36a4:	08 95       	ret

000036a6 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    36a6:	df 93       	push	r29
    36a8:	cf 93       	push	r28
    36aa:	cd b7       	in	r28, 0x3d	; 61
    36ac:	de b7       	in	r29, 0x3e	; 62
    36ae:	27 97       	sbiw	r28, 0x07	; 7
    36b0:	0f b6       	in	r0, 0x3f	; 63
    36b2:	f8 94       	cli
    36b4:	de bf       	out	0x3e, r29	; 62
    36b6:	0f be       	out	0x3f, r0	; 63
    36b8:	cd bf       	out	0x3d, r28	; 61
    36ba:	9f 83       	std	Y+7, r25	; 0x07
    36bc:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    36be:	8e 81       	ldd	r24, Y+6	; 0x06
    36c0:	9f 81       	ldd	r25, Y+7	; 0x07
    36c2:	9a 83       	std	Y+2, r25	; 0x02
    36c4:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    36c6:	e9 81       	ldd	r30, Y+1	; 0x01
    36c8:	fa 81       	ldd	r31, Y+2	; 0x02
    36ca:	86 85       	ldd	r24, Z+14	; 0x0e
    36cc:	88 2f       	mov	r24, r24
    36ce:	90 e0       	ldi	r25, 0x00	; 0
    36d0:	81 70       	andi	r24, 0x01	; 1
    36d2:	90 70       	andi	r25, 0x00	; 0
    36d4:	88 23       	and	r24, r24
    36d6:	29 f0       	breq	.+10     	; 0x36e2 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    36d8:	82 e0       	ldi	r24, 0x02	; 2
    36da:	90 e0       	ldi	r25, 0x00	; 0
    36dc:	9c 83       	std	Y+4, r25	; 0x04
    36de:	8b 83       	std	Y+3, r24	; 0x03
    36e0:	02 c0       	rjmp	.+4      	; 0x36e6 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    36e2:	1c 82       	std	Y+4, r1	; 0x04
    36e4:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    36e6:	8e 81       	ldd	r24, Y+6	; 0x06
    36e8:	9f 81       	ldd	r25, Y+7	; 0x07
    36ea:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <xStreamBufferSpacesAvailable>
    36ee:	9c 01       	movw	r18, r24
    36f0:	8b 81       	ldd	r24, Y+3	; 0x03
    36f2:	9c 81       	ldd	r25, Y+4	; 0x04
    36f4:	82 17       	cp	r24, r18
    36f6:	93 07       	cpc	r25, r19
    36f8:	18 f0       	brcs	.+6      	; 0x3700 <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    36fa:	81 e0       	ldi	r24, 0x01	; 1
    36fc:	8d 83       	std	Y+5, r24	; 0x05
    36fe:	01 c0       	rjmp	.+2      	; 0x3702 <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    3700:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    3702:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3704:	27 96       	adiw	r28, 0x07	; 7
    3706:	0f b6       	in	r0, 0x3f	; 63
    3708:	f8 94       	cli
    370a:	de bf       	out	0x3e, r29	; 62
    370c:	0f be       	out	0x3f, r0	; 63
    370e:	cd bf       	out	0x3d, r28	; 61
    3710:	cf 91       	pop	r28
    3712:	df 91       	pop	r29
    3714:	08 95       	ret

00003716 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    3716:	cf 92       	push	r12
    3718:	df 92       	push	r13
    371a:	ef 92       	push	r14
    371c:	ff 92       	push	r15
    371e:	0f 93       	push	r16
    3720:	df 93       	push	r29
    3722:	cf 93       	push	r28
    3724:	cd b7       	in	r28, 0x3d	; 61
    3726:	de b7       	in	r29, 0x3e	; 62
    3728:	28 97       	sbiw	r28, 0x08	; 8
    372a:	0f b6       	in	r0, 0x3f	; 63
    372c:	f8 94       	cli
    372e:	de bf       	out	0x3e, r29	; 62
    3730:	0f be       	out	0x3f, r0	; 63
    3732:	cd bf       	out	0x3d, r28	; 61
    3734:	9e 83       	std	Y+6, r25	; 0x06
    3736:	8d 83       	std	Y+5, r24	; 0x05
    3738:	78 87       	std	Y+8, r23	; 0x08
    373a:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    373c:	8d 81       	ldd	r24, Y+5	; 0x05
    373e:	9e 81       	ldd	r25, Y+6	; 0x06
    3740:	9c 83       	std	Y+4, r25	; 0x04
    3742:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3744:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    3746:	eb 81       	ldd	r30, Y+3	; 0x03
    3748:	fc 81       	ldd	r31, Y+4	; 0x04
    374a:	80 85       	ldd	r24, Z+8	; 0x08
    374c:	91 85       	ldd	r25, Z+9	; 0x09
    374e:	00 97       	sbiw	r24, 0x00	; 0
    3750:	c1 f0       	breq	.+48     	; 0x3782 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3752:	eb 81       	ldd	r30, Y+3	; 0x03
    3754:	fc 81       	ldd	r31, Y+4	; 0x04
    3756:	80 85       	ldd	r24, Z+8	; 0x08
    3758:	91 85       	ldd	r25, Z+9	; 0x09
    375a:	ef 81       	ldd	r30, Y+7	; 0x07
    375c:	f8 85       	ldd	r31, Y+8	; 0x08
    375e:	60 e0       	ldi	r22, 0x00	; 0
    3760:	20 e0       	ldi	r18, 0x00	; 0
    3762:	30 e0       	ldi	r19, 0x00	; 0
    3764:	40 e0       	ldi	r20, 0x00	; 0
    3766:	50 e0       	ldi	r21, 0x00	; 0
    3768:	00 e0       	ldi	r16, 0x00	; 0
    376a:	ee 24       	eor	r14, r14
    376c:	ff 24       	eor	r15, r15
    376e:	6f 01       	movw	r12, r30
    3770:	0e 94 99 2c 	call	0x5932	; 0x5932 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3774:	eb 81       	ldd	r30, Y+3	; 0x03
    3776:	fc 81       	ldd	r31, Y+4	; 0x04
    3778:	11 86       	std	Z+9, r1	; 0x09
    377a:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    377c:	81 e0       	ldi	r24, 0x01	; 1
    377e:	8a 83       	std	Y+2, r24	; 0x02
    3780:	01 c0       	rjmp	.+2      	; 0x3784 <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    3782:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3784:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3786:	28 96       	adiw	r28, 0x08	; 8
    3788:	0f b6       	in	r0, 0x3f	; 63
    378a:	f8 94       	cli
    378c:	de bf       	out	0x3e, r29	; 62
    378e:	0f be       	out	0x3f, r0	; 63
    3790:	cd bf       	out	0x3d, r28	; 61
    3792:	cf 91       	pop	r28
    3794:	df 91       	pop	r29
    3796:	0f 91       	pop	r16
    3798:	ff 90       	pop	r15
    379a:	ef 90       	pop	r14
    379c:	df 90       	pop	r13
    379e:	cf 90       	pop	r12
    37a0:	08 95       	ret

000037a2 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    37a2:	cf 92       	push	r12
    37a4:	df 92       	push	r13
    37a6:	ef 92       	push	r14
    37a8:	ff 92       	push	r15
    37aa:	0f 93       	push	r16
    37ac:	df 93       	push	r29
    37ae:	cf 93       	push	r28
    37b0:	cd b7       	in	r28, 0x3d	; 61
    37b2:	de b7       	in	r29, 0x3e	; 62
    37b4:	28 97       	sbiw	r28, 0x08	; 8
    37b6:	0f b6       	in	r0, 0x3f	; 63
    37b8:	f8 94       	cli
    37ba:	de bf       	out	0x3e, r29	; 62
    37bc:	0f be       	out	0x3f, r0	; 63
    37be:	cd bf       	out	0x3d, r28	; 61
    37c0:	9e 83       	std	Y+6, r25	; 0x06
    37c2:	8d 83       	std	Y+5, r24	; 0x05
    37c4:	78 87       	std	Y+8, r23	; 0x08
    37c6:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    37c8:	8d 81       	ldd	r24, Y+5	; 0x05
    37ca:	9e 81       	ldd	r25, Y+6	; 0x06
    37cc:	9c 83       	std	Y+4, r25	; 0x04
    37ce:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    37d0:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    37d2:	eb 81       	ldd	r30, Y+3	; 0x03
    37d4:	fc 81       	ldd	r31, Y+4	; 0x04
    37d6:	82 85       	ldd	r24, Z+10	; 0x0a
    37d8:	93 85       	ldd	r25, Z+11	; 0x0b
    37da:	00 97       	sbiw	r24, 0x00	; 0
    37dc:	c1 f0       	breq	.+48     	; 0x380e <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    37de:	eb 81       	ldd	r30, Y+3	; 0x03
    37e0:	fc 81       	ldd	r31, Y+4	; 0x04
    37e2:	82 85       	ldd	r24, Z+10	; 0x0a
    37e4:	93 85       	ldd	r25, Z+11	; 0x0b
    37e6:	ef 81       	ldd	r30, Y+7	; 0x07
    37e8:	f8 85       	ldd	r31, Y+8	; 0x08
    37ea:	60 e0       	ldi	r22, 0x00	; 0
    37ec:	20 e0       	ldi	r18, 0x00	; 0
    37ee:	30 e0       	ldi	r19, 0x00	; 0
    37f0:	40 e0       	ldi	r20, 0x00	; 0
    37f2:	50 e0       	ldi	r21, 0x00	; 0
    37f4:	00 e0       	ldi	r16, 0x00	; 0
    37f6:	ee 24       	eor	r14, r14
    37f8:	ff 24       	eor	r15, r15
    37fa:	6f 01       	movw	r12, r30
    37fc:	0e 94 99 2c 	call	0x5932	; 0x5932 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    3800:	eb 81       	ldd	r30, Y+3	; 0x03
    3802:	fc 81       	ldd	r31, Y+4	; 0x04
    3804:	13 86       	std	Z+11, r1	; 0x0b
    3806:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    3808:	81 e0       	ldi	r24, 0x01	; 1
    380a:	8a 83       	std	Y+2, r24	; 0x02
    380c:	01 c0       	rjmp	.+2      	; 0x3810 <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    380e:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3810:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3812:	28 96       	adiw	r28, 0x08	; 8
    3814:	0f b6       	in	r0, 0x3f	; 63
    3816:	f8 94       	cli
    3818:	de bf       	out	0x3e, r29	; 62
    381a:	0f be       	out	0x3f, r0	; 63
    381c:	cd bf       	out	0x3d, r28	; 61
    381e:	cf 91       	pop	r28
    3820:	df 91       	pop	r29
    3822:	0f 91       	pop	r16
    3824:	ff 90       	pop	r15
    3826:	ef 90       	pop	r14
    3828:	df 90       	pop	r13
    382a:	cf 90       	pop	r12
    382c:	08 95       	ret

0000382e <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    382e:	df 93       	push	r29
    3830:	cf 93       	push	r28
    3832:	cd b7       	in	r28, 0x3d	; 61
    3834:	de b7       	in	r29, 0x3e	; 62
    3836:	2e 97       	sbiw	r28, 0x0e	; 14
    3838:	0f b6       	in	r0, 0x3f	; 63
    383a:	f8 94       	cli
    383c:	de bf       	out	0x3e, r29	; 62
    383e:	0f be       	out	0x3f, r0	; 63
    3840:	cd bf       	out	0x3d, r28	; 61
    3842:	9c 83       	std	Y+4, r25	; 0x04
    3844:	8b 83       	std	Y+3, r24	; 0x03
    3846:	7e 83       	std	Y+6, r23	; 0x06
    3848:	6d 83       	std	Y+5, r22	; 0x05
    384a:	58 87       	std	Y+8, r21	; 0x08
    384c:	4f 83       	std	Y+7, r20	; 0x07
    384e:	3a 87       	std	Y+10, r19	; 0x0a
    3850:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    3852:	eb 81       	ldd	r30, Y+3	; 0x03
    3854:	fc 81       	ldd	r31, Y+4	; 0x04
    3856:	24 81       	ldd	r18, Z+4	; 0x04
    3858:	35 81       	ldd	r19, Z+5	; 0x05
    385a:	89 85       	ldd	r24, Y+9	; 0x09
    385c:	9a 85       	ldd	r25, Y+10	; 0x0a
    385e:	a9 01       	movw	r20, r18
    3860:	48 1b       	sub	r20, r24
    3862:	59 0b       	sbc	r21, r25
    3864:	ca 01       	movw	r24, r20
    3866:	2f 81       	ldd	r18, Y+7	; 0x07
    3868:	38 85       	ldd	r19, Y+8	; 0x08
    386a:	3e 87       	std	Y+14, r19	; 0x0e
    386c:	2d 87       	std	Y+13, r18	; 0x0d
    386e:	9c 87       	std	Y+12, r25	; 0x0c
    3870:	8b 87       	std	Y+11, r24	; 0x0b
    3872:	4b 85       	ldd	r20, Y+11	; 0x0b
    3874:	5c 85       	ldd	r21, Y+12	; 0x0c
    3876:	8d 85       	ldd	r24, Y+13	; 0x0d
    3878:	9e 85       	ldd	r25, Y+14	; 0x0e
    387a:	84 17       	cp	r24, r20
    387c:	95 07       	cpc	r25, r21
    387e:	20 f4       	brcc	.+8      	; 0x3888 <prvWriteBytesToBuffer+0x5a>
    3880:	2d 85       	ldd	r18, Y+13	; 0x0d
    3882:	3e 85       	ldd	r19, Y+14	; 0x0e
    3884:	3c 87       	std	Y+12, r19	; 0x0c
    3886:	2b 87       	std	Y+11, r18	; 0x0b
    3888:	4b 85       	ldd	r20, Y+11	; 0x0b
    388a:	5c 85       	ldd	r21, Y+12	; 0x0c
    388c:	5a 83       	std	Y+2, r21	; 0x02
    388e:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3890:	eb 81       	ldd	r30, Y+3	; 0x03
    3892:	fc 81       	ldd	r31, Y+4	; 0x04
    3894:	24 85       	ldd	r18, Z+12	; 0x0c
    3896:	35 85       	ldd	r19, Z+13	; 0x0d
    3898:	89 85       	ldd	r24, Y+9	; 0x09
    389a:	9a 85       	ldd	r25, Y+10	; 0x0a
    389c:	82 0f       	add	r24, r18
    389e:	93 1f       	adc	r25, r19
    38a0:	2d 81       	ldd	r18, Y+5	; 0x05
    38a2:	3e 81       	ldd	r19, Y+6	; 0x06
    38a4:	49 81       	ldd	r20, Y+1	; 0x01
    38a6:	5a 81       	ldd	r21, Y+2	; 0x02
    38a8:	b9 01       	movw	r22, r18
    38aa:	0e 94 e0 3d 	call	0x7bc0	; 0x7bc0 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    38ae:	2f 81       	ldd	r18, Y+7	; 0x07
    38b0:	38 85       	ldd	r19, Y+8	; 0x08
    38b2:	89 81       	ldd	r24, Y+1	; 0x01
    38b4:	9a 81       	ldd	r25, Y+2	; 0x02
    38b6:	82 17       	cp	r24, r18
    38b8:	93 07       	cpc	r25, r19
    38ba:	b0 f4       	brcc	.+44     	; 0x38e8 <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    38bc:	eb 81       	ldd	r30, Y+3	; 0x03
    38be:	fc 81       	ldd	r31, Y+4	; 0x04
    38c0:	64 85       	ldd	r22, Z+12	; 0x0c
    38c2:	75 85       	ldd	r23, Z+13	; 0x0d
    38c4:	2d 81       	ldd	r18, Y+5	; 0x05
    38c6:	3e 81       	ldd	r19, Y+6	; 0x06
    38c8:	89 81       	ldd	r24, Y+1	; 0x01
    38ca:	9a 81       	ldd	r25, Y+2	; 0x02
    38cc:	a9 01       	movw	r20, r18
    38ce:	48 0f       	add	r20, r24
    38d0:	59 1f       	adc	r21, r25
    38d2:	2f 81       	ldd	r18, Y+7	; 0x07
    38d4:	38 85       	ldd	r19, Y+8	; 0x08
    38d6:	89 81       	ldd	r24, Y+1	; 0x01
    38d8:	9a 81       	ldd	r25, Y+2	; 0x02
    38da:	28 1b       	sub	r18, r24
    38dc:	39 0b       	sbc	r19, r25
    38de:	cb 01       	movw	r24, r22
    38e0:	ba 01       	movw	r22, r20
    38e2:	a9 01       	movw	r20, r18
    38e4:	0e 94 e0 3d 	call	0x7bc0	; 0x7bc0 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    38e8:	29 85       	ldd	r18, Y+9	; 0x09
    38ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    38ec:	8f 81       	ldd	r24, Y+7	; 0x07
    38ee:	98 85       	ldd	r25, Y+8	; 0x08
    38f0:	82 0f       	add	r24, r18
    38f2:	93 1f       	adc	r25, r19
    38f4:	9a 87       	std	Y+10, r25	; 0x0a
    38f6:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    38f8:	eb 81       	ldd	r30, Y+3	; 0x03
    38fa:	fc 81       	ldd	r31, Y+4	; 0x04
    38fc:	24 81       	ldd	r18, Z+4	; 0x04
    38fe:	35 81       	ldd	r19, Z+5	; 0x05
    3900:	89 85       	ldd	r24, Y+9	; 0x09
    3902:	9a 85       	ldd	r25, Y+10	; 0x0a
    3904:	82 17       	cp	r24, r18
    3906:	93 07       	cpc	r25, r19
    3908:	50 f0       	brcs	.+20     	; 0x391e <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    390a:	eb 81       	ldd	r30, Y+3	; 0x03
    390c:	fc 81       	ldd	r31, Y+4	; 0x04
    390e:	24 81       	ldd	r18, Z+4	; 0x04
    3910:	35 81       	ldd	r19, Z+5	; 0x05
    3912:	89 85       	ldd	r24, Y+9	; 0x09
    3914:	9a 85       	ldd	r25, Y+10	; 0x0a
    3916:	82 1b       	sub	r24, r18
    3918:	93 0b       	sbc	r25, r19
    391a:	9a 87       	std	Y+10, r25	; 0x0a
    391c:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    391e:	89 85       	ldd	r24, Y+9	; 0x09
    3920:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    3922:	2e 96       	adiw	r28, 0x0e	; 14
    3924:	0f b6       	in	r0, 0x3f	; 63
    3926:	f8 94       	cli
    3928:	de bf       	out	0x3e, r29	; 62
    392a:	0f be       	out	0x3f, r0	; 63
    392c:	cd bf       	out	0x3d, r28	; 61
    392e:	cf 91       	pop	r28
    3930:	df 91       	pop	r29
    3932:	08 95       	ret

00003934 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    3934:	df 93       	push	r29
    3936:	cf 93       	push	r28
    3938:	cd b7       	in	r28, 0x3d	; 61
    393a:	de b7       	in	r29, 0x3e	; 62
    393c:	2e 97       	sbiw	r28, 0x0e	; 14
    393e:	0f b6       	in	r0, 0x3f	; 63
    3940:	f8 94       	cli
    3942:	de bf       	out	0x3e, r29	; 62
    3944:	0f be       	out	0x3f, r0	; 63
    3946:	cd bf       	out	0x3d, r28	; 61
    3948:	9c 83       	std	Y+4, r25	; 0x04
    394a:	8b 83       	std	Y+3, r24	; 0x03
    394c:	7e 83       	std	Y+6, r23	; 0x06
    394e:	6d 83       	std	Y+5, r22	; 0x05
    3950:	58 87       	std	Y+8, r21	; 0x08
    3952:	4f 83       	std	Y+7, r20	; 0x07
    3954:	3a 87       	std	Y+10, r19	; 0x0a
    3956:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    3958:	eb 81       	ldd	r30, Y+3	; 0x03
    395a:	fc 81       	ldd	r31, Y+4	; 0x04
    395c:	24 81       	ldd	r18, Z+4	; 0x04
    395e:	35 81       	ldd	r19, Z+5	; 0x05
    3960:	89 85       	ldd	r24, Y+9	; 0x09
    3962:	9a 85       	ldd	r25, Y+10	; 0x0a
    3964:	a9 01       	movw	r20, r18
    3966:	48 1b       	sub	r20, r24
    3968:	59 0b       	sbc	r21, r25
    396a:	ca 01       	movw	r24, r20
    396c:	2f 81       	ldd	r18, Y+7	; 0x07
    396e:	38 85       	ldd	r19, Y+8	; 0x08
    3970:	3e 87       	std	Y+14, r19	; 0x0e
    3972:	2d 87       	std	Y+13, r18	; 0x0d
    3974:	9c 87       	std	Y+12, r25	; 0x0c
    3976:	8b 87       	std	Y+11, r24	; 0x0b
    3978:	4b 85       	ldd	r20, Y+11	; 0x0b
    397a:	5c 85       	ldd	r21, Y+12	; 0x0c
    397c:	8d 85       	ldd	r24, Y+13	; 0x0d
    397e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3980:	84 17       	cp	r24, r20
    3982:	95 07       	cpc	r25, r21
    3984:	20 f4       	brcc	.+8      	; 0x398e <prvReadBytesFromBuffer+0x5a>
    3986:	2d 85       	ldd	r18, Y+13	; 0x0d
    3988:	3e 85       	ldd	r19, Y+14	; 0x0e
    398a:	3c 87       	std	Y+12, r19	; 0x0c
    398c:	2b 87       	std	Y+11, r18	; 0x0b
    398e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3990:	5c 85       	ldd	r21, Y+12	; 0x0c
    3992:	5a 83       	std	Y+2, r21	; 0x02
    3994:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3996:	eb 81       	ldd	r30, Y+3	; 0x03
    3998:	fc 81       	ldd	r31, Y+4	; 0x04
    399a:	24 85       	ldd	r18, Z+12	; 0x0c
    399c:	35 85       	ldd	r19, Z+13	; 0x0d
    399e:	89 85       	ldd	r24, Y+9	; 0x09
    39a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    39a2:	a9 01       	movw	r20, r18
    39a4:	48 0f       	add	r20, r24
    39a6:	59 1f       	adc	r21, r25
    39a8:	8d 81       	ldd	r24, Y+5	; 0x05
    39aa:	9e 81       	ldd	r25, Y+6	; 0x06
    39ac:	29 81       	ldd	r18, Y+1	; 0x01
    39ae:	3a 81       	ldd	r19, Y+2	; 0x02
    39b0:	ba 01       	movw	r22, r20
    39b2:	a9 01       	movw	r20, r18
    39b4:	0e 94 e0 3d 	call	0x7bc0	; 0x7bc0 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    39b8:	2f 81       	ldd	r18, Y+7	; 0x07
    39ba:	38 85       	ldd	r19, Y+8	; 0x08
    39bc:	89 81       	ldd	r24, Y+1	; 0x01
    39be:	9a 81       	ldd	r25, Y+2	; 0x02
    39c0:	82 17       	cp	r24, r18
    39c2:	93 07       	cpc	r25, r19
    39c4:	b0 f4       	brcc	.+44     	; 0x39f2 <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    39c6:	2d 81       	ldd	r18, Y+5	; 0x05
    39c8:	3e 81       	ldd	r19, Y+6	; 0x06
    39ca:	89 81       	ldd	r24, Y+1	; 0x01
    39cc:	9a 81       	ldd	r25, Y+2	; 0x02
    39ce:	b9 01       	movw	r22, r18
    39d0:	68 0f       	add	r22, r24
    39d2:	79 1f       	adc	r23, r25
    39d4:	eb 81       	ldd	r30, Y+3	; 0x03
    39d6:	fc 81       	ldd	r31, Y+4	; 0x04
    39d8:	44 85       	ldd	r20, Z+12	; 0x0c
    39da:	55 85       	ldd	r21, Z+13	; 0x0d
    39dc:	2f 81       	ldd	r18, Y+7	; 0x07
    39de:	38 85       	ldd	r19, Y+8	; 0x08
    39e0:	89 81       	ldd	r24, Y+1	; 0x01
    39e2:	9a 81       	ldd	r25, Y+2	; 0x02
    39e4:	28 1b       	sub	r18, r24
    39e6:	39 0b       	sbc	r19, r25
    39e8:	cb 01       	movw	r24, r22
    39ea:	ba 01       	movw	r22, r20
    39ec:	a9 01       	movw	r20, r18
    39ee:	0e 94 e0 3d 	call	0x7bc0	; 0x7bc0 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    39f2:	29 85       	ldd	r18, Y+9	; 0x09
    39f4:	3a 85       	ldd	r19, Y+10	; 0x0a
    39f6:	8f 81       	ldd	r24, Y+7	; 0x07
    39f8:	98 85       	ldd	r25, Y+8	; 0x08
    39fa:	82 0f       	add	r24, r18
    39fc:	93 1f       	adc	r25, r19
    39fe:	9a 87       	std	Y+10, r25	; 0x0a
    3a00:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    3a02:	eb 81       	ldd	r30, Y+3	; 0x03
    3a04:	fc 81       	ldd	r31, Y+4	; 0x04
    3a06:	24 81       	ldd	r18, Z+4	; 0x04
    3a08:	35 81       	ldd	r19, Z+5	; 0x05
    3a0a:	89 85       	ldd	r24, Y+9	; 0x09
    3a0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a0e:	82 17       	cp	r24, r18
    3a10:	93 07       	cpc	r25, r19
    3a12:	50 f0       	brcs	.+20     	; 0x3a28 <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    3a14:	eb 81       	ldd	r30, Y+3	; 0x03
    3a16:	fc 81       	ldd	r31, Y+4	; 0x04
    3a18:	24 81       	ldd	r18, Z+4	; 0x04
    3a1a:	35 81       	ldd	r19, Z+5	; 0x05
    3a1c:	89 85       	ldd	r24, Y+9	; 0x09
    3a1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a20:	82 1b       	sub	r24, r18
    3a22:	93 0b       	sbc	r25, r19
    3a24:	9a 87       	std	Y+10, r25	; 0x0a
    3a26:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    3a28:	89 85       	ldd	r24, Y+9	; 0x09
    3a2a:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    3a2c:	2e 96       	adiw	r28, 0x0e	; 14
    3a2e:	0f b6       	in	r0, 0x3f	; 63
    3a30:	f8 94       	cli
    3a32:	de bf       	out	0x3e, r29	; 62
    3a34:	0f be       	out	0x3f, r0	; 63
    3a36:	cd bf       	out	0x3d, r28	; 61
    3a38:	cf 91       	pop	r28
    3a3a:	df 91       	pop	r29
    3a3c:	08 95       	ret

00003a3e <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3a3e:	df 93       	push	r29
    3a40:	cf 93       	push	r28
    3a42:	00 d0       	rcall	.+0      	; 0x3a44 <prvBytesInBuffer+0x6>
    3a44:	00 d0       	rcall	.+0      	; 0x3a46 <prvBytesInBuffer+0x8>
    3a46:	cd b7       	in	r28, 0x3d	; 61
    3a48:	de b7       	in	r29, 0x3e	; 62
    3a4a:	9c 83       	std	Y+4, r25	; 0x04
    3a4c:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3a4e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a50:	fc 81       	ldd	r31, Y+4	; 0x04
    3a52:	24 81       	ldd	r18, Z+4	; 0x04
    3a54:	35 81       	ldd	r19, Z+5	; 0x05
    3a56:	eb 81       	ldd	r30, Y+3	; 0x03
    3a58:	fc 81       	ldd	r31, Y+4	; 0x04
    3a5a:	82 81       	ldd	r24, Z+2	; 0x02
    3a5c:	93 81       	ldd	r25, Z+3	; 0x03
    3a5e:	82 0f       	add	r24, r18
    3a60:	93 1f       	adc	r25, r19
    3a62:	9a 83       	std	Y+2, r25	; 0x02
    3a64:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    3a66:	eb 81       	ldd	r30, Y+3	; 0x03
    3a68:	fc 81       	ldd	r31, Y+4	; 0x04
    3a6a:	20 81       	ld	r18, Z
    3a6c:	31 81       	ldd	r19, Z+1	; 0x01
    3a6e:	89 81       	ldd	r24, Y+1	; 0x01
    3a70:	9a 81       	ldd	r25, Y+2	; 0x02
    3a72:	82 1b       	sub	r24, r18
    3a74:	93 0b       	sbc	r25, r19
    3a76:	9a 83       	std	Y+2, r25	; 0x02
    3a78:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    3a7a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a7c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a7e:	24 81       	ldd	r18, Z+4	; 0x04
    3a80:	35 81       	ldd	r19, Z+5	; 0x05
    3a82:	89 81       	ldd	r24, Y+1	; 0x01
    3a84:	9a 81       	ldd	r25, Y+2	; 0x02
    3a86:	82 17       	cp	r24, r18
    3a88:	93 07       	cpc	r25, r19
    3a8a:	50 f0       	brcs	.+20     	; 0x3aa0 <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    3a8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a90:	24 81       	ldd	r18, Z+4	; 0x04
    3a92:	35 81       	ldd	r19, Z+5	; 0x05
    3a94:	89 81       	ldd	r24, Y+1	; 0x01
    3a96:	9a 81       	ldd	r25, Y+2	; 0x02
    3a98:	82 1b       	sub	r24, r18
    3a9a:	93 0b       	sbc	r25, r19
    3a9c:	9a 83       	std	Y+2, r25	; 0x02
    3a9e:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    3aa0:	89 81       	ldd	r24, Y+1	; 0x01
    3aa2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3aa4:	0f 90       	pop	r0
    3aa6:	0f 90       	pop	r0
    3aa8:	0f 90       	pop	r0
    3aaa:	0f 90       	pop	r0
    3aac:	cf 91       	pop	r28
    3aae:	df 91       	pop	r29
    3ab0:	08 95       	ret

00003ab2 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
    3ab2:	cf 92       	push	r12
    3ab4:	df 92       	push	r13
    3ab6:	ef 92       	push	r14
    3ab8:	ff 92       	push	r15
    3aba:	0f 93       	push	r16
    3abc:	df 93       	push	r29
    3abe:	cf 93       	push	r28
    3ac0:	cd b7       	in	r28, 0x3d	; 61
    3ac2:	de b7       	in	r29, 0x3e	; 62
    3ac4:	2d 97       	sbiw	r28, 0x0d	; 13
    3ac6:	0f b6       	in	r0, 0x3f	; 63
    3ac8:	f8 94       	cli
    3aca:	de bf       	out	0x3e, r29	; 62
    3acc:	0f be       	out	0x3f, r0	; 63
    3ace:	cd bf       	out	0x3d, r28	; 61
    3ad0:	9a 83       	std	Y+2, r25	; 0x02
    3ad2:	89 83       	std	Y+1, r24	; 0x01
    3ad4:	7c 83       	std	Y+4, r23	; 0x04
    3ad6:	6b 83       	std	Y+3, r22	; 0x03
    3ad8:	5e 83       	std	Y+6, r21	; 0x06
    3ada:	4d 83       	std	Y+5, r20	; 0x05
    3adc:	38 87       	std	Y+8, r19	; 0x08
    3ade:	2f 83       	std	Y+7, r18	; 0x07
    3ae0:	09 87       	std	Y+9, r16	; 0x09
    3ae2:	fb 86       	std	Y+11, r15	; 0x0b
    3ae4:	ea 86       	std	Y+10, r14	; 0x0a
    3ae6:	dd 86       	std	Y+13, r13	; 0x0d
    3ae8:	cc 86       	std	Y+12, r12	; 0x0c
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3aea:	89 81       	ldd	r24, Y+1	; 0x01
    3aec:	9a 81       	ldd	r25, Y+2	; 0x02
    3aee:	60 e0       	ldi	r22, 0x00	; 0
    3af0:	70 e0       	ldi	r23, 0x00	; 0
    3af2:	4f e0       	ldi	r20, 0x0F	; 15
    3af4:	50 e0       	ldi	r21, 0x00	; 0
    3af6:	0e 94 e9 3d 	call	0x7bd2	; 0x7bd2 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    3afa:	e9 81       	ldd	r30, Y+1	; 0x01
    3afc:	fa 81       	ldd	r31, Y+2	; 0x02
    3afe:	8b 81       	ldd	r24, Y+3	; 0x03
    3b00:	9c 81       	ldd	r25, Y+4	; 0x04
    3b02:	95 87       	std	Z+13, r25	; 0x0d
    3b04:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    3b06:	e9 81       	ldd	r30, Y+1	; 0x01
    3b08:	fa 81       	ldd	r31, Y+2	; 0x02
    3b0a:	8d 81       	ldd	r24, Y+5	; 0x05
    3b0c:	9e 81       	ldd	r25, Y+6	; 0x06
    3b0e:	95 83       	std	Z+5, r25	; 0x05
    3b10:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3b12:	e9 81       	ldd	r30, Y+1	; 0x01
    3b14:	fa 81       	ldd	r31, Y+2	; 0x02
    3b16:	8f 81       	ldd	r24, Y+7	; 0x07
    3b18:	98 85       	ldd	r25, Y+8	; 0x08
    3b1a:	97 83       	std	Z+7, r25	; 0x07
    3b1c:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    3b1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3b20:	fa 81       	ldd	r31, Y+2	; 0x02
    3b22:	89 85       	ldd	r24, Y+9	; 0x09
    3b24:	86 87       	std	Z+14, r24	; 0x0e
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
    3b26:	2d 96       	adiw	r28, 0x0d	; 13
    3b28:	0f b6       	in	r0, 0x3f	; 63
    3b2a:	f8 94       	cli
    3b2c:	de bf       	out	0x3e, r29	; 62
    3b2e:	0f be       	out	0x3f, r0	; 63
    3b30:	cd bf       	out	0x3d, r28	; 61
    3b32:	cf 91       	pop	r28
    3b34:	df 91       	pop	r29
    3b36:	0f 91       	pop	r16
    3b38:	ff 90       	pop	r15
    3b3a:	ef 90       	pop	r14
    3b3c:	df 90       	pop	r13
    3b3e:	cf 90       	pop	r12
    3b40:	08 95       	ret

00003b42 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    3b42:	8f 92       	push	r8
    3b44:	9f 92       	push	r9
    3b46:	af 92       	push	r10
    3b48:	bf 92       	push	r11
    3b4a:	cf 92       	push	r12
    3b4c:	df 92       	push	r13
    3b4e:	ef 92       	push	r14
    3b50:	ff 92       	push	r15
    3b52:	0f 93       	push	r16
    3b54:	1f 93       	push	r17
    3b56:	df 93       	push	r29
    3b58:	cf 93       	push	r28
    3b5a:	cd b7       	in	r28, 0x3d	; 61
    3b5c:	de b7       	in	r29, 0x3e	; 62
    3b5e:	60 97       	sbiw	r28, 0x10	; 16
    3b60:	0f b6       	in	r0, 0x3f	; 63
    3b62:	f8 94       	cli
    3b64:	de bf       	out	0x3e, r29	; 62
    3b66:	0f be       	out	0x3f, r0	; 63
    3b68:	cd bf       	out	0x3d, r28	; 61
    3b6a:	9f 83       	std	Y+7, r25	; 0x07
    3b6c:	8e 83       	std	Y+6, r24	; 0x06
    3b6e:	79 87       	std	Y+9, r23	; 0x09
    3b70:	68 87       	std	Y+8, r22	; 0x08
    3b72:	5b 87       	std	Y+11, r21	; 0x0b
    3b74:	4a 87       	std	Y+10, r20	; 0x0a
    3b76:	3d 87       	std	Y+13, r19	; 0x0d
    3b78:	2c 87       	std	Y+12, r18	; 0x0c
    3b7a:	0e 87       	std	Y+14, r16	; 0x0e
    3b7c:	f8 8a       	std	Y+16, r15	; 0x10
    3b7e:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3b80:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b82:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b84:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    3b88:	9a 83       	std	Y+2, r25	; 0x02
    3b8a:	89 83       	std	Y+1, r24	; 0x01

            if( pxStack != NULL )
    3b8c:	89 81       	ldd	r24, Y+1	; 0x01
    3b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b90:	00 97       	sbiw	r24, 0x00	; 0
    3b92:	f1 f0       	breq	.+60     	; 0x3bd0 <xTaskCreate+0x8e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3b94:	86 e2       	ldi	r24, 0x26	; 38
    3b96:	90 e0       	ldi	r25, 0x00	; 0
    3b98:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    3b9c:	9d 83       	std	Y+5, r25	; 0x05
    3b9e:	8c 83       	std	Y+4, r24	; 0x04

                if( pxNewTCB != NULL )
    3ba0:	8c 81       	ldd	r24, Y+4	; 0x04
    3ba2:	9d 81       	ldd	r25, Y+5	; 0x05
    3ba4:	00 97       	sbiw	r24, 0x00	; 0
    3ba6:	79 f0       	breq	.+30     	; 0x3bc6 <xTaskCreate+0x84>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    3ba8:	8c 81       	ldd	r24, Y+4	; 0x04
    3baa:	9d 81       	ldd	r25, Y+5	; 0x05
    3bac:	60 e0       	ldi	r22, 0x00	; 0
    3bae:	70 e0       	ldi	r23, 0x00	; 0
    3bb0:	46 e2       	ldi	r20, 0x26	; 38
    3bb2:	50 e0       	ldi	r21, 0x00	; 0
    3bb4:	0e 94 e9 3d 	call	0x7bd2	; 0x7bd2 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    3bb8:	ec 81       	ldd	r30, Y+4	; 0x04
    3bba:	fd 81       	ldd	r31, Y+5	; 0x05
    3bbc:	89 81       	ldd	r24, Y+1	; 0x01
    3bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc0:	90 8f       	std	Z+24, r25	; 0x18
    3bc2:	87 8b       	std	Z+23, r24	; 0x17
    3bc4:	07 c0       	rjmp	.+14     	; 0x3bd4 <xTaskCreate+0x92>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    3bc6:	89 81       	ldd	r24, Y+1	; 0x01
    3bc8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bca:	0e 94 a9 06 	call	0xd52	; 0xd52 <vPortFree>
    3bce:	02 c0       	rjmp	.+4      	; 0x3bd4 <xTaskCreate+0x92>
                }
            }
            else
            {
                pxNewTCB = NULL;
    3bd0:	1d 82       	std	Y+5, r1	; 0x05
    3bd2:	1c 82       	std	Y+4, r1	; 0x04
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    3bd4:	8c 81       	ldd	r24, Y+4	; 0x04
    3bd6:	9d 81       	ldd	r25, Y+5	; 0x05
    3bd8:	00 97       	sbiw	r24, 0x00	; 0
    3bda:	e9 f0       	breq	.+58     	; 0x3c16 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3bdc:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bde:	9b 85       	ldd	r25, Y+11	; 0x0b
    3be0:	9c 01       	movw	r18, r24
    3be2:	40 e0       	ldi	r20, 0x00	; 0
    3be4:	50 e0       	ldi	r21, 0x00	; 0
    3be6:	8e 81       	ldd	r24, Y+6	; 0x06
    3be8:	9f 81       	ldd	r25, Y+7	; 0x07
    3bea:	68 85       	ldd	r22, Y+8	; 0x08
    3bec:	79 85       	ldd	r23, Y+9	; 0x09
    3bee:	ec 85       	ldd	r30, Y+12	; 0x0c
    3bf0:	fd 85       	ldd	r31, Y+13	; 0x0d
    3bf2:	af 85       	ldd	r26, Y+15	; 0x0f
    3bf4:	b8 89       	ldd	r27, Y+16	; 0x10
    3bf6:	ac 80       	ldd	r10, Y+4	; 0x04
    3bf8:	bd 80       	ldd	r11, Y+5	; 0x05
    3bfa:	8f 01       	movw	r16, r30
    3bfc:	ee 84       	ldd	r14, Y+14	; 0x0e
    3bfe:	6d 01       	movw	r12, r26
    3c00:	88 24       	eor	r8, r8
    3c02:	99 24       	eor	r9, r9
    3c04:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3c08:	8c 81       	ldd	r24, Y+4	; 0x04
    3c0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3c0c:	0e 94 d0 1e 	call	0x3da0	; 0x3da0 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    3c10:	81 e0       	ldi	r24, 0x01	; 1
    3c12:	8b 83       	std	Y+3, r24	; 0x03
    3c14:	02 c0       	rjmp	.+4      	; 0x3c1a <xTaskCreate+0xd8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3c16:	8f ef       	ldi	r24, 0xFF	; 255
    3c18:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    3c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3c1c:	60 96       	adiw	r28, 0x10	; 16
    3c1e:	0f b6       	in	r0, 0x3f	; 63
    3c20:	f8 94       	cli
    3c22:	de bf       	out	0x3e, r29	; 62
    3c24:	0f be       	out	0x3f, r0	; 63
    3c26:	cd bf       	out	0x3d, r28	; 61
    3c28:	cf 91       	pop	r28
    3c2a:	df 91       	pop	r29
    3c2c:	1f 91       	pop	r17
    3c2e:	0f 91       	pop	r16
    3c30:	ff 90       	pop	r15
    3c32:	ef 90       	pop	r14
    3c34:	df 90       	pop	r13
    3c36:	cf 90       	pop	r12
    3c38:	bf 90       	pop	r11
    3c3a:	af 90       	pop	r10
    3c3c:	9f 90       	pop	r9
    3c3e:	8f 90       	pop	r8
    3c40:	08 95       	ret

00003c42 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    3c42:	8f 92       	push	r8
    3c44:	9f 92       	push	r9
    3c46:	af 92       	push	r10
    3c48:	bf 92       	push	r11
    3c4a:	cf 92       	push	r12
    3c4c:	df 92       	push	r13
    3c4e:	ef 92       	push	r14
    3c50:	0f 93       	push	r16
    3c52:	1f 93       	push	r17
    3c54:	df 93       	push	r29
    3c56:	cf 93       	push	r28
    3c58:	cd b7       	in	r28, 0x3d	; 61
    3c5a:	de b7       	in	r29, 0x3e	; 62
    3c5c:	64 97       	sbiw	r28, 0x14	; 20
    3c5e:	0f b6       	in	r0, 0x3f	; 63
    3c60:	f8 94       	cli
    3c62:	de bf       	out	0x3e, r29	; 62
    3c64:	0f be       	out	0x3f, r0	; 63
    3c66:	cd bf       	out	0x3d, r28	; 61
    3c68:	9d 83       	std	Y+5, r25	; 0x05
    3c6a:	8c 83       	std	Y+4, r24	; 0x04
    3c6c:	7f 83       	std	Y+7, r23	; 0x07
    3c6e:	6e 83       	std	Y+6, r22	; 0x06
    3c70:	28 87       	std	Y+8, r18	; 0x08
    3c72:	39 87       	std	Y+9, r19	; 0x09
    3c74:	4a 87       	std	Y+10, r20	; 0x0a
    3c76:	5b 87       	std	Y+11, r21	; 0x0b
    3c78:	1d 87       	std	Y+13, r17	; 0x0d
    3c7a:	0c 87       	std	Y+12, r16	; 0x0c
    3c7c:	ee 86       	std	Y+14, r14	; 0x0e
    3c7e:	d8 8a       	std	Y+16, r13	; 0x10
    3c80:	cf 86       	std	Y+15, r12	; 0x0f
    3c82:	ba 8a       	std	Y+18, r11	; 0x12
    3c84:	a9 8a       	std	Y+17, r10	; 0x11
    3c86:	9c 8a       	std	Y+20, r9	; 0x14
    3c88:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3c8a:	e9 89       	ldd	r30, Y+17	; 0x11
    3c8c:	fa 89       	ldd	r31, Y+18	; 0x12
    3c8e:	27 89       	ldd	r18, Z+23	; 0x17
    3c90:	30 8d       	ldd	r19, Z+24	; 0x18
    3c92:	88 85       	ldd	r24, Y+8	; 0x08
    3c94:	99 85       	ldd	r25, Y+9	; 0x09
    3c96:	01 97       	sbiw	r24, 0x01	; 1
    3c98:	82 0f       	add	r24, r18
    3c9a:	93 1f       	adc	r25, r19
    3c9c:	9b 83       	std	Y+3, r25	; 0x03
    3c9e:	8a 83       	std	Y+2, r24	; 0x02
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3ca0:	8e 81       	ldd	r24, Y+6	; 0x06
    3ca2:	9f 81       	ldd	r25, Y+7	; 0x07
    3ca4:	00 97       	sbiw	r24, 0x00	; 0
    3ca6:	49 f1       	breq	.+82     	; 0x3cfa <prvInitialiseNewTask+0xb8>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3ca8:	19 82       	std	Y+1, r1	; 0x01
    3caa:	21 c0       	rjmp	.+66     	; 0x3cee <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3cac:	89 81       	ldd	r24, Y+1	; 0x01
    3cae:	48 2f       	mov	r20, r24
    3cb0:	50 e0       	ldi	r21, 0x00	; 0
    3cb2:	89 81       	ldd	r24, Y+1	; 0x01
    3cb4:	28 2f       	mov	r18, r24
    3cb6:	30 e0       	ldi	r19, 0x00	; 0
    3cb8:	8e 81       	ldd	r24, Y+6	; 0x06
    3cba:	9f 81       	ldd	r25, Y+7	; 0x07
    3cbc:	fc 01       	movw	r30, r24
    3cbe:	e2 0f       	add	r30, r18
    3cc0:	f3 1f       	adc	r31, r19
    3cc2:	20 81       	ld	r18, Z
    3cc4:	89 89       	ldd	r24, Y+17	; 0x11
    3cc6:	9a 89       	ldd	r25, Y+18	; 0x12
    3cc8:	84 0f       	add	r24, r20
    3cca:	95 1f       	adc	r25, r21
    3ccc:	fc 01       	movw	r30, r24
    3cce:	79 96       	adiw	r30, 0x19	; 25
    3cd0:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    3cd2:	89 81       	ldd	r24, Y+1	; 0x01
    3cd4:	28 2f       	mov	r18, r24
    3cd6:	30 e0       	ldi	r19, 0x00	; 0
    3cd8:	8e 81       	ldd	r24, Y+6	; 0x06
    3cda:	9f 81       	ldd	r25, Y+7	; 0x07
    3cdc:	fc 01       	movw	r30, r24
    3cde:	e2 0f       	add	r30, r18
    3ce0:	f3 1f       	adc	r31, r19
    3ce2:	80 81       	ld	r24, Z
    3ce4:	88 23       	and	r24, r24
    3ce6:	31 f0       	breq	.+12     	; 0x3cf4 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3ce8:	89 81       	ldd	r24, Y+1	; 0x01
    3cea:	8f 5f       	subi	r24, 0xFF	; 255
    3cec:	89 83       	std	Y+1, r24	; 0x01
    3cee:	89 81       	ldd	r24, Y+1	; 0x01
    3cf0:	88 30       	cpi	r24, 0x08	; 8
    3cf2:	e0 f2       	brcs	.-72     	; 0x3cac <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3cf4:	e9 89       	ldd	r30, Y+17	; 0x11
    3cf6:	fa 89       	ldd	r31, Y+18	; 0x12
    3cf8:	10 a2       	std	Z+32, r1	; 0x20
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3cfa:	8e 85       	ldd	r24, Y+14	; 0x0e
    3cfc:	84 30       	cpi	r24, 0x04	; 4
    3cfe:	10 f0       	brcs	.+4      	; 0x3d04 <prvInitialiseNewTask+0xc2>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3d00:	83 e0       	ldi	r24, 0x03	; 3
    3d02:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3d04:	e9 89       	ldd	r30, Y+17	; 0x11
    3d06:	fa 89       	ldd	r31, Y+18	; 0x12
    3d08:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d0a:	86 8b       	std	Z+22, r24	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3d0c:	89 89       	ldd	r24, Y+17	; 0x11
    3d0e:	9a 89       	ldd	r25, Y+18	; 0x12
    3d10:	02 96       	adiw	r24, 0x02	; 2
    3d12:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3d16:	89 89       	ldd	r24, Y+17	; 0x11
    3d18:	9a 89       	ldd	r25, Y+18	; 0x12
    3d1a:	0c 96       	adiw	r24, 0x0c	; 12
    3d1c:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3d20:	e9 89       	ldd	r30, Y+17	; 0x11
    3d22:	fa 89       	ldd	r31, Y+18	; 0x12
    3d24:	89 89       	ldd	r24, Y+17	; 0x11
    3d26:	9a 89       	ldd	r25, Y+18	; 0x12
    3d28:	91 87       	std	Z+9, r25	; 0x09
    3d2a:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3d2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d2e:	28 2f       	mov	r18, r24
    3d30:	30 e0       	ldi	r19, 0x00	; 0
    3d32:	84 e0       	ldi	r24, 0x04	; 4
    3d34:	90 e0       	ldi	r25, 0x00	; 0
    3d36:	82 1b       	sub	r24, r18
    3d38:	93 0b       	sbc	r25, r19
    3d3a:	e9 89       	ldd	r30, Y+17	; 0x11
    3d3c:	fa 89       	ldd	r31, Y+18	; 0x12
    3d3e:	95 87       	std	Z+13, r25	; 0x0d
    3d40:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3d42:	e9 89       	ldd	r30, Y+17	; 0x11
    3d44:	fa 89       	ldd	r31, Y+18	; 0x12
    3d46:	89 89       	ldd	r24, Y+17	; 0x11
    3d48:	9a 89       	ldd	r25, Y+18	; 0x12
    3d4a:	93 8b       	std	Z+19, r25	; 0x13
    3d4c:	82 8b       	std	Z+18, r24	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d50:	9b 81       	ldd	r25, Y+3	; 0x03
    3d52:	2c 81       	ldd	r18, Y+4	; 0x04
    3d54:	3d 81       	ldd	r19, Y+5	; 0x05
    3d56:	4c 85       	ldd	r20, Y+12	; 0x0c
    3d58:	5d 85       	ldd	r21, Y+13	; 0x0d
    3d5a:	b9 01       	movw	r22, r18
    3d5c:	0e 94 cf 06 	call	0xd9e	; 0xd9e <pxPortInitialiseStack>
    3d60:	e9 89       	ldd	r30, Y+17	; 0x11
    3d62:	fa 89       	ldd	r31, Y+18	; 0x12
    3d64:	91 83       	std	Z+1, r25	; 0x01
    3d66:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    3d68:	8f 85       	ldd	r24, Y+15	; 0x0f
    3d6a:	98 89       	ldd	r25, Y+16	; 0x10
    3d6c:	00 97       	sbiw	r24, 0x00	; 0
    3d6e:	31 f0       	breq	.+12     	; 0x3d7c <prvInitialiseNewTask+0x13a>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3d70:	ef 85       	ldd	r30, Y+15	; 0x0f
    3d72:	f8 89       	ldd	r31, Y+16	; 0x10
    3d74:	89 89       	ldd	r24, Y+17	; 0x11
    3d76:	9a 89       	ldd	r25, Y+18	; 0x12
    3d78:	91 83       	std	Z+1, r25	; 0x01
    3d7a:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3d7c:	64 96       	adiw	r28, 0x14	; 20
    3d7e:	0f b6       	in	r0, 0x3f	; 63
    3d80:	f8 94       	cli
    3d82:	de bf       	out	0x3e, r29	; 62
    3d84:	0f be       	out	0x3f, r0	; 63
    3d86:	cd bf       	out	0x3d, r28	; 61
    3d88:	cf 91       	pop	r28
    3d8a:	df 91       	pop	r29
    3d8c:	1f 91       	pop	r17
    3d8e:	0f 91       	pop	r16
    3d90:	ef 90       	pop	r14
    3d92:	df 90       	pop	r13
    3d94:	cf 90       	pop	r12
    3d96:	bf 90       	pop	r11
    3d98:	af 90       	pop	r10
    3d9a:	9f 90       	pop	r9
    3d9c:	8f 90       	pop	r8
    3d9e:	08 95       	ret

00003da0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3da0:	df 93       	push	r29
    3da2:	cf 93       	push	r28
    3da4:	00 d0       	rcall	.+0      	; 0x3da6 <prvAddNewTaskToReadyList+0x6>
    3da6:	00 d0       	rcall	.+0      	; 0x3da8 <prvAddNewTaskToReadyList+0x8>
    3da8:	cd b7       	in	r28, 0x3d	; 61
    3daa:	de b7       	in	r29, 0x3e	; 62
    3dac:	9c 83       	std	Y+4, r25	; 0x04
    3dae:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3db0:	0f b6       	in	r0, 0x3f	; 63
    3db2:	f8 94       	cli
    3db4:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    3db6:	80 91 51 06 	lds	r24, 0x0651
    3dba:	8f 5f       	subi	r24, 0xFF	; 255
    3dbc:	80 93 51 06 	sts	0x0651, r24

        if( pxCurrentTCB == NULL )
    3dc0:	80 91 4e 06 	lds	r24, 0x064E
    3dc4:	90 91 4f 06 	lds	r25, 0x064F
    3dc8:	00 97       	sbiw	r24, 0x00	; 0
    3dca:	69 f4       	brne	.+26     	; 0x3de6 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3dcc:	8b 81       	ldd	r24, Y+3	; 0x03
    3dce:	9c 81       	ldd	r25, Y+4	; 0x04
    3dd0:	90 93 4f 06 	sts	0x064F, r25
    3dd4:	80 93 4e 06 	sts	0x064E, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3dd8:	80 91 51 06 	lds	r24, 0x0651
    3ddc:	81 30       	cpi	r24, 0x01	; 1
    3dde:	b9 f4       	brne	.+46     	; 0x3e0e <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    3de0:	0e 94 51 28 	call	0x50a2	; 0x50a2 <prvInitialiseTaskLists>
    3de4:	14 c0       	rjmp	.+40     	; 0x3e0e <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    3de6:	80 91 55 06 	lds	r24, 0x0655
    3dea:	88 23       	and	r24, r24
    3dec:	81 f4       	brne	.+32     	; 0x3e0e <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3dee:	e0 91 4e 06 	lds	r30, 0x064E
    3df2:	f0 91 4f 06 	lds	r31, 0x064F
    3df6:	96 89       	ldd	r25, Z+22	; 0x16
    3df8:	eb 81       	ldd	r30, Y+3	; 0x03
    3dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    3dfc:	86 89       	ldd	r24, Z+22	; 0x16
    3dfe:	89 17       	cp	r24, r25
    3e00:	30 f0       	brcs	.+12     	; 0x3e0e <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    3e02:	8b 81       	ldd	r24, Y+3	; 0x03
    3e04:	9c 81       	ldd	r25, Y+4	; 0x04
    3e06:	90 93 4f 06 	sts	0x064F, r25
    3e0a:	80 93 4e 06 	sts	0x064E, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3e0e:	80 91 5a 06 	lds	r24, 0x065A
    3e12:	8f 5f       	subi	r24, 0xFF	; 255
    3e14:	80 93 5a 06 	sts	0x065A, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3e18:	eb 81       	ldd	r30, Y+3	; 0x03
    3e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e1c:	96 89       	ldd	r25, Z+22	; 0x16
    3e1e:	80 91 54 06 	lds	r24, 0x0654
    3e22:	89 17       	cp	r24, r25
    3e24:	28 f4       	brcc	.+10     	; 0x3e30 <prvAddNewTaskToReadyList+0x90>
    3e26:	eb 81       	ldd	r30, Y+3	; 0x03
    3e28:	fc 81       	ldd	r31, Y+4	; 0x04
    3e2a:	86 89       	ldd	r24, Z+22	; 0x16
    3e2c:	80 93 54 06 	sts	0x0654, r24
    3e30:	eb 81       	ldd	r30, Y+3	; 0x03
    3e32:	fc 81       	ldd	r31, Y+4	; 0x04
    3e34:	86 89       	ldd	r24, Z+22	; 0x16
    3e36:	28 2f       	mov	r18, r24
    3e38:	30 e0       	ldi	r19, 0x00	; 0
    3e3a:	c9 01       	movw	r24, r18
    3e3c:	88 0f       	add	r24, r24
    3e3e:	99 1f       	adc	r25, r25
    3e40:	88 0f       	add	r24, r24
    3e42:	99 1f       	adc	r25, r25
    3e44:	88 0f       	add	r24, r24
    3e46:	99 1f       	adc	r25, r25
    3e48:	82 0f       	add	r24, r18
    3e4a:	93 1f       	adc	r25, r19
    3e4c:	fc 01       	movw	r30, r24
    3e4e:	e0 5a       	subi	r30, 0xA0	; 160
    3e50:	f9 4f       	sbci	r31, 0xF9	; 249
    3e52:	81 81       	ldd	r24, Z+1	; 0x01
    3e54:	92 81       	ldd	r25, Z+2	; 0x02
    3e56:	9a 83       	std	Y+2, r25	; 0x02
    3e58:	89 83       	std	Y+1, r24	; 0x01
    3e5a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e5c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e5e:	89 81       	ldd	r24, Y+1	; 0x01
    3e60:	9a 81       	ldd	r25, Y+2	; 0x02
    3e62:	95 83       	std	Z+5, r25	; 0x05
    3e64:	84 83       	std	Z+4, r24	; 0x04
    3e66:	e9 81       	ldd	r30, Y+1	; 0x01
    3e68:	fa 81       	ldd	r31, Y+2	; 0x02
    3e6a:	84 81       	ldd	r24, Z+4	; 0x04
    3e6c:	95 81       	ldd	r25, Z+5	; 0x05
    3e6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e70:	fc 81       	ldd	r31, Y+4	; 0x04
    3e72:	97 83       	std	Z+7, r25	; 0x07
    3e74:	86 83       	std	Z+6, r24	; 0x06
    3e76:	e9 81       	ldd	r30, Y+1	; 0x01
    3e78:	fa 81       	ldd	r31, Y+2	; 0x02
    3e7a:	04 80       	ldd	r0, Z+4	; 0x04
    3e7c:	f5 81       	ldd	r31, Z+5	; 0x05
    3e7e:	e0 2d       	mov	r30, r0
    3e80:	8b 81       	ldd	r24, Y+3	; 0x03
    3e82:	9c 81       	ldd	r25, Y+4	; 0x04
    3e84:	02 96       	adiw	r24, 0x02	; 2
    3e86:	93 83       	std	Z+3, r25	; 0x03
    3e88:	82 83       	std	Z+2, r24	; 0x02
    3e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e8e:	02 96       	adiw	r24, 0x02	; 2
    3e90:	e9 81       	ldd	r30, Y+1	; 0x01
    3e92:	fa 81       	ldd	r31, Y+2	; 0x02
    3e94:	95 83       	std	Z+5, r25	; 0x05
    3e96:	84 83       	std	Z+4, r24	; 0x04
    3e98:	eb 81       	ldd	r30, Y+3	; 0x03
    3e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e9c:	86 89       	ldd	r24, Z+22	; 0x16
    3e9e:	28 2f       	mov	r18, r24
    3ea0:	30 e0       	ldi	r19, 0x00	; 0
    3ea2:	c9 01       	movw	r24, r18
    3ea4:	88 0f       	add	r24, r24
    3ea6:	99 1f       	adc	r25, r25
    3ea8:	88 0f       	add	r24, r24
    3eaa:	99 1f       	adc	r25, r25
    3eac:	88 0f       	add	r24, r24
    3eae:	99 1f       	adc	r25, r25
    3eb0:	82 0f       	add	r24, r18
    3eb2:	93 1f       	adc	r25, r19
    3eb4:	80 5a       	subi	r24, 0xA0	; 160
    3eb6:	99 4f       	sbci	r25, 0xF9	; 249
    3eb8:	eb 81       	ldd	r30, Y+3	; 0x03
    3eba:	fc 81       	ldd	r31, Y+4	; 0x04
    3ebc:	93 87       	std	Z+11, r25	; 0x0b
    3ebe:	82 87       	std	Z+10, r24	; 0x0a
    3ec0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec4:	86 89       	ldd	r24, Z+22	; 0x16
    3ec6:	28 2f       	mov	r18, r24
    3ec8:	30 e0       	ldi	r19, 0x00	; 0
    3eca:	c9 01       	movw	r24, r18
    3ecc:	88 0f       	add	r24, r24
    3ece:	99 1f       	adc	r25, r25
    3ed0:	88 0f       	add	r24, r24
    3ed2:	99 1f       	adc	r25, r25
    3ed4:	88 0f       	add	r24, r24
    3ed6:	99 1f       	adc	r25, r25
    3ed8:	82 0f       	add	r24, r18
    3eda:	93 1f       	adc	r25, r19
    3edc:	fc 01       	movw	r30, r24
    3ede:	e0 5a       	subi	r30, 0xA0	; 160
    3ee0:	f9 4f       	sbci	r31, 0xF9	; 249
    3ee2:	80 81       	ld	r24, Z
    3ee4:	8f 5f       	subi	r24, 0xFF	; 255
    3ee6:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3ee8:	0f 90       	pop	r0
    3eea:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3eec:	80 91 55 06 	lds	r24, 0x0655
    3ef0:	88 23       	and	r24, r24
    3ef2:	61 f0       	breq	.+24     	; 0x3f0c <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3ef4:	e0 91 4e 06 	lds	r30, 0x064E
    3ef8:	f0 91 4f 06 	lds	r31, 0x064F
    3efc:	96 89       	ldd	r25, Z+22	; 0x16
    3efe:	eb 81       	ldd	r30, Y+3	; 0x03
    3f00:	fc 81       	ldd	r31, Y+4	; 0x04
    3f02:	86 89       	ldd	r24, Z+22	; 0x16
    3f04:	98 17       	cp	r25, r24
    3f06:	10 f4       	brcc	.+4      	; 0x3f0c <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3f08:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3f0c:	0f 90       	pop	r0
    3f0e:	0f 90       	pop	r0
    3f10:	0f 90       	pop	r0
    3f12:	0f 90       	pop	r0
    3f14:	cf 91       	pop	r28
    3f16:	df 91       	pop	r29
    3f18:	08 95       	ret

00003f1a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    3f1a:	df 93       	push	r29
    3f1c:	cf 93       	push	r28
    3f1e:	00 d0       	rcall	.+0      	; 0x3f20 <vTaskDelete+0x6>
    3f20:	00 d0       	rcall	.+0      	; 0x3f22 <vTaskDelete+0x8>
    3f22:	00 d0       	rcall	.+0      	; 0x3f24 <vTaskDelete+0xa>
    3f24:	cd b7       	in	r28, 0x3d	; 61
    3f26:	de b7       	in	r29, 0x3e	; 62
    3f28:	9c 83       	std	Y+4, r25	; 0x04
    3f2a:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3f2c:	0f b6       	in	r0, 0x3f	; 63
    3f2e:	f8 94       	cli
    3f30:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3f32:	8b 81       	ldd	r24, Y+3	; 0x03
    3f34:	9c 81       	ldd	r25, Y+4	; 0x04
    3f36:	00 97       	sbiw	r24, 0x00	; 0
    3f38:	39 f4       	brne	.+14     	; 0x3f48 <vTaskDelete+0x2e>
    3f3a:	80 91 4e 06 	lds	r24, 0x064E
    3f3e:	90 91 4f 06 	lds	r25, 0x064F
    3f42:	9e 83       	std	Y+6, r25	; 0x06
    3f44:	8d 83       	std	Y+5, r24	; 0x05
    3f46:	04 c0       	rjmp	.+8      	; 0x3f50 <vTaskDelete+0x36>
    3f48:	8b 81       	ldd	r24, Y+3	; 0x03
    3f4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f4c:	9e 83       	std	Y+6, r25	; 0x06
    3f4e:	8d 83       	std	Y+5, r24	; 0x05
    3f50:	8d 81       	ldd	r24, Y+5	; 0x05
    3f52:	9e 81       	ldd	r25, Y+6	; 0x06
    3f54:	9a 83       	std	Y+2, r25	; 0x02
    3f56:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3f58:	89 81       	ldd	r24, Y+1	; 0x01
    3f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5c:	02 96       	adiw	r24, 0x02	; 2
    3f5e:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3f62:	e9 81       	ldd	r30, Y+1	; 0x01
    3f64:	fa 81       	ldd	r31, Y+2	; 0x02
    3f66:	84 89       	ldd	r24, Z+20	; 0x14
    3f68:	95 89       	ldd	r25, Z+21	; 0x15
    3f6a:	00 97       	sbiw	r24, 0x00	; 0
    3f6c:	29 f0       	breq	.+10     	; 0x3f78 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3f6e:	89 81       	ldd	r24, Y+1	; 0x01
    3f70:	9a 81       	ldd	r25, Y+2	; 0x02
    3f72:	0c 96       	adiw	r24, 0x0c	; 12
    3f74:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3f78:	80 91 5a 06 	lds	r24, 0x065A
    3f7c:	8f 5f       	subi	r24, 0xFF	; 255
    3f7e:	80 93 5a 06 	sts	0x065A, r24

            if( pxTCB == pxCurrentTCB )
    3f82:	20 91 4e 06 	lds	r18, 0x064E
    3f86:	30 91 4f 06 	lds	r19, 0x064F
    3f8a:	89 81       	ldd	r24, Y+1	; 0x01
    3f8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f8e:	82 17       	cp	r24, r18
    3f90:	93 07       	cpc	r25, r19
    3f92:	81 f4       	brne	.+32     	; 0x3fb4 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3f94:	89 81       	ldd	r24, Y+1	; 0x01
    3f96:	9a 81       	ldd	r25, Y+2	; 0x02
    3f98:	9c 01       	movw	r18, r24
    3f9a:	2e 5f       	subi	r18, 0xFE	; 254
    3f9c:	3f 4f       	sbci	r19, 0xFF	; 255
    3f9e:	83 ea       	ldi	r24, 0xA3	; 163
    3fa0:	96 e0       	ldi	r25, 0x06	; 6
    3fa2:	b9 01       	movw	r22, r18
    3fa4:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3fa8:	80 91 50 06 	lds	r24, 0x0650
    3fac:	8f 5f       	subi	r24, 0xFF	; 255
    3fae:	80 93 50 06 	sts	0x0650, r24
    3fb2:	07 c0       	rjmp	.+14     	; 0x3fc2 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3fb4:	80 91 51 06 	lds	r24, 0x0651
    3fb8:	81 50       	subi	r24, 0x01	; 1
    3fba:	80 93 51 06 	sts	0x0651, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    3fbe:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3fc2:	0f 90       	pop	r0
    3fc4:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3fc6:	20 91 4e 06 	lds	r18, 0x064E
    3fca:	30 91 4f 06 	lds	r19, 0x064F
    3fce:	89 81       	ldd	r24, Y+1	; 0x01
    3fd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd2:	82 17       	cp	r24, r18
    3fd4:	93 07       	cpc	r25, r19
    3fd6:	21 f0       	breq	.+8      	; 0x3fe0 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3fd8:	89 81       	ldd	r24, Y+1	; 0x01
    3fda:	9a 81       	ldd	r25, Y+2	; 0x02
    3fdc:	0e 94 bd 28 	call	0x517a	; 0x517a <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    3fe0:	80 91 55 06 	lds	r24, 0x0655
    3fe4:	88 23       	and	r24, r24
    3fe6:	59 f0       	breq	.+22     	; 0x3ffe <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3fe8:	20 91 4e 06 	lds	r18, 0x064E
    3fec:	30 91 4f 06 	lds	r19, 0x064F
    3ff0:	89 81       	ldd	r24, Y+1	; 0x01
    3ff2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff4:	82 17       	cp	r24, r18
    3ff6:	93 07       	cpc	r25, r19
    3ff8:	11 f4       	brne	.+4      	; 0x3ffe <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3ffa:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3ffe:	26 96       	adiw	r28, 0x06	; 6
    4000:	0f b6       	in	r0, 0x3f	; 63
    4002:	f8 94       	cli
    4004:	de bf       	out	0x3e, r29	; 62
    4006:	0f be       	out	0x3f, r0	; 63
    4008:	cd bf       	out	0x3d, r28	; 61
    400a:	cf 91       	pop	r28
    400c:	df 91       	pop	r29
    400e:	08 95       	ret

00004010 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    4010:	df 93       	push	r29
    4012:	cf 93       	push	r28
    4014:	cd b7       	in	r28, 0x3d	; 61
    4016:	de b7       	in	r29, 0x3e	; 62
    4018:	2a 97       	sbiw	r28, 0x0a	; 10
    401a:	0f b6       	in	r0, 0x3f	; 63
    401c:	f8 94       	cli
    401e:	de bf       	out	0x3e, r29	; 62
    4020:	0f be       	out	0x3f, r0	; 63
    4022:	cd bf       	out	0x3d, r28	; 61
    4024:	98 87       	std	Y+8, r25	; 0x08
    4026:	8f 83       	std	Y+7, r24	; 0x07
    4028:	7a 87       	std	Y+10, r23	; 0x0a
    402a:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    402c:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    402e:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    4032:	80 91 52 06 	lds	r24, 0x0652
    4036:	90 91 53 06 	lds	r25, 0x0653
    403a:	9a 83       	std	Y+2, r25	; 0x02
    403c:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    403e:	ef 81       	ldd	r30, Y+7	; 0x07
    4040:	f8 85       	ldd	r31, Y+8	; 0x08
    4042:	20 81       	ld	r18, Z
    4044:	31 81       	ldd	r19, Z+1	; 0x01
    4046:	89 85       	ldd	r24, Y+9	; 0x09
    4048:	9a 85       	ldd	r25, Y+10	; 0x0a
    404a:	82 0f       	add	r24, r18
    404c:	93 1f       	adc	r25, r19
    404e:	9e 83       	std	Y+6, r25	; 0x06
    4050:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    4052:	ef 81       	ldd	r30, Y+7	; 0x07
    4054:	f8 85       	ldd	r31, Y+8	; 0x08
    4056:	20 81       	ld	r18, Z
    4058:	31 81       	ldd	r19, Z+1	; 0x01
    405a:	89 81       	ldd	r24, Y+1	; 0x01
    405c:	9a 81       	ldd	r25, Y+2	; 0x02
    405e:	82 17       	cp	r24, r18
    4060:	93 07       	cpc	r25, r19
    4062:	98 f4       	brcc	.+38     	; 0x408a <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    4064:	ef 81       	ldd	r30, Y+7	; 0x07
    4066:	f8 85       	ldd	r31, Y+8	; 0x08
    4068:	20 81       	ld	r18, Z
    406a:	31 81       	ldd	r19, Z+1	; 0x01
    406c:	8d 81       	ldd	r24, Y+5	; 0x05
    406e:	9e 81       	ldd	r25, Y+6	; 0x06
    4070:	82 17       	cp	r24, r18
    4072:	93 07       	cpc	r25, r19
    4074:	e0 f4       	brcc	.+56     	; 0x40ae <xTaskDelayUntil+0x9e>
    4076:	2d 81       	ldd	r18, Y+5	; 0x05
    4078:	3e 81       	ldd	r19, Y+6	; 0x06
    407a:	89 81       	ldd	r24, Y+1	; 0x01
    407c:	9a 81       	ldd	r25, Y+2	; 0x02
    407e:	82 17       	cp	r24, r18
    4080:	93 07       	cpc	r25, r19
    4082:	a8 f4       	brcc	.+42     	; 0x40ae <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    4084:	81 e0       	ldi	r24, 0x01	; 1
    4086:	8b 83       	std	Y+3, r24	; 0x03
    4088:	12 c0       	rjmp	.+36     	; 0x40ae <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    408a:	ef 81       	ldd	r30, Y+7	; 0x07
    408c:	f8 85       	ldd	r31, Y+8	; 0x08
    408e:	20 81       	ld	r18, Z
    4090:	31 81       	ldd	r19, Z+1	; 0x01
    4092:	8d 81       	ldd	r24, Y+5	; 0x05
    4094:	9e 81       	ldd	r25, Y+6	; 0x06
    4096:	82 17       	cp	r24, r18
    4098:	93 07       	cpc	r25, r19
    409a:	38 f0       	brcs	.+14     	; 0x40aa <xTaskDelayUntil+0x9a>
    409c:	2d 81       	ldd	r18, Y+5	; 0x05
    409e:	3e 81       	ldd	r19, Y+6	; 0x06
    40a0:	89 81       	ldd	r24, Y+1	; 0x01
    40a2:	9a 81       	ldd	r25, Y+2	; 0x02
    40a4:	82 17       	cp	r24, r18
    40a6:	93 07       	cpc	r25, r19
    40a8:	10 f4       	brcc	.+4      	; 0x40ae <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    40aa:	81 e0       	ldi	r24, 0x01	; 1
    40ac:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    40ae:	ef 81       	ldd	r30, Y+7	; 0x07
    40b0:	f8 85       	ldd	r31, Y+8	; 0x08
    40b2:	8d 81       	ldd	r24, Y+5	; 0x05
    40b4:	9e 81       	ldd	r25, Y+6	; 0x06
    40b6:	91 83       	std	Z+1, r25	; 0x01
    40b8:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    40ba:	8b 81       	ldd	r24, Y+3	; 0x03
    40bc:	88 23       	and	r24, r24
    40be:	49 f0       	breq	.+18     	; 0x40d2 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    40c0:	8d 81       	ldd	r24, Y+5	; 0x05
    40c2:	9e 81       	ldd	r25, Y+6	; 0x06
    40c4:	29 81       	ldd	r18, Y+1	; 0x01
    40c6:	3a 81       	ldd	r19, Y+2	; 0x02
    40c8:	82 1b       	sub	r24, r18
    40ca:	93 0b       	sbc	r25, r19
    40cc:	60 e0       	ldi	r22, 0x00	; 0
    40ce:	0e 94 b3 30 	call	0x6166	; 0x6166 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    40d2:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    40d6:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    40d8:	8c 81       	ldd	r24, Y+4	; 0x04
    40da:	88 23       	and	r24, r24
    40dc:	11 f4       	brne	.+4      	; 0x40e2 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    40de:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    40e2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    40e4:	2a 96       	adiw	r28, 0x0a	; 10
    40e6:	0f b6       	in	r0, 0x3f	; 63
    40e8:	f8 94       	cli
    40ea:	de bf       	out	0x3e, r29	; 62
    40ec:	0f be       	out	0x3f, r0	; 63
    40ee:	cd bf       	out	0x3d, r28	; 61
    40f0:	cf 91       	pop	r28
    40f2:	df 91       	pop	r29
    40f4:	08 95       	ret

000040f6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    40f6:	df 93       	push	r29
    40f8:	cf 93       	push	r28
    40fa:	00 d0       	rcall	.+0      	; 0x40fc <vTaskDelay+0x6>
    40fc:	0f 92       	push	r0
    40fe:	cd b7       	in	r28, 0x3d	; 61
    4100:	de b7       	in	r29, 0x3e	; 62
    4102:	9b 83       	std	Y+3, r25	; 0x03
    4104:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    4106:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    4108:	8a 81       	ldd	r24, Y+2	; 0x02
    410a:	9b 81       	ldd	r25, Y+3	; 0x03
    410c:	00 97       	sbiw	r24, 0x00	; 0
    410e:	51 f0       	breq	.+20     	; 0x4124 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    4110:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4114:	8a 81       	ldd	r24, Y+2	; 0x02
    4116:	9b 81       	ldd	r25, Y+3	; 0x03
    4118:	60 e0       	ldi	r22, 0x00	; 0
    411a:	0e 94 b3 30 	call	0x6166	; 0x6166 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    411e:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    4122:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4124:	89 81       	ldd	r24, Y+1	; 0x01
    4126:	88 23       	and	r24, r24
    4128:	11 f4       	brne	.+4      	; 0x412e <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    412a:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    412e:	0f 90       	pop	r0
    4130:	0f 90       	pop	r0
    4132:	0f 90       	pop	r0
    4134:	cf 91       	pop	r28
    4136:	df 91       	pop	r29
    4138:	08 95       	ret

0000413a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    413a:	ef 92       	push	r14
    413c:	ff 92       	push	r15
    413e:	0f 93       	push	r16
    4140:	df 93       	push	r29
    4142:	cf 93       	push	r28
    4144:	00 d0       	rcall	.+0      	; 0x4146 <vTaskStartScheduler+0xc>
    4146:	cd b7       	in	r28, 0x3d	; 61
    4148:	de b7       	in	r29, 0x3e	; 62
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    414a:	81 e4       	ldi	r24, 0x41	; 65
    414c:	98 e2       	ldi	r25, 0x28	; 40
    414e:	20 e6       	ldi	r18, 0x60	; 96
    4150:	30 e0       	ldi	r19, 0x00	; 0
    4152:	ed e5       	ldi	r30, 0x5D	; 93
    4154:	f6 e0       	ldi	r31, 0x06	; 6
    4156:	b9 01       	movw	r22, r18
    4158:	45 e5       	ldi	r20, 0x55	; 85
    415a:	50 e0       	ldi	r21, 0x00	; 0
    415c:	20 e0       	ldi	r18, 0x00	; 0
    415e:	30 e0       	ldi	r19, 0x00	; 0
    4160:	00 e0       	ldi	r16, 0x00	; 0
    4162:	7f 01       	movw	r14, r30
    4164:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <xTaskCreate>
    4168:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    416a:	89 81       	ldd	r24, Y+1	; 0x01
    416c:	81 30       	cpi	r24, 0x01	; 1
    416e:	81 f4       	brne	.+32     	; 0x4190 <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    4170:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    4172:	8f ef       	ldi	r24, 0xFF	; 255
    4174:	9f ef       	ldi	r25, 0xFF	; 255
    4176:	90 93 5c 06 	sts	0x065C, r25
    417a:	80 93 5b 06 	sts	0x065B, r24
        xSchedulerRunning = pdTRUE;
    417e:	81 e0       	ldi	r24, 0x01	; 1
    4180:	80 93 55 06 	sts	0x0655, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4184:	10 92 53 06 	sts	0x0653, r1
    4188:	10 92 52 06 	sts	0x0652, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    418c:	0e 94 52 08 	call	0x10a4	; 0x10a4 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    4190:	80 91 6d 00 	lds	r24, 0x006D
}
    4194:	0f 90       	pop	r0
    4196:	0f 90       	pop	r0
    4198:	cf 91       	pop	r28
    419a:	df 91       	pop	r29
    419c:	0f 91       	pop	r16
    419e:	ff 90       	pop	r15
    41a0:	ef 90       	pop	r14
    41a2:	08 95       	ret

000041a4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    41a4:	df 93       	push	r29
    41a6:	cf 93       	push	r28
    41a8:	cd b7       	in	r28, 0x3d	; 61
    41aa:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    41ac:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    41ae:	10 92 55 06 	sts	0x0655, r1
    vPortEndScheduler();
    41b2:	0e 94 87 08 	call	0x110e	; 0x110e <vPortEndScheduler>
}
    41b6:	cf 91       	pop	r28
    41b8:	df 91       	pop	r29
    41ba:	08 95       	ret

000041bc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    41bc:	df 93       	push	r29
    41be:	cf 93       	push	r28
    41c0:	cd b7       	in	r28, 0x3d	; 61
    41c2:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    41c4:	80 91 5f 06 	lds	r24, 0x065F
    41c8:	8f 5f       	subi	r24, 0xFF	; 255
    41ca:	80 93 5f 06 	sts	0x065F, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    41ce:	cf 91       	pop	r28
    41d0:	df 91       	pop	r29
    41d2:	08 95       	ret

000041d4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    41d4:	df 93       	push	r29
    41d6:	cf 93       	push	r28
    41d8:	cd b7       	in	r28, 0x3d	; 61
    41da:	de b7       	in	r29, 0x3e	; 62
    41dc:	2b 97       	sbiw	r28, 0x0b	; 11
    41de:	0f b6       	in	r0, 0x3f	; 63
    41e0:	f8 94       	cli
    41e2:	de bf       	out	0x3e, r29	; 62
    41e4:	0f be       	out	0x3f, r0	; 63
    41e6:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    41e8:	1b 86       	std	Y+11, r1	; 0x0b
    41ea:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    41ec:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    41ee:	0f b6       	in	r0, 0x3f	; 63
    41f0:	f8 94       	cli
    41f2:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    41f4:	80 91 5f 06 	lds	r24, 0x065F
    41f8:	81 50       	subi	r24, 0x01	; 1
    41fa:	80 93 5f 06 	sts	0x065F, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    41fe:	80 91 5f 06 	lds	r24, 0x065F
    4202:	88 23       	and	r24, r24
    4204:	09 f0       	breq	.+2      	; 0x4208 <xTaskResumeAll+0x34>
    4206:	2a c1       	rjmp	.+596    	; 0x445c <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4208:	80 91 51 06 	lds	r24, 0x0651
    420c:	88 23       	and	r24, r24
    420e:	09 f4       	brne	.+2      	; 0x4212 <xTaskResumeAll+0x3e>
    4210:	25 c1       	rjmp	.+586    	; 0x445c <xTaskResumeAll+0x288>
    4212:	f3 c0       	rjmp	.+486    	; 0x43fa <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4214:	e0 91 9f 06 	lds	r30, 0x069F
    4218:	f0 91 a0 06 	lds	r31, 0x06A0
    421c:	86 81       	ldd	r24, Z+6	; 0x06
    421e:	97 81       	ldd	r25, Z+7	; 0x07
    4220:	9b 87       	std	Y+11, r25	; 0x0b
    4222:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    4224:	ea 85       	ldd	r30, Y+10	; 0x0a
    4226:	fb 85       	ldd	r31, Y+11	; 0x0b
    4228:	84 89       	ldd	r24, Z+20	; 0x14
    422a:	95 89       	ldd	r25, Z+21	; 0x15
    422c:	98 87       	std	Y+8, r25	; 0x08
    422e:	8f 83       	std	Y+7, r24	; 0x07
    4230:	ea 85       	ldd	r30, Y+10	; 0x0a
    4232:	fb 85       	ldd	r31, Y+11	; 0x0b
    4234:	a6 85       	ldd	r26, Z+14	; 0x0e
    4236:	b7 85       	ldd	r27, Z+15	; 0x0f
    4238:	ea 85       	ldd	r30, Y+10	; 0x0a
    423a:	fb 85       	ldd	r31, Y+11	; 0x0b
    423c:	80 89       	ldd	r24, Z+16	; 0x10
    423e:	91 89       	ldd	r25, Z+17	; 0x11
    4240:	15 96       	adiw	r26, 0x05	; 5
    4242:	9c 93       	st	X, r25
    4244:	8e 93       	st	-X, r24
    4246:	14 97       	sbiw	r26, 0x04	; 4
    4248:	ea 85       	ldd	r30, Y+10	; 0x0a
    424a:	fb 85       	ldd	r31, Y+11	; 0x0b
    424c:	a0 89       	ldd	r26, Z+16	; 0x10
    424e:	b1 89       	ldd	r27, Z+17	; 0x11
    4250:	ea 85       	ldd	r30, Y+10	; 0x0a
    4252:	fb 85       	ldd	r31, Y+11	; 0x0b
    4254:	86 85       	ldd	r24, Z+14	; 0x0e
    4256:	97 85       	ldd	r25, Z+15	; 0x0f
    4258:	13 96       	adiw	r26, 0x03	; 3
    425a:	9c 93       	st	X, r25
    425c:	8e 93       	st	-X, r24
    425e:	12 97       	sbiw	r26, 0x02	; 2
    4260:	ef 81       	ldd	r30, Y+7	; 0x07
    4262:	f8 85       	ldd	r31, Y+8	; 0x08
    4264:	21 81       	ldd	r18, Z+1	; 0x01
    4266:	32 81       	ldd	r19, Z+2	; 0x02
    4268:	8a 85       	ldd	r24, Y+10	; 0x0a
    426a:	9b 85       	ldd	r25, Y+11	; 0x0b
    426c:	0c 96       	adiw	r24, 0x0c	; 12
    426e:	28 17       	cp	r18, r24
    4270:	39 07       	cpc	r19, r25
    4272:	41 f4       	brne	.+16     	; 0x4284 <xTaskResumeAll+0xb0>
    4274:	ea 85       	ldd	r30, Y+10	; 0x0a
    4276:	fb 85       	ldd	r31, Y+11	; 0x0b
    4278:	80 89       	ldd	r24, Z+16	; 0x10
    427a:	91 89       	ldd	r25, Z+17	; 0x11
    427c:	ef 81       	ldd	r30, Y+7	; 0x07
    427e:	f8 85       	ldd	r31, Y+8	; 0x08
    4280:	92 83       	std	Z+2, r25	; 0x02
    4282:	81 83       	std	Z+1, r24	; 0x01
    4284:	ea 85       	ldd	r30, Y+10	; 0x0a
    4286:	fb 85       	ldd	r31, Y+11	; 0x0b
    4288:	15 8a       	std	Z+21, r1	; 0x15
    428a:	14 8a       	std	Z+20, r1	; 0x14
    428c:	ef 81       	ldd	r30, Y+7	; 0x07
    428e:	f8 85       	ldd	r31, Y+8	; 0x08
    4290:	80 81       	ld	r24, Z
    4292:	81 50       	subi	r24, 0x01	; 1
    4294:	ef 81       	ldd	r30, Y+7	; 0x07
    4296:	f8 85       	ldd	r31, Y+8	; 0x08
    4298:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    429a:	ea 85       	ldd	r30, Y+10	; 0x0a
    429c:	fb 85       	ldd	r31, Y+11	; 0x0b
    429e:	82 85       	ldd	r24, Z+10	; 0x0a
    42a0:	93 85       	ldd	r25, Z+11	; 0x0b
    42a2:	9e 83       	std	Y+6, r25	; 0x06
    42a4:	8d 83       	std	Y+5, r24	; 0x05
    42a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    42a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    42aa:	a4 81       	ldd	r26, Z+4	; 0x04
    42ac:	b5 81       	ldd	r27, Z+5	; 0x05
    42ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    42b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    42b2:	86 81       	ldd	r24, Z+6	; 0x06
    42b4:	97 81       	ldd	r25, Z+7	; 0x07
    42b6:	15 96       	adiw	r26, 0x05	; 5
    42b8:	9c 93       	st	X, r25
    42ba:	8e 93       	st	-X, r24
    42bc:	14 97       	sbiw	r26, 0x04	; 4
    42be:	ea 85       	ldd	r30, Y+10	; 0x0a
    42c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    42c2:	a6 81       	ldd	r26, Z+6	; 0x06
    42c4:	b7 81       	ldd	r27, Z+7	; 0x07
    42c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    42c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    42ca:	84 81       	ldd	r24, Z+4	; 0x04
    42cc:	95 81       	ldd	r25, Z+5	; 0x05
    42ce:	13 96       	adiw	r26, 0x03	; 3
    42d0:	9c 93       	st	X, r25
    42d2:	8e 93       	st	-X, r24
    42d4:	12 97       	sbiw	r26, 0x02	; 2
    42d6:	ed 81       	ldd	r30, Y+5	; 0x05
    42d8:	fe 81       	ldd	r31, Y+6	; 0x06
    42da:	21 81       	ldd	r18, Z+1	; 0x01
    42dc:	32 81       	ldd	r19, Z+2	; 0x02
    42de:	8a 85       	ldd	r24, Y+10	; 0x0a
    42e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    42e2:	02 96       	adiw	r24, 0x02	; 2
    42e4:	28 17       	cp	r18, r24
    42e6:	39 07       	cpc	r19, r25
    42e8:	41 f4       	brne	.+16     	; 0x42fa <xTaskResumeAll+0x126>
    42ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    42ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    42ee:	86 81       	ldd	r24, Z+6	; 0x06
    42f0:	97 81       	ldd	r25, Z+7	; 0x07
    42f2:	ed 81       	ldd	r30, Y+5	; 0x05
    42f4:	fe 81       	ldd	r31, Y+6	; 0x06
    42f6:	92 83       	std	Z+2, r25	; 0x02
    42f8:	81 83       	std	Z+1, r24	; 0x01
    42fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    42fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    42fe:	13 86       	std	Z+11, r1	; 0x0b
    4300:	12 86       	std	Z+10, r1	; 0x0a
    4302:	ed 81       	ldd	r30, Y+5	; 0x05
    4304:	fe 81       	ldd	r31, Y+6	; 0x06
    4306:	80 81       	ld	r24, Z
    4308:	81 50       	subi	r24, 0x01	; 1
    430a:	ed 81       	ldd	r30, Y+5	; 0x05
    430c:	fe 81       	ldd	r31, Y+6	; 0x06
    430e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4310:	ea 85       	ldd	r30, Y+10	; 0x0a
    4312:	fb 85       	ldd	r31, Y+11	; 0x0b
    4314:	96 89       	ldd	r25, Z+22	; 0x16
    4316:	80 91 54 06 	lds	r24, 0x0654
    431a:	89 17       	cp	r24, r25
    431c:	28 f4       	brcc	.+10     	; 0x4328 <xTaskResumeAll+0x154>
    431e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4320:	fb 85       	ldd	r31, Y+11	; 0x0b
    4322:	86 89       	ldd	r24, Z+22	; 0x16
    4324:	80 93 54 06 	sts	0x0654, r24
    4328:	ea 85       	ldd	r30, Y+10	; 0x0a
    432a:	fb 85       	ldd	r31, Y+11	; 0x0b
    432c:	86 89       	ldd	r24, Z+22	; 0x16
    432e:	28 2f       	mov	r18, r24
    4330:	30 e0       	ldi	r19, 0x00	; 0
    4332:	c9 01       	movw	r24, r18
    4334:	88 0f       	add	r24, r24
    4336:	99 1f       	adc	r25, r25
    4338:	88 0f       	add	r24, r24
    433a:	99 1f       	adc	r25, r25
    433c:	88 0f       	add	r24, r24
    433e:	99 1f       	adc	r25, r25
    4340:	82 0f       	add	r24, r18
    4342:	93 1f       	adc	r25, r19
    4344:	fc 01       	movw	r30, r24
    4346:	e0 5a       	subi	r30, 0xA0	; 160
    4348:	f9 4f       	sbci	r31, 0xF9	; 249
    434a:	81 81       	ldd	r24, Z+1	; 0x01
    434c:	92 81       	ldd	r25, Z+2	; 0x02
    434e:	9c 83       	std	Y+4, r25	; 0x04
    4350:	8b 83       	std	Y+3, r24	; 0x03
    4352:	ea 85       	ldd	r30, Y+10	; 0x0a
    4354:	fb 85       	ldd	r31, Y+11	; 0x0b
    4356:	8b 81       	ldd	r24, Y+3	; 0x03
    4358:	9c 81       	ldd	r25, Y+4	; 0x04
    435a:	95 83       	std	Z+5, r25	; 0x05
    435c:	84 83       	std	Z+4, r24	; 0x04
    435e:	eb 81       	ldd	r30, Y+3	; 0x03
    4360:	fc 81       	ldd	r31, Y+4	; 0x04
    4362:	84 81       	ldd	r24, Z+4	; 0x04
    4364:	95 81       	ldd	r25, Z+5	; 0x05
    4366:	ea 85       	ldd	r30, Y+10	; 0x0a
    4368:	fb 85       	ldd	r31, Y+11	; 0x0b
    436a:	97 83       	std	Z+7, r25	; 0x07
    436c:	86 83       	std	Z+6, r24	; 0x06
    436e:	eb 81       	ldd	r30, Y+3	; 0x03
    4370:	fc 81       	ldd	r31, Y+4	; 0x04
    4372:	04 80       	ldd	r0, Z+4	; 0x04
    4374:	f5 81       	ldd	r31, Z+5	; 0x05
    4376:	e0 2d       	mov	r30, r0
    4378:	8a 85       	ldd	r24, Y+10	; 0x0a
    437a:	9b 85       	ldd	r25, Y+11	; 0x0b
    437c:	02 96       	adiw	r24, 0x02	; 2
    437e:	93 83       	std	Z+3, r25	; 0x03
    4380:	82 83       	std	Z+2, r24	; 0x02
    4382:	8a 85       	ldd	r24, Y+10	; 0x0a
    4384:	9b 85       	ldd	r25, Y+11	; 0x0b
    4386:	02 96       	adiw	r24, 0x02	; 2
    4388:	eb 81       	ldd	r30, Y+3	; 0x03
    438a:	fc 81       	ldd	r31, Y+4	; 0x04
    438c:	95 83       	std	Z+5, r25	; 0x05
    438e:	84 83       	std	Z+4, r24	; 0x04
    4390:	ea 85       	ldd	r30, Y+10	; 0x0a
    4392:	fb 85       	ldd	r31, Y+11	; 0x0b
    4394:	86 89       	ldd	r24, Z+22	; 0x16
    4396:	28 2f       	mov	r18, r24
    4398:	30 e0       	ldi	r19, 0x00	; 0
    439a:	c9 01       	movw	r24, r18
    439c:	88 0f       	add	r24, r24
    439e:	99 1f       	adc	r25, r25
    43a0:	88 0f       	add	r24, r24
    43a2:	99 1f       	adc	r25, r25
    43a4:	88 0f       	add	r24, r24
    43a6:	99 1f       	adc	r25, r25
    43a8:	82 0f       	add	r24, r18
    43aa:	93 1f       	adc	r25, r19
    43ac:	80 5a       	subi	r24, 0xA0	; 160
    43ae:	99 4f       	sbci	r25, 0xF9	; 249
    43b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    43b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    43b4:	93 87       	std	Z+11, r25	; 0x0b
    43b6:	82 87       	std	Z+10, r24	; 0x0a
    43b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    43ba:	fb 85       	ldd	r31, Y+11	; 0x0b
    43bc:	86 89       	ldd	r24, Z+22	; 0x16
    43be:	28 2f       	mov	r18, r24
    43c0:	30 e0       	ldi	r19, 0x00	; 0
    43c2:	c9 01       	movw	r24, r18
    43c4:	88 0f       	add	r24, r24
    43c6:	99 1f       	adc	r25, r25
    43c8:	88 0f       	add	r24, r24
    43ca:	99 1f       	adc	r25, r25
    43cc:	88 0f       	add	r24, r24
    43ce:	99 1f       	adc	r25, r25
    43d0:	82 0f       	add	r24, r18
    43d2:	93 1f       	adc	r25, r19
    43d4:	fc 01       	movw	r30, r24
    43d6:	e0 5a       	subi	r30, 0xA0	; 160
    43d8:	f9 4f       	sbci	r31, 0xF9	; 249
    43da:	80 81       	ld	r24, Z
    43dc:	8f 5f       	subi	r24, 0xFF	; 255
    43de:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    43e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    43e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    43e4:	96 89       	ldd	r25, Z+22	; 0x16
    43e6:	e0 91 4e 06 	lds	r30, 0x064E
    43ea:	f0 91 4f 06 	lds	r31, 0x064F
    43ee:	86 89       	ldd	r24, Z+22	; 0x16
    43f0:	98 17       	cp	r25, r24
    43f2:	18 f0       	brcs	.+6      	; 0x43fa <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    43f4:	81 e0       	ldi	r24, 0x01	; 1
    43f6:	80 93 58 06 	sts	0x0658, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    43fa:	80 91 9a 06 	lds	r24, 0x069A
    43fe:	88 23       	and	r24, r24
    4400:	09 f0       	breq	.+2      	; 0x4404 <xTaskResumeAll+0x230>
    4402:	08 cf       	rjmp	.-496    	; 0x4214 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    4404:	8a 85       	ldd	r24, Y+10	; 0x0a
    4406:	9b 85       	ldd	r25, Y+11	; 0x0b
    4408:	00 97       	sbiw	r24, 0x00	; 0
    440a:	11 f0       	breq	.+4      	; 0x4410 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    440c:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    4410:	80 91 56 06 	lds	r24, 0x0656
    4414:	90 91 57 06 	lds	r25, 0x0657
    4418:	9a 83       	std	Y+2, r25	; 0x02
    441a:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    441c:	89 81       	ldd	r24, Y+1	; 0x01
    441e:	9a 81       	ldd	r25, Y+2	; 0x02
    4420:	00 97       	sbiw	r24, 0x00	; 0
    4422:	a1 f0       	breq	.+40     	; 0x444c <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    4424:	0e 94 bc 22 	call	0x4578	; 0x4578 <xTaskIncrementTick>
    4428:	88 23       	and	r24, r24
    442a:	19 f0       	breq	.+6      	; 0x4432 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    442c:	81 e0       	ldi	r24, 0x01	; 1
    442e:	80 93 58 06 	sts	0x0658, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    4432:	89 81       	ldd	r24, Y+1	; 0x01
    4434:	9a 81       	ldd	r25, Y+2	; 0x02
    4436:	01 97       	sbiw	r24, 0x01	; 1
    4438:	9a 83       	std	Y+2, r25	; 0x02
    443a:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    443c:	89 81       	ldd	r24, Y+1	; 0x01
    443e:	9a 81       	ldd	r25, Y+2	; 0x02
    4440:	00 97       	sbiw	r24, 0x00	; 0
    4442:	81 f7       	brne	.-32     	; 0x4424 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    4444:	10 92 57 06 	sts	0x0657, r1
    4448:	10 92 56 06 	sts	0x0656, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    444c:	80 91 58 06 	lds	r24, 0x0658
    4450:	88 23       	and	r24, r24
    4452:	21 f0       	breq	.+8      	; 0x445c <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
    4454:	81 e0       	ldi	r24, 0x01	; 1
    4456:	89 87       	std	Y+9, r24	; 0x09
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    4458:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    445c:	0f 90       	pop	r0
    445e:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    4460:	89 85       	ldd	r24, Y+9	; 0x09
}
    4462:	2b 96       	adiw	r28, 0x0b	; 11
    4464:	0f b6       	in	r0, 0x3f	; 63
    4466:	f8 94       	cli
    4468:	de bf       	out	0x3e, r29	; 62
    446a:	0f be       	out	0x3f, r0	; 63
    446c:	cd bf       	out	0x3d, r28	; 61
    446e:	cf 91       	pop	r28
    4470:	df 91       	pop	r29
    4472:	08 95       	ret

00004474 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4474:	df 93       	push	r29
    4476:	cf 93       	push	r28
    4478:	00 d0       	rcall	.+0      	; 0x447a <xTaskGetTickCount+0x6>
    447a:	cd b7       	in	r28, 0x3d	; 61
    447c:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    447e:	0f b6       	in	r0, 0x3f	; 63
    4480:	f8 94       	cli
    4482:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    4484:	80 91 52 06 	lds	r24, 0x0652
    4488:	90 91 53 06 	lds	r25, 0x0653
    448c:	9a 83       	std	Y+2, r25	; 0x02
    448e:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    4490:	0f 90       	pop	r0
    4492:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    4494:	89 81       	ldd	r24, Y+1	; 0x01
    4496:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4498:	0f 90       	pop	r0
    449a:	0f 90       	pop	r0
    449c:	cf 91       	pop	r28
    449e:	df 91       	pop	r29
    44a0:	08 95       	ret

000044a2 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    44a2:	df 93       	push	r29
    44a4:	cf 93       	push	r28
    44a6:	00 d0       	rcall	.+0      	; 0x44a8 <xTaskGetTickCountFromISR+0x6>
    44a8:	0f 92       	push	r0
    44aa:	cd b7       	in	r28, 0x3d	; 61
    44ac:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    44ae:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    44b0:	80 91 52 06 	lds	r24, 0x0652
    44b4:	90 91 53 06 	lds	r25, 0x0653
    44b8:	9b 83       	std	Y+3, r25	; 0x03
    44ba:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    44bc:	8a 81       	ldd	r24, Y+2	; 0x02
    44be:	9b 81       	ldd	r25, Y+3	; 0x03
}
    44c0:	0f 90       	pop	r0
    44c2:	0f 90       	pop	r0
    44c4:	0f 90       	pop	r0
    44c6:	cf 91       	pop	r28
    44c8:	df 91       	pop	r29
    44ca:	08 95       	ret

000044cc <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    44cc:	df 93       	push	r29
    44ce:	cf 93       	push	r28
    44d0:	cd b7       	in	r28, 0x3d	; 61
    44d2:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    44d4:	80 91 51 06 	lds	r24, 0x0651
}
    44d8:	cf 91       	pop	r28
    44da:	df 91       	pop	r29
    44dc:	08 95       	ret

000044de <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    44de:	df 93       	push	r29
    44e0:	cf 93       	push	r28
    44e2:	00 d0       	rcall	.+0      	; 0x44e4 <pcTaskGetName+0x6>
    44e4:	00 d0       	rcall	.+0      	; 0x44e6 <pcTaskGetName+0x8>
    44e6:	00 d0       	rcall	.+0      	; 0x44e8 <pcTaskGetName+0xa>
    44e8:	cd b7       	in	r28, 0x3d	; 61
    44ea:	de b7       	in	r29, 0x3e	; 62
    44ec:	9c 83       	std	Y+4, r25	; 0x04
    44ee:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    44f0:	8b 81       	ldd	r24, Y+3	; 0x03
    44f2:	9c 81       	ldd	r25, Y+4	; 0x04
    44f4:	00 97       	sbiw	r24, 0x00	; 0
    44f6:	39 f4       	brne	.+14     	; 0x4506 <pcTaskGetName+0x28>
    44f8:	80 91 4e 06 	lds	r24, 0x064E
    44fc:	90 91 4f 06 	lds	r25, 0x064F
    4500:	9e 83       	std	Y+6, r25	; 0x06
    4502:	8d 83       	std	Y+5, r24	; 0x05
    4504:	04 c0       	rjmp	.+8      	; 0x450e <pcTaskGetName+0x30>
    4506:	8b 81       	ldd	r24, Y+3	; 0x03
    4508:	9c 81       	ldd	r25, Y+4	; 0x04
    450a:	9e 83       	std	Y+6, r25	; 0x06
    450c:	8d 83       	std	Y+5, r24	; 0x05
    450e:	8d 81       	ldd	r24, Y+5	; 0x05
    4510:	9e 81       	ldd	r25, Y+6	; 0x06
    4512:	9a 83       	std	Y+2, r25	; 0x02
    4514:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    4516:	89 81       	ldd	r24, Y+1	; 0x01
    4518:	9a 81       	ldd	r25, Y+2	; 0x02
    451a:	49 96       	adiw	r24, 0x19	; 25
}
    451c:	26 96       	adiw	r28, 0x06	; 6
    451e:	0f b6       	in	r0, 0x3f	; 63
    4520:	f8 94       	cli
    4522:	de bf       	out	0x3e, r29	; 62
    4524:	0f be       	out	0x3f, r0	; 63
    4526:	cd bf       	out	0x3d, r28	; 61
    4528:	cf 91       	pop	r28
    452a:	df 91       	pop	r29
    452c:	08 95       	ret

0000452e <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    452e:	df 93       	push	r29
    4530:	cf 93       	push	r28
    4532:	00 d0       	rcall	.+0      	; 0x4534 <xTaskCatchUpTicks+0x6>
    4534:	0f 92       	push	r0
    4536:	cd b7       	in	r28, 0x3d	; 61
    4538:	de b7       	in	r29, 0x3e	; 62
    453a:	9b 83       	std	Y+3, r25	; 0x03
    453c:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    453e:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    4542:	0f b6       	in	r0, 0x3f	; 63
    4544:	f8 94       	cli
    4546:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    4548:	20 91 56 06 	lds	r18, 0x0656
    454c:	30 91 57 06 	lds	r19, 0x0657
    4550:	8a 81       	ldd	r24, Y+2	; 0x02
    4552:	9b 81       	ldd	r25, Y+3	; 0x03
    4554:	82 0f       	add	r24, r18
    4556:	93 1f       	adc	r25, r19
    4558:	90 93 57 06 	sts	0x0657, r25
    455c:	80 93 56 06 	sts	0x0656, r24
    }
    taskEXIT_CRITICAL();
    4560:	0f 90       	pop	r0
    4562:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    4564:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <xTaskResumeAll>
    4568:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    456a:	89 81       	ldd	r24, Y+1	; 0x01
}
    456c:	0f 90       	pop	r0
    456e:	0f 90       	pop	r0
    4570:	0f 90       	pop	r0
    4572:	cf 91       	pop	r28
    4574:	df 91       	pop	r29
    4576:	08 95       	ret

00004578 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4578:	df 93       	push	r29
    457a:	cf 93       	push	r28
    457c:	cd b7       	in	r28, 0x3d	; 61
    457e:	de b7       	in	r29, 0x3e	; 62
    4580:	2f 97       	sbiw	r28, 0x0f	; 15
    4582:	0f b6       	in	r0, 0x3f	; 63
    4584:	f8 94       	cli
    4586:	de bf       	out	0x3e, r29	; 62
    4588:	0f be       	out	0x3f, r0	; 63
    458a:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    458c:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    458e:	80 91 5f 06 	lds	r24, 0x065F
    4592:	88 23       	and	r24, r24
    4594:	09 f0       	breq	.+2      	; 0x4598 <xTaskIncrementTick+0x20>
    4596:	74 c1       	rjmp	.+744    	; 0x4880 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4598:	80 91 52 06 	lds	r24, 0x0652
    459c:	90 91 53 06 	lds	r25, 0x0653
    45a0:	01 96       	adiw	r24, 0x01	; 1
    45a2:	9a 87       	std	Y+10, r25	; 0x0a
    45a4:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    45a6:	89 85       	ldd	r24, Y+9	; 0x09
    45a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    45aa:	90 93 53 06 	sts	0x0653, r25
    45ae:	80 93 52 06 	sts	0x0652, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    45b2:	89 85       	ldd	r24, Y+9	; 0x09
    45b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    45b6:	00 97       	sbiw	r24, 0x00	; 0
    45b8:	d9 f4       	brne	.+54     	; 0x45f0 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    45ba:	80 91 96 06 	lds	r24, 0x0696
    45be:	90 91 97 06 	lds	r25, 0x0697
    45c2:	98 87       	std	Y+8, r25	; 0x08
    45c4:	8f 83       	std	Y+7, r24	; 0x07
    45c6:	80 91 98 06 	lds	r24, 0x0698
    45ca:	90 91 99 06 	lds	r25, 0x0699
    45ce:	90 93 97 06 	sts	0x0697, r25
    45d2:	80 93 96 06 	sts	0x0696, r24
    45d6:	8f 81       	ldd	r24, Y+7	; 0x07
    45d8:	98 85       	ldd	r25, Y+8	; 0x08
    45da:	90 93 99 06 	sts	0x0699, r25
    45de:	80 93 98 06 	sts	0x0698, r24
    45e2:	80 91 59 06 	lds	r24, 0x0659
    45e6:	8f 5f       	subi	r24, 0xFF	; 255
    45e8:	80 93 59 06 	sts	0x0659, r24
    45ec:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    45f0:	20 91 5b 06 	lds	r18, 0x065B
    45f4:	30 91 5c 06 	lds	r19, 0x065C
    45f8:	89 85       	ldd	r24, Y+9	; 0x09
    45fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    45fc:	82 17       	cp	r24, r18
    45fe:	93 07       	cpc	r25, r19
    4600:	08 f4       	brcc	.+2      	; 0x4604 <xTaskIncrementTick+0x8c>
    4602:	1f c1       	rjmp	.+574    	; 0x4842 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4604:	e0 91 96 06 	lds	r30, 0x0696
    4608:	f0 91 97 06 	lds	r31, 0x0697
    460c:	80 81       	ld	r24, Z
    460e:	88 23       	and	r24, r24
    4610:	39 f4       	brne	.+14     	; 0x4620 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4612:	8f ef       	ldi	r24, 0xFF	; 255
    4614:	9f ef       	ldi	r25, 0xFF	; 255
    4616:	90 93 5c 06 	sts	0x065C, r25
    461a:	80 93 5b 06 	sts	0x065B, r24
    461e:	11 c1       	rjmp	.+546    	; 0x4842 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4620:	e0 91 96 06 	lds	r30, 0x0696
    4624:	f0 91 97 06 	lds	r31, 0x0697
    4628:	05 80       	ldd	r0, Z+5	; 0x05
    462a:	f6 81       	ldd	r31, Z+6	; 0x06
    462c:	e0 2d       	mov	r30, r0
    462e:	86 81       	ldd	r24, Z+6	; 0x06
    4630:	97 81       	ldd	r25, Z+7	; 0x07
    4632:	9f 87       	std	Y+15, r25	; 0x0f
    4634:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4636:	ee 85       	ldd	r30, Y+14	; 0x0e
    4638:	ff 85       	ldd	r31, Y+15	; 0x0f
    463a:	82 81       	ldd	r24, Z+2	; 0x02
    463c:	93 81       	ldd	r25, Z+3	; 0x03
    463e:	9d 87       	std	Y+13, r25	; 0x0d
    4640:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    4642:	29 85       	ldd	r18, Y+9	; 0x09
    4644:	3a 85       	ldd	r19, Y+10	; 0x0a
    4646:	8c 85       	ldd	r24, Y+12	; 0x0c
    4648:	9d 85       	ldd	r25, Y+13	; 0x0d
    464a:	28 17       	cp	r18, r24
    464c:	39 07       	cpc	r19, r25
    464e:	38 f4       	brcc	.+14     	; 0x465e <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    4650:	8c 85       	ldd	r24, Y+12	; 0x0c
    4652:	9d 85       	ldd	r25, Y+13	; 0x0d
    4654:	90 93 5c 06 	sts	0x065C, r25
    4658:	80 93 5b 06 	sts	0x065B, r24
    465c:	f2 c0       	rjmp	.+484    	; 0x4842 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    465e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4660:	ff 85       	ldd	r31, Y+15	; 0x0f
    4662:	82 85       	ldd	r24, Z+10	; 0x0a
    4664:	93 85       	ldd	r25, Z+11	; 0x0b
    4666:	9e 83       	std	Y+6, r25	; 0x06
    4668:	8d 83       	std	Y+5, r24	; 0x05
    466a:	ee 85       	ldd	r30, Y+14	; 0x0e
    466c:	ff 85       	ldd	r31, Y+15	; 0x0f
    466e:	a4 81       	ldd	r26, Z+4	; 0x04
    4670:	b5 81       	ldd	r27, Z+5	; 0x05
    4672:	ee 85       	ldd	r30, Y+14	; 0x0e
    4674:	ff 85       	ldd	r31, Y+15	; 0x0f
    4676:	86 81       	ldd	r24, Z+6	; 0x06
    4678:	97 81       	ldd	r25, Z+7	; 0x07
    467a:	15 96       	adiw	r26, 0x05	; 5
    467c:	9c 93       	st	X, r25
    467e:	8e 93       	st	-X, r24
    4680:	14 97       	sbiw	r26, 0x04	; 4
    4682:	ee 85       	ldd	r30, Y+14	; 0x0e
    4684:	ff 85       	ldd	r31, Y+15	; 0x0f
    4686:	a6 81       	ldd	r26, Z+6	; 0x06
    4688:	b7 81       	ldd	r27, Z+7	; 0x07
    468a:	ee 85       	ldd	r30, Y+14	; 0x0e
    468c:	ff 85       	ldd	r31, Y+15	; 0x0f
    468e:	84 81       	ldd	r24, Z+4	; 0x04
    4690:	95 81       	ldd	r25, Z+5	; 0x05
    4692:	13 96       	adiw	r26, 0x03	; 3
    4694:	9c 93       	st	X, r25
    4696:	8e 93       	st	-X, r24
    4698:	12 97       	sbiw	r26, 0x02	; 2
    469a:	ed 81       	ldd	r30, Y+5	; 0x05
    469c:	fe 81       	ldd	r31, Y+6	; 0x06
    469e:	21 81       	ldd	r18, Z+1	; 0x01
    46a0:	32 81       	ldd	r19, Z+2	; 0x02
    46a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    46a4:	9f 85       	ldd	r25, Y+15	; 0x0f
    46a6:	02 96       	adiw	r24, 0x02	; 2
    46a8:	28 17       	cp	r18, r24
    46aa:	39 07       	cpc	r19, r25
    46ac:	41 f4       	brne	.+16     	; 0x46be <xTaskIncrementTick+0x146>
    46ae:	ee 85       	ldd	r30, Y+14	; 0x0e
    46b0:	ff 85       	ldd	r31, Y+15	; 0x0f
    46b2:	86 81       	ldd	r24, Z+6	; 0x06
    46b4:	97 81       	ldd	r25, Z+7	; 0x07
    46b6:	ed 81       	ldd	r30, Y+5	; 0x05
    46b8:	fe 81       	ldd	r31, Y+6	; 0x06
    46ba:	92 83       	std	Z+2, r25	; 0x02
    46bc:	81 83       	std	Z+1, r24	; 0x01
    46be:	ee 85       	ldd	r30, Y+14	; 0x0e
    46c0:	ff 85       	ldd	r31, Y+15	; 0x0f
    46c2:	13 86       	std	Z+11, r1	; 0x0b
    46c4:	12 86       	std	Z+10, r1	; 0x0a
    46c6:	ed 81       	ldd	r30, Y+5	; 0x05
    46c8:	fe 81       	ldd	r31, Y+6	; 0x06
    46ca:	80 81       	ld	r24, Z
    46cc:	81 50       	subi	r24, 0x01	; 1
    46ce:	ed 81       	ldd	r30, Y+5	; 0x05
    46d0:	fe 81       	ldd	r31, Y+6	; 0x06
    46d2:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    46d4:	ee 85       	ldd	r30, Y+14	; 0x0e
    46d6:	ff 85       	ldd	r31, Y+15	; 0x0f
    46d8:	84 89       	ldd	r24, Z+20	; 0x14
    46da:	95 89       	ldd	r25, Z+21	; 0x15
    46dc:	00 97       	sbiw	r24, 0x00	; 0
    46de:	d9 f1       	breq	.+118    	; 0x4756 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    46e0:	ee 85       	ldd	r30, Y+14	; 0x0e
    46e2:	ff 85       	ldd	r31, Y+15	; 0x0f
    46e4:	84 89       	ldd	r24, Z+20	; 0x14
    46e6:	95 89       	ldd	r25, Z+21	; 0x15
    46e8:	9c 83       	std	Y+4, r25	; 0x04
    46ea:	8b 83       	std	Y+3, r24	; 0x03
    46ec:	ee 85       	ldd	r30, Y+14	; 0x0e
    46ee:	ff 85       	ldd	r31, Y+15	; 0x0f
    46f0:	a6 85       	ldd	r26, Z+14	; 0x0e
    46f2:	b7 85       	ldd	r27, Z+15	; 0x0f
    46f4:	ee 85       	ldd	r30, Y+14	; 0x0e
    46f6:	ff 85       	ldd	r31, Y+15	; 0x0f
    46f8:	80 89       	ldd	r24, Z+16	; 0x10
    46fa:	91 89       	ldd	r25, Z+17	; 0x11
    46fc:	15 96       	adiw	r26, 0x05	; 5
    46fe:	9c 93       	st	X, r25
    4700:	8e 93       	st	-X, r24
    4702:	14 97       	sbiw	r26, 0x04	; 4
    4704:	ee 85       	ldd	r30, Y+14	; 0x0e
    4706:	ff 85       	ldd	r31, Y+15	; 0x0f
    4708:	a0 89       	ldd	r26, Z+16	; 0x10
    470a:	b1 89       	ldd	r27, Z+17	; 0x11
    470c:	ee 85       	ldd	r30, Y+14	; 0x0e
    470e:	ff 85       	ldd	r31, Y+15	; 0x0f
    4710:	86 85       	ldd	r24, Z+14	; 0x0e
    4712:	97 85       	ldd	r25, Z+15	; 0x0f
    4714:	13 96       	adiw	r26, 0x03	; 3
    4716:	9c 93       	st	X, r25
    4718:	8e 93       	st	-X, r24
    471a:	12 97       	sbiw	r26, 0x02	; 2
    471c:	eb 81       	ldd	r30, Y+3	; 0x03
    471e:	fc 81       	ldd	r31, Y+4	; 0x04
    4720:	21 81       	ldd	r18, Z+1	; 0x01
    4722:	32 81       	ldd	r19, Z+2	; 0x02
    4724:	8e 85       	ldd	r24, Y+14	; 0x0e
    4726:	9f 85       	ldd	r25, Y+15	; 0x0f
    4728:	0c 96       	adiw	r24, 0x0c	; 12
    472a:	28 17       	cp	r18, r24
    472c:	39 07       	cpc	r19, r25
    472e:	41 f4       	brne	.+16     	; 0x4740 <xTaskIncrementTick+0x1c8>
    4730:	ee 85       	ldd	r30, Y+14	; 0x0e
    4732:	ff 85       	ldd	r31, Y+15	; 0x0f
    4734:	80 89       	ldd	r24, Z+16	; 0x10
    4736:	91 89       	ldd	r25, Z+17	; 0x11
    4738:	eb 81       	ldd	r30, Y+3	; 0x03
    473a:	fc 81       	ldd	r31, Y+4	; 0x04
    473c:	92 83       	std	Z+2, r25	; 0x02
    473e:	81 83       	std	Z+1, r24	; 0x01
    4740:	ee 85       	ldd	r30, Y+14	; 0x0e
    4742:	ff 85       	ldd	r31, Y+15	; 0x0f
    4744:	15 8a       	std	Z+21, r1	; 0x15
    4746:	14 8a       	std	Z+20, r1	; 0x14
    4748:	eb 81       	ldd	r30, Y+3	; 0x03
    474a:	fc 81       	ldd	r31, Y+4	; 0x04
    474c:	80 81       	ld	r24, Z
    474e:	81 50       	subi	r24, 0x01	; 1
    4750:	eb 81       	ldd	r30, Y+3	; 0x03
    4752:	fc 81       	ldd	r31, Y+4	; 0x04
    4754:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    4756:	ee 85       	ldd	r30, Y+14	; 0x0e
    4758:	ff 85       	ldd	r31, Y+15	; 0x0f
    475a:	96 89       	ldd	r25, Z+22	; 0x16
    475c:	80 91 54 06 	lds	r24, 0x0654
    4760:	89 17       	cp	r24, r25
    4762:	28 f4       	brcc	.+10     	; 0x476e <xTaskIncrementTick+0x1f6>
    4764:	ee 85       	ldd	r30, Y+14	; 0x0e
    4766:	ff 85       	ldd	r31, Y+15	; 0x0f
    4768:	86 89       	ldd	r24, Z+22	; 0x16
    476a:	80 93 54 06 	sts	0x0654, r24
    476e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4770:	ff 85       	ldd	r31, Y+15	; 0x0f
    4772:	86 89       	ldd	r24, Z+22	; 0x16
    4774:	28 2f       	mov	r18, r24
    4776:	30 e0       	ldi	r19, 0x00	; 0
    4778:	c9 01       	movw	r24, r18
    477a:	88 0f       	add	r24, r24
    477c:	99 1f       	adc	r25, r25
    477e:	88 0f       	add	r24, r24
    4780:	99 1f       	adc	r25, r25
    4782:	88 0f       	add	r24, r24
    4784:	99 1f       	adc	r25, r25
    4786:	82 0f       	add	r24, r18
    4788:	93 1f       	adc	r25, r19
    478a:	fc 01       	movw	r30, r24
    478c:	e0 5a       	subi	r30, 0xA0	; 160
    478e:	f9 4f       	sbci	r31, 0xF9	; 249
    4790:	81 81       	ldd	r24, Z+1	; 0x01
    4792:	92 81       	ldd	r25, Z+2	; 0x02
    4794:	9a 83       	std	Y+2, r25	; 0x02
    4796:	89 83       	std	Y+1, r24	; 0x01
    4798:	ee 85       	ldd	r30, Y+14	; 0x0e
    479a:	ff 85       	ldd	r31, Y+15	; 0x0f
    479c:	89 81       	ldd	r24, Y+1	; 0x01
    479e:	9a 81       	ldd	r25, Y+2	; 0x02
    47a0:	95 83       	std	Z+5, r25	; 0x05
    47a2:	84 83       	std	Z+4, r24	; 0x04
    47a4:	e9 81       	ldd	r30, Y+1	; 0x01
    47a6:	fa 81       	ldd	r31, Y+2	; 0x02
    47a8:	84 81       	ldd	r24, Z+4	; 0x04
    47aa:	95 81       	ldd	r25, Z+5	; 0x05
    47ac:	ee 85       	ldd	r30, Y+14	; 0x0e
    47ae:	ff 85       	ldd	r31, Y+15	; 0x0f
    47b0:	97 83       	std	Z+7, r25	; 0x07
    47b2:	86 83       	std	Z+6, r24	; 0x06
    47b4:	e9 81       	ldd	r30, Y+1	; 0x01
    47b6:	fa 81       	ldd	r31, Y+2	; 0x02
    47b8:	04 80       	ldd	r0, Z+4	; 0x04
    47ba:	f5 81       	ldd	r31, Z+5	; 0x05
    47bc:	e0 2d       	mov	r30, r0
    47be:	8e 85       	ldd	r24, Y+14	; 0x0e
    47c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    47c2:	02 96       	adiw	r24, 0x02	; 2
    47c4:	93 83       	std	Z+3, r25	; 0x03
    47c6:	82 83       	std	Z+2, r24	; 0x02
    47c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    47ca:	9f 85       	ldd	r25, Y+15	; 0x0f
    47cc:	02 96       	adiw	r24, 0x02	; 2
    47ce:	e9 81       	ldd	r30, Y+1	; 0x01
    47d0:	fa 81       	ldd	r31, Y+2	; 0x02
    47d2:	95 83       	std	Z+5, r25	; 0x05
    47d4:	84 83       	std	Z+4, r24	; 0x04
    47d6:	ee 85       	ldd	r30, Y+14	; 0x0e
    47d8:	ff 85       	ldd	r31, Y+15	; 0x0f
    47da:	86 89       	ldd	r24, Z+22	; 0x16
    47dc:	28 2f       	mov	r18, r24
    47de:	30 e0       	ldi	r19, 0x00	; 0
    47e0:	c9 01       	movw	r24, r18
    47e2:	88 0f       	add	r24, r24
    47e4:	99 1f       	adc	r25, r25
    47e6:	88 0f       	add	r24, r24
    47e8:	99 1f       	adc	r25, r25
    47ea:	88 0f       	add	r24, r24
    47ec:	99 1f       	adc	r25, r25
    47ee:	82 0f       	add	r24, r18
    47f0:	93 1f       	adc	r25, r19
    47f2:	80 5a       	subi	r24, 0xA0	; 160
    47f4:	99 4f       	sbci	r25, 0xF9	; 249
    47f6:	ee 85       	ldd	r30, Y+14	; 0x0e
    47f8:	ff 85       	ldd	r31, Y+15	; 0x0f
    47fa:	93 87       	std	Z+11, r25	; 0x0b
    47fc:	82 87       	std	Z+10, r24	; 0x0a
    47fe:	ee 85       	ldd	r30, Y+14	; 0x0e
    4800:	ff 85       	ldd	r31, Y+15	; 0x0f
    4802:	86 89       	ldd	r24, Z+22	; 0x16
    4804:	28 2f       	mov	r18, r24
    4806:	30 e0       	ldi	r19, 0x00	; 0
    4808:	c9 01       	movw	r24, r18
    480a:	88 0f       	add	r24, r24
    480c:	99 1f       	adc	r25, r25
    480e:	88 0f       	add	r24, r24
    4810:	99 1f       	adc	r25, r25
    4812:	88 0f       	add	r24, r24
    4814:	99 1f       	adc	r25, r25
    4816:	82 0f       	add	r24, r18
    4818:	93 1f       	adc	r25, r19
    481a:	fc 01       	movw	r30, r24
    481c:	e0 5a       	subi	r30, 0xA0	; 160
    481e:	f9 4f       	sbci	r31, 0xF9	; 249
    4820:	80 81       	ld	r24, Z
    4822:	8f 5f       	subi	r24, 0xFF	; 255
    4824:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4826:	ee 85       	ldd	r30, Y+14	; 0x0e
    4828:	ff 85       	ldd	r31, Y+15	; 0x0f
    482a:	96 89       	ldd	r25, Z+22	; 0x16
    482c:	e0 91 4e 06 	lds	r30, 0x064E
    4830:	f0 91 4f 06 	lds	r31, 0x064F
    4834:	86 89       	ldd	r24, Z+22	; 0x16
    4836:	89 17       	cp	r24, r25
    4838:	08 f0       	brcs	.+2      	; 0x483c <xTaskIncrementTick+0x2c4>
    483a:	e4 ce       	rjmp	.-568    	; 0x4604 <xTaskIncrementTick+0x8c>
                        {
                            xSwitchRequired = pdTRUE;
    483c:	81 e0       	ldi	r24, 0x01	; 1
    483e:	8b 87       	std	Y+11, r24	; 0x0b
    4840:	e1 ce       	rjmp	.-574    	; 0x4604 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4842:	e0 91 4e 06 	lds	r30, 0x064E
    4846:	f0 91 4f 06 	lds	r31, 0x064F
    484a:	86 89       	ldd	r24, Z+22	; 0x16
    484c:	28 2f       	mov	r18, r24
    484e:	30 e0       	ldi	r19, 0x00	; 0
    4850:	c9 01       	movw	r24, r18
    4852:	88 0f       	add	r24, r24
    4854:	99 1f       	adc	r25, r25
    4856:	88 0f       	add	r24, r24
    4858:	99 1f       	adc	r25, r25
    485a:	88 0f       	add	r24, r24
    485c:	99 1f       	adc	r25, r25
    485e:	82 0f       	add	r24, r18
    4860:	93 1f       	adc	r25, r19
    4862:	fc 01       	movw	r30, r24
    4864:	e0 5a       	subi	r30, 0xA0	; 160
    4866:	f9 4f       	sbci	r31, 0xF9	; 249
    4868:	80 81       	ld	r24, Z
    486a:	82 30       	cpi	r24, 0x02	; 2
    486c:	10 f0       	brcs	.+4      	; 0x4872 <xTaskIncrementTick+0x2fa>
            {
                xSwitchRequired = pdTRUE;
    486e:	81 e0       	ldi	r24, 0x01	; 1
    4870:	8b 87       	std	Y+11, r24	; 0x0b
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    4872:	80 91 58 06 	lds	r24, 0x0658
    4876:	88 23       	and	r24, r24
    4878:	61 f0       	breq	.+24     	; 0x4892 <xTaskIncrementTick+0x31a>
            {
                xSwitchRequired = pdTRUE;
    487a:	81 e0       	ldi	r24, 0x01	; 1
    487c:	8b 87       	std	Y+11, r24	; 0x0b
    487e:	09 c0       	rjmp	.+18     	; 0x4892 <xTaskIncrementTick+0x31a>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    4880:	80 91 56 06 	lds	r24, 0x0656
    4884:	90 91 57 06 	lds	r25, 0x0657
    4888:	01 96       	adiw	r24, 0x01	; 1
    488a:	90 93 57 06 	sts	0x0657, r25
    488e:	80 93 56 06 	sts	0x0656, r24
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
    4892:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    4894:	2f 96       	adiw	r28, 0x0f	; 15
    4896:	0f b6       	in	r0, 0x3f	; 63
    4898:	f8 94       	cli
    489a:	de bf       	out	0x3e, r29	; 62
    489c:	0f be       	out	0x3f, r0	; 63
    489e:	cd bf       	out	0x3d, r28	; 61
    48a0:	cf 91       	pop	r28
    48a2:	df 91       	pop	r29
    48a4:	08 95       	ret

000048a6 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    48a6:	df 93       	push	r29
    48a8:	cf 93       	push	r28
    48aa:	00 d0       	rcall	.+0      	; 0x48ac <vTaskSwitchContext+0x6>
    48ac:	0f 92       	push	r0
    48ae:	cd b7       	in	r28, 0x3d	; 61
    48b0:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    48b2:	80 91 5f 06 	lds	r24, 0x065F
    48b6:	88 23       	and	r24, r24
    48b8:	21 f0       	breq	.+8      	; 0x48c2 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    48ba:	81 e0       	ldi	r24, 0x01	; 1
    48bc:	80 93 58 06 	sts	0x0658, r24
    48c0:	59 c0       	rjmp	.+178    	; 0x4974 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    48c2:	10 92 58 06 	sts	0x0658, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    48c6:	80 91 54 06 	lds	r24, 0x0654
    48ca:	8b 83       	std	Y+3, r24	; 0x03
    48cc:	03 c0       	rjmp	.+6      	; 0x48d4 <vTaskSwitchContext+0x2e>
    48ce:	8b 81       	ldd	r24, Y+3	; 0x03
    48d0:	81 50       	subi	r24, 0x01	; 1
    48d2:	8b 83       	std	Y+3, r24	; 0x03
    48d4:	8b 81       	ldd	r24, Y+3	; 0x03
    48d6:	28 2f       	mov	r18, r24
    48d8:	30 e0       	ldi	r19, 0x00	; 0
    48da:	c9 01       	movw	r24, r18
    48dc:	88 0f       	add	r24, r24
    48de:	99 1f       	adc	r25, r25
    48e0:	88 0f       	add	r24, r24
    48e2:	99 1f       	adc	r25, r25
    48e4:	88 0f       	add	r24, r24
    48e6:	99 1f       	adc	r25, r25
    48e8:	82 0f       	add	r24, r18
    48ea:	93 1f       	adc	r25, r19
    48ec:	fc 01       	movw	r30, r24
    48ee:	e0 5a       	subi	r30, 0xA0	; 160
    48f0:	f9 4f       	sbci	r31, 0xF9	; 249
    48f2:	80 81       	ld	r24, Z
    48f4:	88 23       	and	r24, r24
    48f6:	59 f3       	breq	.-42     	; 0x48ce <vTaskSwitchContext+0x28>
    48f8:	8b 81       	ldd	r24, Y+3	; 0x03
    48fa:	28 2f       	mov	r18, r24
    48fc:	30 e0       	ldi	r19, 0x00	; 0
    48fe:	c9 01       	movw	r24, r18
    4900:	88 0f       	add	r24, r24
    4902:	99 1f       	adc	r25, r25
    4904:	88 0f       	add	r24, r24
    4906:	99 1f       	adc	r25, r25
    4908:	88 0f       	add	r24, r24
    490a:	99 1f       	adc	r25, r25
    490c:	82 0f       	add	r24, r18
    490e:	93 1f       	adc	r25, r19
    4910:	80 5a       	subi	r24, 0xA0	; 160
    4912:	99 4f       	sbci	r25, 0xF9	; 249
    4914:	9a 83       	std	Y+2, r25	; 0x02
    4916:	89 83       	std	Y+1, r24	; 0x01
    4918:	e9 81       	ldd	r30, Y+1	; 0x01
    491a:	fa 81       	ldd	r31, Y+2	; 0x02
    491c:	01 80       	ldd	r0, Z+1	; 0x01
    491e:	f2 81       	ldd	r31, Z+2	; 0x02
    4920:	e0 2d       	mov	r30, r0
    4922:	82 81       	ldd	r24, Z+2	; 0x02
    4924:	93 81       	ldd	r25, Z+3	; 0x03
    4926:	e9 81       	ldd	r30, Y+1	; 0x01
    4928:	fa 81       	ldd	r31, Y+2	; 0x02
    492a:	92 83       	std	Z+2, r25	; 0x02
    492c:	81 83       	std	Z+1, r24	; 0x01
    492e:	e9 81       	ldd	r30, Y+1	; 0x01
    4930:	fa 81       	ldd	r31, Y+2	; 0x02
    4932:	21 81       	ldd	r18, Z+1	; 0x01
    4934:	32 81       	ldd	r19, Z+2	; 0x02
    4936:	89 81       	ldd	r24, Y+1	; 0x01
    4938:	9a 81       	ldd	r25, Y+2	; 0x02
    493a:	03 96       	adiw	r24, 0x03	; 3
    493c:	28 17       	cp	r18, r24
    493e:	39 07       	cpc	r19, r25
    4940:	59 f4       	brne	.+22     	; 0x4958 <vTaskSwitchContext+0xb2>
    4942:	e9 81       	ldd	r30, Y+1	; 0x01
    4944:	fa 81       	ldd	r31, Y+2	; 0x02
    4946:	01 80       	ldd	r0, Z+1	; 0x01
    4948:	f2 81       	ldd	r31, Z+2	; 0x02
    494a:	e0 2d       	mov	r30, r0
    494c:	82 81       	ldd	r24, Z+2	; 0x02
    494e:	93 81       	ldd	r25, Z+3	; 0x03
    4950:	e9 81       	ldd	r30, Y+1	; 0x01
    4952:	fa 81       	ldd	r31, Y+2	; 0x02
    4954:	92 83       	std	Z+2, r25	; 0x02
    4956:	81 83       	std	Z+1, r24	; 0x01
    4958:	e9 81       	ldd	r30, Y+1	; 0x01
    495a:	fa 81       	ldd	r31, Y+2	; 0x02
    495c:	01 80       	ldd	r0, Z+1	; 0x01
    495e:	f2 81       	ldd	r31, Z+2	; 0x02
    4960:	e0 2d       	mov	r30, r0
    4962:	86 81       	ldd	r24, Z+6	; 0x06
    4964:	97 81       	ldd	r25, Z+7	; 0x07
    4966:	90 93 4f 06 	sts	0x064F, r25
    496a:	80 93 4e 06 	sts	0x064E, r24
    496e:	8b 81       	ldd	r24, Y+3	; 0x03
    4970:	80 93 54 06 	sts	0x0654, r24
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
    4974:	0f 90       	pop	r0
    4976:	0f 90       	pop	r0
    4978:	0f 90       	pop	r0
    497a:	cf 91       	pop	r28
    497c:	df 91       	pop	r29
    497e:	08 95       	ret

00004980 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    4980:	df 93       	push	r29
    4982:	cf 93       	push	r28
    4984:	00 d0       	rcall	.+0      	; 0x4986 <vTaskPlaceOnEventList+0x6>
    4986:	00 d0       	rcall	.+0      	; 0x4988 <vTaskPlaceOnEventList+0x8>
    4988:	cd b7       	in	r28, 0x3d	; 61
    498a:	de b7       	in	r29, 0x3e	; 62
    498c:	9a 83       	std	Y+2, r25	; 0x02
    498e:	89 83       	std	Y+1, r24	; 0x01
    4990:	7c 83       	std	Y+4, r23	; 0x04
    4992:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4994:	80 91 4e 06 	lds	r24, 0x064E
    4998:	90 91 4f 06 	lds	r25, 0x064F
    499c:	9c 01       	movw	r18, r24
    499e:	24 5f       	subi	r18, 0xF4	; 244
    49a0:	3f 4f       	sbci	r19, 0xFF	; 255
    49a2:	89 81       	ldd	r24, Y+1	; 0x01
    49a4:	9a 81       	ldd	r25, Y+2	; 0x02
    49a6:	b9 01       	movw	r22, r18
    49a8:	0e 94 66 0d 	call	0x1acc	; 0x1acc <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    49ac:	8b 81       	ldd	r24, Y+3	; 0x03
    49ae:	9c 81       	ldd	r25, Y+4	; 0x04
    49b0:	61 e0       	ldi	r22, 0x01	; 1
    49b2:	0e 94 b3 30 	call	0x6166	; 0x6166 <prvAddCurrentTaskToDelayedList>
}
    49b6:	0f 90       	pop	r0
    49b8:	0f 90       	pop	r0
    49ba:	0f 90       	pop	r0
    49bc:	0f 90       	pop	r0
    49be:	cf 91       	pop	r28
    49c0:	df 91       	pop	r29
    49c2:	08 95       	ret

000049c4 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    49c4:	df 93       	push	r29
    49c6:	cf 93       	push	r28
    49c8:	cd b7       	in	r28, 0x3d	; 61
    49ca:	de b7       	in	r29, 0x3e	; 62
    49cc:	28 97       	sbiw	r28, 0x08	; 8
    49ce:	0f b6       	in	r0, 0x3f	; 63
    49d0:	f8 94       	cli
    49d2:	de bf       	out	0x3e, r29	; 62
    49d4:	0f be       	out	0x3f, r0	; 63
    49d6:	cd bf       	out	0x3d, r28	; 61
    49d8:	9c 83       	std	Y+4, r25	; 0x04
    49da:	8b 83       	std	Y+3, r24	; 0x03
    49dc:	7e 83       	std	Y+6, r23	; 0x06
    49de:	6d 83       	std	Y+5, r22	; 0x05
    49e0:	58 87       	std	Y+8, r21	; 0x08
    49e2:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    49e4:	e0 91 4e 06 	lds	r30, 0x064E
    49e8:	f0 91 4f 06 	lds	r31, 0x064F
    49ec:	8d 81       	ldd	r24, Y+5	; 0x05
    49ee:	9e 81       	ldd	r25, Y+6	; 0x06
    49f0:	90 68       	ori	r25, 0x80	; 128
    49f2:	95 87       	std	Z+13, r25	; 0x0d
    49f4:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    49f6:	eb 81       	ldd	r30, Y+3	; 0x03
    49f8:	fc 81       	ldd	r31, Y+4	; 0x04
    49fa:	81 81       	ldd	r24, Z+1	; 0x01
    49fc:	92 81       	ldd	r25, Z+2	; 0x02
    49fe:	9a 83       	std	Y+2, r25	; 0x02
    4a00:	89 83       	std	Y+1, r24	; 0x01
    4a02:	e0 91 4e 06 	lds	r30, 0x064E
    4a06:	f0 91 4f 06 	lds	r31, 0x064F
    4a0a:	89 81       	ldd	r24, Y+1	; 0x01
    4a0c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a0e:	97 87       	std	Z+15, r25	; 0x0f
    4a10:	86 87       	std	Z+14, r24	; 0x0e
    4a12:	a0 91 4e 06 	lds	r26, 0x064E
    4a16:	b0 91 4f 06 	lds	r27, 0x064F
    4a1a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a1c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a1e:	84 81       	ldd	r24, Z+4	; 0x04
    4a20:	95 81       	ldd	r25, Z+5	; 0x05
    4a22:	51 96       	adiw	r26, 0x11	; 17
    4a24:	9c 93       	st	X, r25
    4a26:	8e 93       	st	-X, r24
    4a28:	50 97       	sbiw	r26, 0x10	; 16
    4a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a2e:	04 80       	ldd	r0, Z+4	; 0x04
    4a30:	f5 81       	ldd	r31, Z+5	; 0x05
    4a32:	e0 2d       	mov	r30, r0
    4a34:	80 91 4e 06 	lds	r24, 0x064E
    4a38:	90 91 4f 06 	lds	r25, 0x064F
    4a3c:	0c 96       	adiw	r24, 0x0c	; 12
    4a3e:	93 83       	std	Z+3, r25	; 0x03
    4a40:	82 83       	std	Z+2, r24	; 0x02
    4a42:	80 91 4e 06 	lds	r24, 0x064E
    4a46:	90 91 4f 06 	lds	r25, 0x064F
    4a4a:	0c 96       	adiw	r24, 0x0c	; 12
    4a4c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a4e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a50:	95 83       	std	Z+5, r25	; 0x05
    4a52:	84 83       	std	Z+4, r24	; 0x04
    4a54:	e0 91 4e 06 	lds	r30, 0x064E
    4a58:	f0 91 4f 06 	lds	r31, 0x064F
    4a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a60:	95 8b       	std	Z+21, r25	; 0x15
    4a62:	84 8b       	std	Z+20, r24	; 0x14
    4a64:	eb 81       	ldd	r30, Y+3	; 0x03
    4a66:	fc 81       	ldd	r31, Y+4	; 0x04
    4a68:	80 81       	ld	r24, Z
    4a6a:	8f 5f       	subi	r24, 0xFF	; 255
    4a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    4a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    4a70:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4a72:	8f 81       	ldd	r24, Y+7	; 0x07
    4a74:	98 85       	ldd	r25, Y+8	; 0x08
    4a76:	61 e0       	ldi	r22, 0x01	; 1
    4a78:	0e 94 b3 30 	call	0x6166	; 0x6166 <prvAddCurrentTaskToDelayedList>
}
    4a7c:	28 96       	adiw	r28, 0x08	; 8
    4a7e:	0f b6       	in	r0, 0x3f	; 63
    4a80:	f8 94       	cli
    4a82:	de bf       	out	0x3e, r29	; 62
    4a84:	0f be       	out	0x3f, r0	; 63
    4a86:	cd bf       	out	0x3d, r28	; 61
    4a88:	cf 91       	pop	r28
    4a8a:	df 91       	pop	r29
    4a8c:	08 95       	ret

00004a8e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4a8e:	df 93       	push	r29
    4a90:	cf 93       	push	r28
    4a92:	cd b7       	in	r28, 0x3d	; 61
    4a94:	de b7       	in	r29, 0x3e	; 62
    4a96:	2d 97       	sbiw	r28, 0x0d	; 13
    4a98:	0f b6       	in	r0, 0x3f	; 63
    4a9a:	f8 94       	cli
    4a9c:	de bf       	out	0x3e, r29	; 62
    4a9e:	0f be       	out	0x3f, r0	; 63
    4aa0:	cd bf       	out	0x3d, r28	; 61
    4aa2:	9d 87       	std	Y+13, r25	; 0x0d
    4aa4:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4aa6:	ec 85       	ldd	r30, Y+12	; 0x0c
    4aa8:	fd 85       	ldd	r31, Y+13	; 0x0d
    4aaa:	05 80       	ldd	r0, Z+5	; 0x05
    4aac:	f6 81       	ldd	r31, Z+6	; 0x06
    4aae:	e0 2d       	mov	r30, r0
    4ab0:	86 81       	ldd	r24, Z+6	; 0x06
    4ab2:	97 81       	ldd	r25, Z+7	; 0x07
    4ab4:	9b 87       	std	Y+11, r25	; 0x0b
    4ab6:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4ab8:	ea 85       	ldd	r30, Y+10	; 0x0a
    4aba:	fb 85       	ldd	r31, Y+11	; 0x0b
    4abc:	84 89       	ldd	r24, Z+20	; 0x14
    4abe:	95 89       	ldd	r25, Z+21	; 0x15
    4ac0:	98 87       	std	Y+8, r25	; 0x08
    4ac2:	8f 83       	std	Y+7, r24	; 0x07
    4ac4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ac6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ac8:	a6 85       	ldd	r26, Z+14	; 0x0e
    4aca:	b7 85       	ldd	r27, Z+15	; 0x0f
    4acc:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ace:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ad0:	80 89       	ldd	r24, Z+16	; 0x10
    4ad2:	91 89       	ldd	r25, Z+17	; 0x11
    4ad4:	15 96       	adiw	r26, 0x05	; 5
    4ad6:	9c 93       	st	X, r25
    4ad8:	8e 93       	st	-X, r24
    4ada:	14 97       	sbiw	r26, 0x04	; 4
    4adc:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ade:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ae0:	a0 89       	ldd	r26, Z+16	; 0x10
    4ae2:	b1 89       	ldd	r27, Z+17	; 0x11
    4ae4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ae6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ae8:	86 85       	ldd	r24, Z+14	; 0x0e
    4aea:	97 85       	ldd	r25, Z+15	; 0x0f
    4aec:	13 96       	adiw	r26, 0x03	; 3
    4aee:	9c 93       	st	X, r25
    4af0:	8e 93       	st	-X, r24
    4af2:	12 97       	sbiw	r26, 0x02	; 2
    4af4:	ef 81       	ldd	r30, Y+7	; 0x07
    4af6:	f8 85       	ldd	r31, Y+8	; 0x08
    4af8:	21 81       	ldd	r18, Z+1	; 0x01
    4afa:	32 81       	ldd	r19, Z+2	; 0x02
    4afc:	8a 85       	ldd	r24, Y+10	; 0x0a
    4afe:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b00:	0c 96       	adiw	r24, 0x0c	; 12
    4b02:	28 17       	cp	r18, r24
    4b04:	39 07       	cpc	r19, r25
    4b06:	41 f4       	brne	.+16     	; 0x4b18 <xTaskRemoveFromEventList+0x8a>
    4b08:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b0a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b0c:	80 89       	ldd	r24, Z+16	; 0x10
    4b0e:	91 89       	ldd	r25, Z+17	; 0x11
    4b10:	ef 81       	ldd	r30, Y+7	; 0x07
    4b12:	f8 85       	ldd	r31, Y+8	; 0x08
    4b14:	92 83       	std	Z+2, r25	; 0x02
    4b16:	81 83       	std	Z+1, r24	; 0x01
    4b18:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b1a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b1c:	15 8a       	std	Z+21, r1	; 0x15
    4b1e:	14 8a       	std	Z+20, r1	; 0x14
    4b20:	ef 81       	ldd	r30, Y+7	; 0x07
    4b22:	f8 85       	ldd	r31, Y+8	; 0x08
    4b24:	80 81       	ld	r24, Z
    4b26:	81 50       	subi	r24, 0x01	; 1
    4b28:	ef 81       	ldd	r30, Y+7	; 0x07
    4b2a:	f8 85       	ldd	r31, Y+8	; 0x08
    4b2c:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b2e:	80 91 5f 06 	lds	r24, 0x065F
    4b32:	88 23       	and	r24, r24
    4b34:	09 f0       	breq	.+2      	; 0x4b38 <xTaskRemoveFromEventList+0xaa>
    4b36:	a4 c0       	rjmp	.+328    	; 0x4c80 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4b38:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b3a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b3c:	82 85       	ldd	r24, Z+10	; 0x0a
    4b3e:	93 85       	ldd	r25, Z+11	; 0x0b
    4b40:	9e 83       	std	Y+6, r25	; 0x06
    4b42:	8d 83       	std	Y+5, r24	; 0x05
    4b44:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b46:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b48:	a4 81       	ldd	r26, Z+4	; 0x04
    4b4a:	b5 81       	ldd	r27, Z+5	; 0x05
    4b4c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b4e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b50:	86 81       	ldd	r24, Z+6	; 0x06
    4b52:	97 81       	ldd	r25, Z+7	; 0x07
    4b54:	15 96       	adiw	r26, 0x05	; 5
    4b56:	9c 93       	st	X, r25
    4b58:	8e 93       	st	-X, r24
    4b5a:	14 97       	sbiw	r26, 0x04	; 4
    4b5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b60:	a6 81       	ldd	r26, Z+6	; 0x06
    4b62:	b7 81       	ldd	r27, Z+7	; 0x07
    4b64:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b66:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b68:	84 81       	ldd	r24, Z+4	; 0x04
    4b6a:	95 81       	ldd	r25, Z+5	; 0x05
    4b6c:	13 96       	adiw	r26, 0x03	; 3
    4b6e:	9c 93       	st	X, r25
    4b70:	8e 93       	st	-X, r24
    4b72:	12 97       	sbiw	r26, 0x02	; 2
    4b74:	ed 81       	ldd	r30, Y+5	; 0x05
    4b76:	fe 81       	ldd	r31, Y+6	; 0x06
    4b78:	21 81       	ldd	r18, Z+1	; 0x01
    4b7a:	32 81       	ldd	r19, Z+2	; 0x02
    4b7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b80:	02 96       	adiw	r24, 0x02	; 2
    4b82:	28 17       	cp	r18, r24
    4b84:	39 07       	cpc	r19, r25
    4b86:	41 f4       	brne	.+16     	; 0x4b98 <xTaskRemoveFromEventList+0x10a>
    4b88:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b8a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b8c:	86 81       	ldd	r24, Z+6	; 0x06
    4b8e:	97 81       	ldd	r25, Z+7	; 0x07
    4b90:	ed 81       	ldd	r30, Y+5	; 0x05
    4b92:	fe 81       	ldd	r31, Y+6	; 0x06
    4b94:	92 83       	std	Z+2, r25	; 0x02
    4b96:	81 83       	std	Z+1, r24	; 0x01
    4b98:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b9a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b9c:	13 86       	std	Z+11, r1	; 0x0b
    4b9e:	12 86       	std	Z+10, r1	; 0x0a
    4ba0:	ed 81       	ldd	r30, Y+5	; 0x05
    4ba2:	fe 81       	ldd	r31, Y+6	; 0x06
    4ba4:	80 81       	ld	r24, Z
    4ba6:	81 50       	subi	r24, 0x01	; 1
    4ba8:	ed 81       	ldd	r30, Y+5	; 0x05
    4baa:	fe 81       	ldd	r31, Y+6	; 0x06
    4bac:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    4bae:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bb0:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bb2:	96 89       	ldd	r25, Z+22	; 0x16
    4bb4:	80 91 54 06 	lds	r24, 0x0654
    4bb8:	89 17       	cp	r24, r25
    4bba:	28 f4       	brcc	.+10     	; 0x4bc6 <xTaskRemoveFromEventList+0x138>
    4bbc:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bbe:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bc0:	86 89       	ldd	r24, Z+22	; 0x16
    4bc2:	80 93 54 06 	sts	0x0654, r24
    4bc6:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bc8:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bca:	86 89       	ldd	r24, Z+22	; 0x16
    4bcc:	28 2f       	mov	r18, r24
    4bce:	30 e0       	ldi	r19, 0x00	; 0
    4bd0:	c9 01       	movw	r24, r18
    4bd2:	88 0f       	add	r24, r24
    4bd4:	99 1f       	adc	r25, r25
    4bd6:	88 0f       	add	r24, r24
    4bd8:	99 1f       	adc	r25, r25
    4bda:	88 0f       	add	r24, r24
    4bdc:	99 1f       	adc	r25, r25
    4bde:	82 0f       	add	r24, r18
    4be0:	93 1f       	adc	r25, r19
    4be2:	fc 01       	movw	r30, r24
    4be4:	e0 5a       	subi	r30, 0xA0	; 160
    4be6:	f9 4f       	sbci	r31, 0xF9	; 249
    4be8:	81 81       	ldd	r24, Z+1	; 0x01
    4bea:	92 81       	ldd	r25, Z+2	; 0x02
    4bec:	9c 83       	std	Y+4, r25	; 0x04
    4bee:	8b 83       	std	Y+3, r24	; 0x03
    4bf0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4bf2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    4bf8:	95 83       	std	Z+5, r25	; 0x05
    4bfa:	84 83       	std	Z+4, r24	; 0x04
    4bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    4bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    4c00:	84 81       	ldd	r24, Z+4	; 0x04
    4c02:	95 81       	ldd	r25, Z+5	; 0x05
    4c04:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c06:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c08:	97 83       	std	Z+7, r25	; 0x07
    4c0a:	86 83       	std	Z+6, r24	; 0x06
    4c0c:	eb 81       	ldd	r30, Y+3	; 0x03
    4c0e:	fc 81       	ldd	r31, Y+4	; 0x04
    4c10:	04 80       	ldd	r0, Z+4	; 0x04
    4c12:	f5 81       	ldd	r31, Z+5	; 0x05
    4c14:	e0 2d       	mov	r30, r0
    4c16:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c18:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c1a:	02 96       	adiw	r24, 0x02	; 2
    4c1c:	93 83       	std	Z+3, r25	; 0x03
    4c1e:	82 83       	std	Z+2, r24	; 0x02
    4c20:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c22:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c24:	02 96       	adiw	r24, 0x02	; 2
    4c26:	eb 81       	ldd	r30, Y+3	; 0x03
    4c28:	fc 81       	ldd	r31, Y+4	; 0x04
    4c2a:	95 83       	std	Z+5, r25	; 0x05
    4c2c:	84 83       	std	Z+4, r24	; 0x04
    4c2e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c30:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c32:	86 89       	ldd	r24, Z+22	; 0x16
    4c34:	28 2f       	mov	r18, r24
    4c36:	30 e0       	ldi	r19, 0x00	; 0
    4c38:	c9 01       	movw	r24, r18
    4c3a:	88 0f       	add	r24, r24
    4c3c:	99 1f       	adc	r25, r25
    4c3e:	88 0f       	add	r24, r24
    4c40:	99 1f       	adc	r25, r25
    4c42:	88 0f       	add	r24, r24
    4c44:	99 1f       	adc	r25, r25
    4c46:	82 0f       	add	r24, r18
    4c48:	93 1f       	adc	r25, r19
    4c4a:	80 5a       	subi	r24, 0xA0	; 160
    4c4c:	99 4f       	sbci	r25, 0xF9	; 249
    4c4e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c50:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c52:	93 87       	std	Z+11, r25	; 0x0b
    4c54:	82 87       	std	Z+10, r24	; 0x0a
    4c56:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c58:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c5a:	86 89       	ldd	r24, Z+22	; 0x16
    4c5c:	28 2f       	mov	r18, r24
    4c5e:	30 e0       	ldi	r19, 0x00	; 0
    4c60:	c9 01       	movw	r24, r18
    4c62:	88 0f       	add	r24, r24
    4c64:	99 1f       	adc	r25, r25
    4c66:	88 0f       	add	r24, r24
    4c68:	99 1f       	adc	r25, r25
    4c6a:	88 0f       	add	r24, r24
    4c6c:	99 1f       	adc	r25, r25
    4c6e:	82 0f       	add	r24, r18
    4c70:	93 1f       	adc	r25, r19
    4c72:	fc 01       	movw	r30, r24
    4c74:	e0 5a       	subi	r30, 0xA0	; 160
    4c76:	f9 4f       	sbci	r31, 0xF9	; 249
    4c78:	80 81       	ld	r24, Z
    4c7a:	8f 5f       	subi	r24, 0xFF	; 255
    4c7c:	80 83       	st	Z, r24
    4c7e:	30 c0       	rjmp	.+96     	; 0x4ce0 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4c80:	80 91 9b 06 	lds	r24, 0x069B
    4c84:	90 91 9c 06 	lds	r25, 0x069C
    4c88:	9a 83       	std	Y+2, r25	; 0x02
    4c8a:	89 83       	std	Y+1, r24	; 0x01
    4c8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c90:	89 81       	ldd	r24, Y+1	; 0x01
    4c92:	9a 81       	ldd	r25, Y+2	; 0x02
    4c94:	97 87       	std	Z+15, r25	; 0x0f
    4c96:	86 87       	std	Z+14, r24	; 0x0e
    4c98:	e9 81       	ldd	r30, Y+1	; 0x01
    4c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c9c:	84 81       	ldd	r24, Z+4	; 0x04
    4c9e:	95 81       	ldd	r25, Z+5	; 0x05
    4ca0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ca2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ca4:	91 8b       	std	Z+17, r25	; 0x11
    4ca6:	80 8b       	std	Z+16, r24	; 0x10
    4ca8:	e9 81       	ldd	r30, Y+1	; 0x01
    4caa:	fa 81       	ldd	r31, Y+2	; 0x02
    4cac:	04 80       	ldd	r0, Z+4	; 0x04
    4cae:	f5 81       	ldd	r31, Z+5	; 0x05
    4cb0:	e0 2d       	mov	r30, r0
    4cb2:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cb4:	9b 85       	ldd	r25, Y+11	; 0x0b
    4cb6:	0c 96       	adiw	r24, 0x0c	; 12
    4cb8:	93 83       	std	Z+3, r25	; 0x03
    4cba:	82 83       	std	Z+2, r24	; 0x02
    4cbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cbe:	9b 85       	ldd	r25, Y+11	; 0x0b
    4cc0:	0c 96       	adiw	r24, 0x0c	; 12
    4cc2:	e9 81       	ldd	r30, Y+1	; 0x01
    4cc4:	fa 81       	ldd	r31, Y+2	; 0x02
    4cc6:	95 83       	std	Z+5, r25	; 0x05
    4cc8:	84 83       	std	Z+4, r24	; 0x04
    4cca:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ccc:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cce:	8a e9       	ldi	r24, 0x9A	; 154
    4cd0:	96 e0       	ldi	r25, 0x06	; 6
    4cd2:	95 8b       	std	Z+21, r25	; 0x15
    4cd4:	84 8b       	std	Z+20, r24	; 0x14
    4cd6:	80 91 9a 06 	lds	r24, 0x069A
    4cda:	8f 5f       	subi	r24, 0xFF	; 255
    4cdc:	80 93 9a 06 	sts	0x069A, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ce0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ce2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ce4:	96 89       	ldd	r25, Z+22	; 0x16
    4ce6:	e0 91 4e 06 	lds	r30, 0x064E
    4cea:	f0 91 4f 06 	lds	r31, 0x064F
    4cee:	86 89       	ldd	r24, Z+22	; 0x16
    4cf0:	89 17       	cp	r24, r25
    4cf2:	30 f4       	brcc	.+12     	; 0x4d00 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    4cf4:	81 e0       	ldi	r24, 0x01	; 1
    4cf6:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4cf8:	81 e0       	ldi	r24, 0x01	; 1
    4cfa:	80 93 58 06 	sts	0x0658, r24
    4cfe:	01 c0       	rjmp	.+2      	; 0x4d02 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    4d00:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    4d02:	89 85       	ldd	r24, Y+9	; 0x09
}
    4d04:	2d 96       	adiw	r28, 0x0d	; 13
    4d06:	0f b6       	in	r0, 0x3f	; 63
    4d08:	f8 94       	cli
    4d0a:	de bf       	out	0x3e, r29	; 62
    4d0c:	0f be       	out	0x3f, r0	; 63
    4d0e:	cd bf       	out	0x3d, r28	; 61
    4d10:	cf 91       	pop	r28
    4d12:	df 91       	pop	r29
    4d14:	08 95       	ret

00004d16 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4d16:	df 93       	push	r29
    4d18:	cf 93       	push	r28
    4d1a:	cd b7       	in	r28, 0x3d	; 61
    4d1c:	de b7       	in	r29, 0x3e	; 62
    4d1e:	2c 97       	sbiw	r28, 0x0c	; 12
    4d20:	0f b6       	in	r0, 0x3f	; 63
    4d22:	f8 94       	cli
    4d24:	de bf       	out	0x3e, r29	; 62
    4d26:	0f be       	out	0x3f, r0	; 63
    4d28:	cd bf       	out	0x3d, r28	; 61
    4d2a:	9a 87       	std	Y+10, r25	; 0x0a
    4d2c:	89 87       	std	Y+9, r24	; 0x09
    4d2e:	7c 87       	std	Y+12, r23	; 0x0c
    4d30:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4d32:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d34:	9c 85       	ldd	r25, Y+12	; 0x0c
    4d36:	90 68       	ori	r25, 0x80	; 128
    4d38:	e9 85       	ldd	r30, Y+9	; 0x09
    4d3a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d3c:	91 83       	std	Z+1, r25	; 0x01
    4d3e:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d40:	e9 85       	ldd	r30, Y+9	; 0x09
    4d42:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d44:	86 81       	ldd	r24, Z+6	; 0x06
    4d46:	97 81       	ldd	r25, Z+7	; 0x07
    4d48:	98 87       	std	Y+8, r25	; 0x08
    4d4a:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4d4c:	e9 85       	ldd	r30, Y+9	; 0x09
    4d4e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d50:	80 85       	ldd	r24, Z+8	; 0x08
    4d52:	91 85       	ldd	r25, Z+9	; 0x09
    4d54:	9e 83       	std	Y+6, r25	; 0x06
    4d56:	8d 83       	std	Y+5, r24	; 0x05
    4d58:	e9 85       	ldd	r30, Y+9	; 0x09
    4d5a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d5c:	a2 81       	ldd	r26, Z+2	; 0x02
    4d5e:	b3 81       	ldd	r27, Z+3	; 0x03
    4d60:	e9 85       	ldd	r30, Y+9	; 0x09
    4d62:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d64:	84 81       	ldd	r24, Z+4	; 0x04
    4d66:	95 81       	ldd	r25, Z+5	; 0x05
    4d68:	15 96       	adiw	r26, 0x05	; 5
    4d6a:	9c 93       	st	X, r25
    4d6c:	8e 93       	st	-X, r24
    4d6e:	14 97       	sbiw	r26, 0x04	; 4
    4d70:	e9 85       	ldd	r30, Y+9	; 0x09
    4d72:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d74:	a4 81       	ldd	r26, Z+4	; 0x04
    4d76:	b5 81       	ldd	r27, Z+5	; 0x05
    4d78:	e9 85       	ldd	r30, Y+9	; 0x09
    4d7a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d7c:	82 81       	ldd	r24, Z+2	; 0x02
    4d7e:	93 81       	ldd	r25, Z+3	; 0x03
    4d80:	13 96       	adiw	r26, 0x03	; 3
    4d82:	9c 93       	st	X, r25
    4d84:	8e 93       	st	-X, r24
    4d86:	12 97       	sbiw	r26, 0x02	; 2
    4d88:	ed 81       	ldd	r30, Y+5	; 0x05
    4d8a:	fe 81       	ldd	r31, Y+6	; 0x06
    4d8c:	21 81       	ldd	r18, Z+1	; 0x01
    4d8e:	32 81       	ldd	r19, Z+2	; 0x02
    4d90:	89 85       	ldd	r24, Y+9	; 0x09
    4d92:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d94:	28 17       	cp	r18, r24
    4d96:	39 07       	cpc	r19, r25
    4d98:	41 f4       	brne	.+16     	; 0x4daa <vTaskRemoveFromUnorderedEventList+0x94>
    4d9a:	e9 85       	ldd	r30, Y+9	; 0x09
    4d9c:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d9e:	84 81       	ldd	r24, Z+4	; 0x04
    4da0:	95 81       	ldd	r25, Z+5	; 0x05
    4da2:	ed 81       	ldd	r30, Y+5	; 0x05
    4da4:	fe 81       	ldd	r31, Y+6	; 0x06
    4da6:	92 83       	std	Z+2, r25	; 0x02
    4da8:	81 83       	std	Z+1, r24	; 0x01
    4daa:	e9 85       	ldd	r30, Y+9	; 0x09
    4dac:	fa 85       	ldd	r31, Y+10	; 0x0a
    4dae:	11 86       	std	Z+9, r1	; 0x09
    4db0:	10 86       	std	Z+8, r1	; 0x08
    4db2:	ed 81       	ldd	r30, Y+5	; 0x05
    4db4:	fe 81       	ldd	r31, Y+6	; 0x06
    4db6:	80 81       	ld	r24, Z
    4db8:	81 50       	subi	r24, 0x01	; 1
    4dba:	ed 81       	ldd	r30, Y+5	; 0x05
    4dbc:	fe 81       	ldd	r31, Y+6	; 0x06
    4dbe:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4dc0:	ef 81       	ldd	r30, Y+7	; 0x07
    4dc2:	f8 85       	ldd	r31, Y+8	; 0x08
    4dc4:	82 85       	ldd	r24, Z+10	; 0x0a
    4dc6:	93 85       	ldd	r25, Z+11	; 0x0b
    4dc8:	9c 83       	std	Y+4, r25	; 0x04
    4dca:	8b 83       	std	Y+3, r24	; 0x03
    4dcc:	ef 81       	ldd	r30, Y+7	; 0x07
    4dce:	f8 85       	ldd	r31, Y+8	; 0x08
    4dd0:	a4 81       	ldd	r26, Z+4	; 0x04
    4dd2:	b5 81       	ldd	r27, Z+5	; 0x05
    4dd4:	ef 81       	ldd	r30, Y+7	; 0x07
    4dd6:	f8 85       	ldd	r31, Y+8	; 0x08
    4dd8:	86 81       	ldd	r24, Z+6	; 0x06
    4dda:	97 81       	ldd	r25, Z+7	; 0x07
    4ddc:	15 96       	adiw	r26, 0x05	; 5
    4dde:	9c 93       	st	X, r25
    4de0:	8e 93       	st	-X, r24
    4de2:	14 97       	sbiw	r26, 0x04	; 4
    4de4:	ef 81       	ldd	r30, Y+7	; 0x07
    4de6:	f8 85       	ldd	r31, Y+8	; 0x08
    4de8:	a6 81       	ldd	r26, Z+6	; 0x06
    4dea:	b7 81       	ldd	r27, Z+7	; 0x07
    4dec:	ef 81       	ldd	r30, Y+7	; 0x07
    4dee:	f8 85       	ldd	r31, Y+8	; 0x08
    4df0:	84 81       	ldd	r24, Z+4	; 0x04
    4df2:	95 81       	ldd	r25, Z+5	; 0x05
    4df4:	13 96       	adiw	r26, 0x03	; 3
    4df6:	9c 93       	st	X, r25
    4df8:	8e 93       	st	-X, r24
    4dfa:	12 97       	sbiw	r26, 0x02	; 2
    4dfc:	eb 81       	ldd	r30, Y+3	; 0x03
    4dfe:	fc 81       	ldd	r31, Y+4	; 0x04
    4e00:	21 81       	ldd	r18, Z+1	; 0x01
    4e02:	32 81       	ldd	r19, Z+2	; 0x02
    4e04:	8f 81       	ldd	r24, Y+7	; 0x07
    4e06:	98 85       	ldd	r25, Y+8	; 0x08
    4e08:	02 96       	adiw	r24, 0x02	; 2
    4e0a:	28 17       	cp	r18, r24
    4e0c:	39 07       	cpc	r19, r25
    4e0e:	41 f4       	brne	.+16     	; 0x4e20 <vTaskRemoveFromUnorderedEventList+0x10a>
    4e10:	ef 81       	ldd	r30, Y+7	; 0x07
    4e12:	f8 85       	ldd	r31, Y+8	; 0x08
    4e14:	86 81       	ldd	r24, Z+6	; 0x06
    4e16:	97 81       	ldd	r25, Z+7	; 0x07
    4e18:	eb 81       	ldd	r30, Y+3	; 0x03
    4e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e1c:	92 83       	std	Z+2, r25	; 0x02
    4e1e:	81 83       	std	Z+1, r24	; 0x01
    4e20:	ef 81       	ldd	r30, Y+7	; 0x07
    4e22:	f8 85       	ldd	r31, Y+8	; 0x08
    4e24:	13 86       	std	Z+11, r1	; 0x0b
    4e26:	12 86       	std	Z+10, r1	; 0x0a
    4e28:	eb 81       	ldd	r30, Y+3	; 0x03
    4e2a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e2c:	80 81       	ld	r24, Z
    4e2e:	81 50       	subi	r24, 0x01	; 1
    4e30:	eb 81       	ldd	r30, Y+3	; 0x03
    4e32:	fc 81       	ldd	r31, Y+4	; 0x04
    4e34:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4e36:	ef 81       	ldd	r30, Y+7	; 0x07
    4e38:	f8 85       	ldd	r31, Y+8	; 0x08
    4e3a:	96 89       	ldd	r25, Z+22	; 0x16
    4e3c:	80 91 54 06 	lds	r24, 0x0654
    4e40:	89 17       	cp	r24, r25
    4e42:	28 f4       	brcc	.+10     	; 0x4e4e <vTaskRemoveFromUnorderedEventList+0x138>
    4e44:	ef 81       	ldd	r30, Y+7	; 0x07
    4e46:	f8 85       	ldd	r31, Y+8	; 0x08
    4e48:	86 89       	ldd	r24, Z+22	; 0x16
    4e4a:	80 93 54 06 	sts	0x0654, r24
    4e4e:	ef 81       	ldd	r30, Y+7	; 0x07
    4e50:	f8 85       	ldd	r31, Y+8	; 0x08
    4e52:	86 89       	ldd	r24, Z+22	; 0x16
    4e54:	28 2f       	mov	r18, r24
    4e56:	30 e0       	ldi	r19, 0x00	; 0
    4e58:	c9 01       	movw	r24, r18
    4e5a:	88 0f       	add	r24, r24
    4e5c:	99 1f       	adc	r25, r25
    4e5e:	88 0f       	add	r24, r24
    4e60:	99 1f       	adc	r25, r25
    4e62:	88 0f       	add	r24, r24
    4e64:	99 1f       	adc	r25, r25
    4e66:	82 0f       	add	r24, r18
    4e68:	93 1f       	adc	r25, r19
    4e6a:	fc 01       	movw	r30, r24
    4e6c:	e0 5a       	subi	r30, 0xA0	; 160
    4e6e:	f9 4f       	sbci	r31, 0xF9	; 249
    4e70:	81 81       	ldd	r24, Z+1	; 0x01
    4e72:	92 81       	ldd	r25, Z+2	; 0x02
    4e74:	9a 83       	std	Y+2, r25	; 0x02
    4e76:	89 83       	std	Y+1, r24	; 0x01
    4e78:	ef 81       	ldd	r30, Y+7	; 0x07
    4e7a:	f8 85       	ldd	r31, Y+8	; 0x08
    4e7c:	89 81       	ldd	r24, Y+1	; 0x01
    4e7e:	9a 81       	ldd	r25, Y+2	; 0x02
    4e80:	95 83       	std	Z+5, r25	; 0x05
    4e82:	84 83       	std	Z+4, r24	; 0x04
    4e84:	e9 81       	ldd	r30, Y+1	; 0x01
    4e86:	fa 81       	ldd	r31, Y+2	; 0x02
    4e88:	84 81       	ldd	r24, Z+4	; 0x04
    4e8a:	95 81       	ldd	r25, Z+5	; 0x05
    4e8c:	ef 81       	ldd	r30, Y+7	; 0x07
    4e8e:	f8 85       	ldd	r31, Y+8	; 0x08
    4e90:	97 83       	std	Z+7, r25	; 0x07
    4e92:	86 83       	std	Z+6, r24	; 0x06
    4e94:	e9 81       	ldd	r30, Y+1	; 0x01
    4e96:	fa 81       	ldd	r31, Y+2	; 0x02
    4e98:	04 80       	ldd	r0, Z+4	; 0x04
    4e9a:	f5 81       	ldd	r31, Z+5	; 0x05
    4e9c:	e0 2d       	mov	r30, r0
    4e9e:	8f 81       	ldd	r24, Y+7	; 0x07
    4ea0:	98 85       	ldd	r25, Y+8	; 0x08
    4ea2:	02 96       	adiw	r24, 0x02	; 2
    4ea4:	93 83       	std	Z+3, r25	; 0x03
    4ea6:	82 83       	std	Z+2, r24	; 0x02
    4ea8:	8f 81       	ldd	r24, Y+7	; 0x07
    4eaa:	98 85       	ldd	r25, Y+8	; 0x08
    4eac:	02 96       	adiw	r24, 0x02	; 2
    4eae:	e9 81       	ldd	r30, Y+1	; 0x01
    4eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    4eb2:	95 83       	std	Z+5, r25	; 0x05
    4eb4:	84 83       	std	Z+4, r24	; 0x04
    4eb6:	ef 81       	ldd	r30, Y+7	; 0x07
    4eb8:	f8 85       	ldd	r31, Y+8	; 0x08
    4eba:	86 89       	ldd	r24, Z+22	; 0x16
    4ebc:	28 2f       	mov	r18, r24
    4ebe:	30 e0       	ldi	r19, 0x00	; 0
    4ec0:	c9 01       	movw	r24, r18
    4ec2:	88 0f       	add	r24, r24
    4ec4:	99 1f       	adc	r25, r25
    4ec6:	88 0f       	add	r24, r24
    4ec8:	99 1f       	adc	r25, r25
    4eca:	88 0f       	add	r24, r24
    4ecc:	99 1f       	adc	r25, r25
    4ece:	82 0f       	add	r24, r18
    4ed0:	93 1f       	adc	r25, r19
    4ed2:	80 5a       	subi	r24, 0xA0	; 160
    4ed4:	99 4f       	sbci	r25, 0xF9	; 249
    4ed6:	ef 81       	ldd	r30, Y+7	; 0x07
    4ed8:	f8 85       	ldd	r31, Y+8	; 0x08
    4eda:	93 87       	std	Z+11, r25	; 0x0b
    4edc:	82 87       	std	Z+10, r24	; 0x0a
    4ede:	ef 81       	ldd	r30, Y+7	; 0x07
    4ee0:	f8 85       	ldd	r31, Y+8	; 0x08
    4ee2:	86 89       	ldd	r24, Z+22	; 0x16
    4ee4:	28 2f       	mov	r18, r24
    4ee6:	30 e0       	ldi	r19, 0x00	; 0
    4ee8:	c9 01       	movw	r24, r18
    4eea:	88 0f       	add	r24, r24
    4eec:	99 1f       	adc	r25, r25
    4eee:	88 0f       	add	r24, r24
    4ef0:	99 1f       	adc	r25, r25
    4ef2:	88 0f       	add	r24, r24
    4ef4:	99 1f       	adc	r25, r25
    4ef6:	82 0f       	add	r24, r18
    4ef8:	93 1f       	adc	r25, r19
    4efa:	fc 01       	movw	r30, r24
    4efc:	e0 5a       	subi	r30, 0xA0	; 160
    4efe:	f9 4f       	sbci	r31, 0xF9	; 249
    4f00:	80 81       	ld	r24, Z
    4f02:	8f 5f       	subi	r24, 0xFF	; 255
    4f04:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f06:	ef 81       	ldd	r30, Y+7	; 0x07
    4f08:	f8 85       	ldd	r31, Y+8	; 0x08
    4f0a:	96 89       	ldd	r25, Z+22	; 0x16
    4f0c:	e0 91 4e 06 	lds	r30, 0x064E
    4f10:	f0 91 4f 06 	lds	r31, 0x064F
    4f14:	86 89       	ldd	r24, Z+22	; 0x16
    4f16:	89 17       	cp	r24, r25
    4f18:	18 f4       	brcc	.+6      	; 0x4f20 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4f1a:	81 e0       	ldi	r24, 0x01	; 1
    4f1c:	80 93 58 06 	sts	0x0658, r24
    }
}
    4f20:	2c 96       	adiw	r28, 0x0c	; 12
    4f22:	0f b6       	in	r0, 0x3f	; 63
    4f24:	f8 94       	cli
    4f26:	de bf       	out	0x3e, r29	; 62
    4f28:	0f be       	out	0x3f, r0	; 63
    4f2a:	cd bf       	out	0x3d, r28	; 61
    4f2c:	cf 91       	pop	r28
    4f2e:	df 91       	pop	r29
    4f30:	08 95       	ret

00004f32 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4f32:	df 93       	push	r29
    4f34:	cf 93       	push	r28
    4f36:	00 d0       	rcall	.+0      	; 0x4f38 <vTaskSetTimeOutState+0x6>
    4f38:	cd b7       	in	r28, 0x3d	; 61
    4f3a:	de b7       	in	r29, 0x3e	; 62
    4f3c:	9a 83       	std	Y+2, r25	; 0x02
    4f3e:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4f40:	0f b6       	in	r0, 0x3f	; 63
    4f42:	f8 94       	cli
    4f44:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4f46:	80 91 59 06 	lds	r24, 0x0659
    4f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f4e:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4f50:	80 91 52 06 	lds	r24, 0x0652
    4f54:	90 91 53 06 	lds	r25, 0x0653
    4f58:	e9 81       	ldd	r30, Y+1	; 0x01
    4f5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f5c:	92 83       	std	Z+2, r25	; 0x02
    4f5e:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4f60:	0f 90       	pop	r0
    4f62:	0f be       	out	0x3f, r0	; 63
}
    4f64:	0f 90       	pop	r0
    4f66:	0f 90       	pop	r0
    4f68:	cf 91       	pop	r28
    4f6a:	df 91       	pop	r29
    4f6c:	08 95       	ret

00004f6e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4f6e:	df 93       	push	r29
    4f70:	cf 93       	push	r28
    4f72:	00 d0       	rcall	.+0      	; 0x4f74 <vTaskInternalSetTimeOutState+0x6>
    4f74:	cd b7       	in	r28, 0x3d	; 61
    4f76:	de b7       	in	r29, 0x3e	; 62
    4f78:	9a 83       	std	Y+2, r25	; 0x02
    4f7a:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4f7c:	80 91 59 06 	lds	r24, 0x0659
    4f80:	e9 81       	ldd	r30, Y+1	; 0x01
    4f82:	fa 81       	ldd	r31, Y+2	; 0x02
    4f84:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4f86:	80 91 52 06 	lds	r24, 0x0652
    4f8a:	90 91 53 06 	lds	r25, 0x0653
    4f8e:	e9 81       	ldd	r30, Y+1	; 0x01
    4f90:	fa 81       	ldd	r31, Y+2	; 0x02
    4f92:	92 83       	std	Z+2, r25	; 0x02
    4f94:	81 83       	std	Z+1, r24	; 0x01
}
    4f96:	0f 90       	pop	r0
    4f98:	0f 90       	pop	r0
    4f9a:	cf 91       	pop	r28
    4f9c:	df 91       	pop	r29
    4f9e:	08 95       	ret

00004fa0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4fa0:	df 93       	push	r29
    4fa2:	cf 93       	push	r28
    4fa4:	cd b7       	in	r28, 0x3d	; 61
    4fa6:	de b7       	in	r29, 0x3e	; 62
    4fa8:	29 97       	sbiw	r28, 0x09	; 9
    4faa:	0f b6       	in	r0, 0x3f	; 63
    4fac:	f8 94       	cli
    4fae:	de bf       	out	0x3e, r29	; 62
    4fb0:	0f be       	out	0x3f, r0	; 63
    4fb2:	cd bf       	out	0x3d, r28	; 61
    4fb4:	9f 83       	std	Y+7, r25	; 0x07
    4fb6:	8e 83       	std	Y+6, r24	; 0x06
    4fb8:	79 87       	std	Y+9, r23	; 0x09
    4fba:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4fbc:	0f b6       	in	r0, 0x3f	; 63
    4fbe:	f8 94       	cli
    4fc0:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4fc2:	80 91 52 06 	lds	r24, 0x0652
    4fc6:	90 91 53 06 	lds	r25, 0x0653
    4fca:	9c 83       	std	Y+4, r25	; 0x04
    4fcc:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4fce:	ee 81       	ldd	r30, Y+6	; 0x06
    4fd0:	ff 81       	ldd	r31, Y+7	; 0x07
    4fd2:	21 81       	ldd	r18, Z+1	; 0x01
    4fd4:	32 81       	ldd	r19, Z+2	; 0x02
    4fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    4fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    4fda:	82 1b       	sub	r24, r18
    4fdc:	93 0b       	sbc	r25, r19
    4fde:	9a 83       	std	Y+2, r25	; 0x02
    4fe0:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4fe2:	ee 81       	ldd	r30, Y+6	; 0x06
    4fe4:	ff 81       	ldd	r31, Y+7	; 0x07
    4fe6:	90 81       	ld	r25, Z
    4fe8:	80 91 59 06 	lds	r24, 0x0659
    4fec:	98 17       	cp	r25, r24
    4fee:	81 f0       	breq	.+32     	; 0x5010 <xTaskCheckForTimeOut+0x70>
    4ff0:	ee 81       	ldd	r30, Y+6	; 0x06
    4ff2:	ff 81       	ldd	r31, Y+7	; 0x07
    4ff4:	21 81       	ldd	r18, Z+1	; 0x01
    4ff6:	32 81       	ldd	r19, Z+2	; 0x02
    4ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    4ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    4ffc:	82 17       	cp	r24, r18
    4ffe:	93 07       	cpc	r25, r19
    5000:	38 f0       	brcs	.+14     	; 0x5010 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    5002:	81 e0       	ldi	r24, 0x01	; 1
    5004:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    5006:	e8 85       	ldd	r30, Y+8	; 0x08
    5008:	f9 85       	ldd	r31, Y+9	; 0x09
    500a:	11 82       	std	Z+1, r1	; 0x01
    500c:	10 82       	st	Z, r1
    500e:	23 c0       	rjmp	.+70     	; 0x5056 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5010:	e8 85       	ldd	r30, Y+8	; 0x08
    5012:	f9 85       	ldd	r31, Y+9	; 0x09
    5014:	20 81       	ld	r18, Z
    5016:	31 81       	ldd	r19, Z+1	; 0x01
    5018:	89 81       	ldd	r24, Y+1	; 0x01
    501a:	9a 81       	ldd	r25, Y+2	; 0x02
    501c:	82 17       	cp	r24, r18
    501e:	93 07       	cpc	r25, r19
    5020:	a0 f4       	brcc	.+40     	; 0x504a <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    5022:	e8 85       	ldd	r30, Y+8	; 0x08
    5024:	f9 85       	ldd	r31, Y+9	; 0x09
    5026:	20 81       	ld	r18, Z
    5028:	31 81       	ldd	r19, Z+1	; 0x01
    502a:	89 81       	ldd	r24, Y+1	; 0x01
    502c:	9a 81       	ldd	r25, Y+2	; 0x02
    502e:	a9 01       	movw	r20, r18
    5030:	48 1b       	sub	r20, r24
    5032:	59 0b       	sbc	r21, r25
    5034:	ca 01       	movw	r24, r20
    5036:	e8 85       	ldd	r30, Y+8	; 0x08
    5038:	f9 85       	ldd	r31, Y+9	; 0x09
    503a:	91 83       	std	Z+1, r25	; 0x01
    503c:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    503e:	8e 81       	ldd	r24, Y+6	; 0x06
    5040:	9f 81       	ldd	r25, Y+7	; 0x07
    5042:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    5046:	1d 82       	std	Y+5, r1	; 0x05
    5048:	06 c0       	rjmp	.+12     	; 0x5056 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    504a:	e8 85       	ldd	r30, Y+8	; 0x08
    504c:	f9 85       	ldd	r31, Y+9	; 0x09
    504e:	11 82       	std	Z+1, r1	; 0x01
    5050:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    5052:	81 e0       	ldi	r24, 0x01	; 1
    5054:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    5056:	0f 90       	pop	r0
    5058:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    505a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    505c:	29 96       	adiw	r28, 0x09	; 9
    505e:	0f b6       	in	r0, 0x3f	; 63
    5060:	f8 94       	cli
    5062:	de bf       	out	0x3e, r29	; 62
    5064:	0f be       	out	0x3f, r0	; 63
    5066:	cd bf       	out	0x3d, r28	; 61
    5068:	cf 91       	pop	r28
    506a:	df 91       	pop	r29
    506c:	08 95       	ret

0000506e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    506e:	df 93       	push	r29
    5070:	cf 93       	push	r28
    5072:	cd b7       	in	r28, 0x3d	; 61
    5074:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    5076:	81 e0       	ldi	r24, 0x01	; 1
    5078:	80 93 58 06 	sts	0x0658, r24
}
    507c:	cf 91       	pop	r28
    507e:	df 91       	pop	r29
    5080:	08 95       	ret

00005082 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5082:	df 93       	push	r29
    5084:	cf 93       	push	r28
    5086:	00 d0       	rcall	.+0      	; 0x5088 <prvIdleTask+0x6>
    5088:	cd b7       	in	r28, 0x3d	; 61
    508a:	de b7       	in	r29, 0x3e	; 62
    508c:	9a 83       	std	Y+2, r25	; 0x02
    508e:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    5090:	0e 94 8e 28 	call	0x511c	; 0x511c <prvCheckTasksWaitingTermination>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5094:	80 91 60 06 	lds	r24, 0x0660
    5098:	82 30       	cpi	r24, 0x02	; 2
    509a:	d0 f3       	brcs	.-12     	; 0x5090 <prvIdleTask+0xe>
            {
                taskYIELD();
    509c:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
    50a0:	f7 cf       	rjmp	.-18     	; 0x5090 <prvIdleTask+0xe>

000050a2 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    50a2:	df 93       	push	r29
    50a4:	cf 93       	push	r28
    50a6:	0f 92       	push	r0
    50a8:	cd b7       	in	r28, 0x3d	; 61
    50aa:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    50ac:	19 82       	std	Y+1, r1	; 0x01
    50ae:	13 c0       	rjmp	.+38     	; 0x50d6 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    50b0:	89 81       	ldd	r24, Y+1	; 0x01
    50b2:	28 2f       	mov	r18, r24
    50b4:	30 e0       	ldi	r19, 0x00	; 0
    50b6:	c9 01       	movw	r24, r18
    50b8:	88 0f       	add	r24, r24
    50ba:	99 1f       	adc	r25, r25
    50bc:	88 0f       	add	r24, r24
    50be:	99 1f       	adc	r25, r25
    50c0:	88 0f       	add	r24, r24
    50c2:	99 1f       	adc	r25, r25
    50c4:	82 0f       	add	r24, r18
    50c6:	93 1f       	adc	r25, r19
    50c8:	80 5a       	subi	r24, 0xA0	; 160
    50ca:	99 4f       	sbci	r25, 0xF9	; 249
    50cc:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    50d0:	89 81       	ldd	r24, Y+1	; 0x01
    50d2:	8f 5f       	subi	r24, 0xFF	; 255
    50d4:	89 83       	std	Y+1, r24	; 0x01
    50d6:	89 81       	ldd	r24, Y+1	; 0x01
    50d8:	84 30       	cpi	r24, 0x04	; 4
    50da:	50 f3       	brcs	.-44     	; 0x50b0 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    50dc:	84 e8       	ldi	r24, 0x84	; 132
    50de:	96 e0       	ldi	r25, 0x06	; 6
    50e0:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    50e4:	8d e8       	ldi	r24, 0x8D	; 141
    50e6:	96 e0       	ldi	r25, 0x06	; 6
    50e8:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    50ec:	8a e9       	ldi	r24, 0x9A	; 154
    50ee:	96 e0       	ldi	r25, 0x06	; 6
    50f0:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    50f4:	83 ea       	ldi	r24, 0xA3	; 163
    50f6:	96 e0       	ldi	r25, 0x06	; 6
    50f8:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    50fc:	84 e8       	ldi	r24, 0x84	; 132
    50fe:	96 e0       	ldi	r25, 0x06	; 6
    5100:	90 93 97 06 	sts	0x0697, r25
    5104:	80 93 96 06 	sts	0x0696, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5108:	8d e8       	ldi	r24, 0x8D	; 141
    510a:	96 e0       	ldi	r25, 0x06	; 6
    510c:	90 93 99 06 	sts	0x0699, r25
    5110:	80 93 98 06 	sts	0x0698, r24
}
    5114:	0f 90       	pop	r0
    5116:	cf 91       	pop	r28
    5118:	df 91       	pop	r29
    511a:	08 95       	ret

0000511c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    511c:	df 93       	push	r29
    511e:	cf 93       	push	r28
    5120:	00 d0       	rcall	.+0      	; 0x5122 <prvCheckTasksWaitingTermination+0x6>
    5122:	cd b7       	in	r28, 0x3d	; 61
    5124:	de b7       	in	r29, 0x3e	; 62
    5126:	20 c0       	rjmp	.+64     	; 0x5168 <prvCheckTasksWaitingTermination+0x4c>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    5128:	0f b6       	in	r0, 0x3f	; 63
    512a:	f8 94       	cli
    512c:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    512e:	e0 91 a8 06 	lds	r30, 0x06A8
    5132:	f0 91 a9 06 	lds	r31, 0x06A9
    5136:	86 81       	ldd	r24, Z+6	; 0x06
    5138:	97 81       	ldd	r25, Z+7	; 0x07
    513a:	9a 83       	std	Y+2, r25	; 0x02
    513c:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    513e:	89 81       	ldd	r24, Y+1	; 0x01
    5140:	9a 81       	ldd	r25, Y+2	; 0x02
    5142:	02 96       	adiw	r24, 0x02	; 2
    5144:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <uxListRemove>
                --uxCurrentNumberOfTasks;
    5148:	80 91 51 06 	lds	r24, 0x0651
    514c:	81 50       	subi	r24, 0x01	; 1
    514e:	80 93 51 06 	sts	0x0651, r24
                --uxDeletedTasksWaitingCleanUp;
    5152:	80 91 50 06 	lds	r24, 0x0650
    5156:	81 50       	subi	r24, 0x01	; 1
    5158:	80 93 50 06 	sts	0x0650, r24
            }
            taskEXIT_CRITICAL();
    515c:	0f 90       	pop	r0
    515e:	0f be       	out	0x3f, r0	; 63

            prvDeleteTCB( pxTCB );
    5160:	89 81       	ldd	r24, Y+1	; 0x01
    5162:	9a 81       	ldd	r25, Y+2	; 0x02
    5164:	0e 94 bd 28 	call	0x517a	; 0x517a <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5168:	80 91 50 06 	lds	r24, 0x0650
    516c:	88 23       	and	r24, r24
    516e:	e1 f6       	brne	.-72     	; 0x5128 <prvCheckTasksWaitingTermination+0xc>

            prvDeleteTCB( pxTCB );
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    5170:	0f 90       	pop	r0
    5172:	0f 90       	pop	r0
    5174:	cf 91       	pop	r28
    5176:	df 91       	pop	r29
    5178:	08 95       	ret

0000517a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    517a:	df 93       	push	r29
    517c:	cf 93       	push	r28
    517e:	00 d0       	rcall	.+0      	; 0x5180 <prvDeleteTCB+0x6>
    5180:	cd b7       	in	r28, 0x3d	; 61
    5182:	de b7       	in	r29, 0x3e	; 62
    5184:	9a 83       	std	Y+2, r25	; 0x02
    5186:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    5188:	e9 81       	ldd	r30, Y+1	; 0x01
    518a:	fa 81       	ldd	r31, Y+2	; 0x02
    518c:	87 89       	ldd	r24, Z+23	; 0x17
    518e:	90 8d       	ldd	r25, Z+24	; 0x18
    5190:	0e 94 a9 06 	call	0xd52	; 0xd52 <vPortFree>
            vPortFree( pxTCB );
    5194:	89 81       	ldd	r24, Y+1	; 0x01
    5196:	9a 81       	ldd	r25, Y+2	; 0x02
    5198:	0e 94 a9 06 	call	0xd52	; 0xd52 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    519c:	0f 90       	pop	r0
    519e:	0f 90       	pop	r0
    51a0:	cf 91       	pop	r28
    51a2:	df 91       	pop	r29
    51a4:	08 95       	ret

000051a6 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    51a6:	df 93       	push	r29
    51a8:	cf 93       	push	r28
    51aa:	cd b7       	in	r28, 0x3d	; 61
    51ac:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    51ae:	e0 91 96 06 	lds	r30, 0x0696
    51b2:	f0 91 97 06 	lds	r31, 0x0697
    51b6:	80 81       	ld	r24, Z
    51b8:	88 23       	and	r24, r24
    51ba:	39 f4       	brne	.+14     	; 0x51ca <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    51bc:	8f ef       	ldi	r24, 0xFF	; 255
    51be:	9f ef       	ldi	r25, 0xFF	; 255
    51c0:	90 93 5c 06 	sts	0x065C, r25
    51c4:	80 93 5b 06 	sts	0x065B, r24
    51c8:	0d c0       	rjmp	.+26     	; 0x51e4 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    51ca:	e0 91 96 06 	lds	r30, 0x0696
    51ce:	f0 91 97 06 	lds	r31, 0x0697
    51d2:	05 80       	ldd	r0, Z+5	; 0x05
    51d4:	f6 81       	ldd	r31, Z+6	; 0x06
    51d6:	e0 2d       	mov	r30, r0
    51d8:	80 81       	ld	r24, Z
    51da:	91 81       	ldd	r25, Z+1	; 0x01
    51dc:	90 93 5c 06 	sts	0x065C, r25
    51e0:	80 93 5b 06 	sts	0x065B, r24
    }
}
    51e4:	cf 91       	pop	r28
    51e6:	df 91       	pop	r29
    51e8:	08 95       	ret

000051ea <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    51ea:	df 93       	push	r29
    51ec:	cf 93       	push	r28
    51ee:	00 d0       	rcall	.+0      	; 0x51f0 <xTaskGetCurrentTaskHandle+0x6>
    51f0:	cd b7       	in	r28, 0x3d	; 61
    51f2:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    51f4:	80 91 4e 06 	lds	r24, 0x064E
    51f8:	90 91 4f 06 	lds	r25, 0x064F
    51fc:	9a 83       	std	Y+2, r25	; 0x02
    51fe:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    5200:	89 81       	ldd	r24, Y+1	; 0x01
    5202:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5204:	0f 90       	pop	r0
    5206:	0f 90       	pop	r0
    5208:	cf 91       	pop	r28
    520a:	df 91       	pop	r29
    520c:	08 95       	ret

0000520e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    520e:	df 93       	push	r29
    5210:	cf 93       	push	r28
    5212:	00 d0       	rcall	.+0      	; 0x5214 <uxTaskResetEventItemValue+0x6>
    5214:	cd b7       	in	r28, 0x3d	; 61
    5216:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5218:	e0 91 4e 06 	lds	r30, 0x064E
    521c:	f0 91 4f 06 	lds	r31, 0x064F
    5220:	84 85       	ldd	r24, Z+12	; 0x0c
    5222:	95 85       	ldd	r25, Z+13	; 0x0d
    5224:	9a 83       	std	Y+2, r25	; 0x02
    5226:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5228:	a0 91 4e 06 	lds	r26, 0x064E
    522c:	b0 91 4f 06 	lds	r27, 0x064F
    5230:	e0 91 4e 06 	lds	r30, 0x064E
    5234:	f0 91 4f 06 	lds	r31, 0x064F
    5238:	86 89       	ldd	r24, Z+22	; 0x16
    523a:	28 2f       	mov	r18, r24
    523c:	30 e0       	ldi	r19, 0x00	; 0
    523e:	84 e0       	ldi	r24, 0x04	; 4
    5240:	90 e0       	ldi	r25, 0x00	; 0
    5242:	82 1b       	sub	r24, r18
    5244:	93 0b       	sbc	r25, r19
    5246:	1d 96       	adiw	r26, 0x0d	; 13
    5248:	9c 93       	st	X, r25
    524a:	8e 93       	st	-X, r24
    524c:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    524e:	89 81       	ldd	r24, Y+1	; 0x01
    5250:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5252:	0f 90       	pop	r0
    5254:	0f 90       	pop	r0
    5256:	cf 91       	pop	r28
    5258:	df 91       	pop	r29
    525a:	08 95       	ret

0000525c <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    525c:	df 93       	push	r29
    525e:	cf 93       	push	r28
    5260:	cd b7       	in	r28, 0x3d	; 61
    5262:	de b7       	in	r29, 0x3e	; 62
    5264:	28 97       	sbiw	r28, 0x08	; 8
    5266:	0f b6       	in	r0, 0x3f	; 63
    5268:	f8 94       	cli
    526a:	de bf       	out	0x3e, r29	; 62
    526c:	0f be       	out	0x3f, r0	; 63
    526e:	cd bf       	out	0x3d, r28	; 61
    5270:	8d 83       	std	Y+5, r24	; 0x05
    5272:	6e 83       	std	Y+6, r22	; 0x06
    5274:	58 87       	std	Y+8, r21	; 0x08
    5276:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5278:	0f b6       	in	r0, 0x3f	; 63
    527a:	f8 94       	cli
    527c:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    527e:	20 91 4e 06 	lds	r18, 0x064E
    5282:	30 91 4f 06 	lds	r19, 0x064F
    5286:	8d 81       	ldd	r24, Y+5	; 0x05
    5288:	88 2f       	mov	r24, r24
    528a:	90 e0       	ldi	r25, 0x00	; 0
    528c:	88 0f       	add	r24, r24
    528e:	99 1f       	adc	r25, r25
    5290:	88 0f       	add	r24, r24
    5292:	99 1f       	adc	r25, r25
    5294:	82 0f       	add	r24, r18
    5296:	93 1f       	adc	r25, r19
    5298:	fc 01       	movw	r30, r24
    529a:	b1 96       	adiw	r30, 0x21	; 33
    529c:	80 81       	ld	r24, Z
    529e:	91 81       	ldd	r25, Z+1	; 0x01
    52a0:	a2 81       	ldd	r26, Z+2	; 0x02
    52a2:	b3 81       	ldd	r27, Z+3	; 0x03
    52a4:	00 97       	sbiw	r24, 0x00	; 0
    52a6:	a1 05       	cpc	r26, r1
    52a8:	b1 05       	cpc	r27, r1
    52aa:	c1 f4       	brne	.+48     	; 0x52dc <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    52ac:	20 91 4e 06 	lds	r18, 0x064E
    52b0:	30 91 4f 06 	lds	r19, 0x064F
    52b4:	8d 81       	ldd	r24, Y+5	; 0x05
    52b6:	88 2f       	mov	r24, r24
    52b8:	90 e0       	ldi	r25, 0x00	; 0
    52ba:	82 0f       	add	r24, r18
    52bc:	93 1f       	adc	r25, r19
    52be:	fc 01       	movw	r30, r24
    52c0:	b5 96       	adiw	r30, 0x25	; 37
    52c2:	81 e0       	ldi	r24, 0x01	; 1
    52c4:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    52c6:	8f 81       	ldd	r24, Y+7	; 0x07
    52c8:	98 85       	ldd	r25, Y+8	; 0x08
    52ca:	00 97       	sbiw	r24, 0x00	; 0
    52cc:	39 f0       	breq	.+14     	; 0x52dc <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    52ce:	8f 81       	ldd	r24, Y+7	; 0x07
    52d0:	98 85       	ldd	r25, Y+8	; 0x08
    52d2:	61 e0       	ldi	r22, 0x01	; 1
    52d4:	0e 94 b3 30 	call	0x6166	; 0x6166 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    52d8:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    52dc:	0f 90       	pop	r0
    52de:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    52e0:	0f b6       	in	r0, 0x3f	; 63
    52e2:	f8 94       	cli
    52e4:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    52e6:	20 91 4e 06 	lds	r18, 0x064E
    52ea:	30 91 4f 06 	lds	r19, 0x064F
    52ee:	8d 81       	ldd	r24, Y+5	; 0x05
    52f0:	88 2f       	mov	r24, r24
    52f2:	90 e0       	ldi	r25, 0x00	; 0
    52f4:	88 0f       	add	r24, r24
    52f6:	99 1f       	adc	r25, r25
    52f8:	88 0f       	add	r24, r24
    52fa:	99 1f       	adc	r25, r25
    52fc:	82 0f       	add	r24, r18
    52fe:	93 1f       	adc	r25, r19
    5300:	fc 01       	movw	r30, r24
    5302:	b1 96       	adiw	r30, 0x21	; 33
    5304:	80 81       	ld	r24, Z
    5306:	91 81       	ldd	r25, Z+1	; 0x01
    5308:	a2 81       	ldd	r26, Z+2	; 0x02
    530a:	b3 81       	ldd	r27, Z+3	; 0x03
    530c:	89 83       	std	Y+1, r24	; 0x01
    530e:	9a 83       	std	Y+2, r25	; 0x02
    5310:	ab 83       	std	Y+3, r26	; 0x03
    5312:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    5314:	89 81       	ldd	r24, Y+1	; 0x01
    5316:	9a 81       	ldd	r25, Y+2	; 0x02
    5318:	ab 81       	ldd	r26, Y+3	; 0x03
    531a:	bc 81       	ldd	r27, Y+4	; 0x04
    531c:	00 97       	sbiw	r24, 0x00	; 0
    531e:	a1 05       	cpc	r26, r1
    5320:	b1 05       	cpc	r27, r1
    5322:	a9 f1       	breq	.+106    	; 0x538e <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    5324:	8e 81       	ldd	r24, Y+6	; 0x06
    5326:	88 23       	and	r24, r24
    5328:	a1 f0       	breq	.+40     	; 0x5352 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    532a:	20 91 4e 06 	lds	r18, 0x064E
    532e:	30 91 4f 06 	lds	r19, 0x064F
    5332:	8d 81       	ldd	r24, Y+5	; 0x05
    5334:	88 2f       	mov	r24, r24
    5336:	90 e0       	ldi	r25, 0x00	; 0
    5338:	88 0f       	add	r24, r24
    533a:	99 1f       	adc	r25, r25
    533c:	88 0f       	add	r24, r24
    533e:	99 1f       	adc	r25, r25
    5340:	82 0f       	add	r24, r18
    5342:	93 1f       	adc	r25, r19
    5344:	fc 01       	movw	r30, r24
    5346:	b1 96       	adiw	r30, 0x21	; 33
    5348:	10 82       	st	Z, r1
    534a:	11 82       	std	Z+1, r1	; 0x01
    534c:	12 82       	std	Z+2, r1	; 0x02
    534e:	13 82       	std	Z+3, r1	; 0x03
    5350:	1e c0       	rjmp	.+60     	; 0x538e <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    5352:	e0 91 4e 06 	lds	r30, 0x064E
    5356:	f0 91 4f 06 	lds	r31, 0x064F
    535a:	8d 81       	ldd	r24, Y+5	; 0x05
    535c:	68 2f       	mov	r22, r24
    535e:	70 e0       	ldi	r23, 0x00	; 0
    5360:	89 81       	ldd	r24, Y+1	; 0x01
    5362:	9a 81       	ldd	r25, Y+2	; 0x02
    5364:	ab 81       	ldd	r26, Y+3	; 0x03
    5366:	bc 81       	ldd	r27, Y+4	; 0x04
    5368:	9c 01       	movw	r18, r24
    536a:	ad 01       	movw	r20, r26
    536c:	21 50       	subi	r18, 0x01	; 1
    536e:	30 40       	sbci	r19, 0x00	; 0
    5370:	40 40       	sbci	r20, 0x00	; 0
    5372:	50 40       	sbci	r21, 0x00	; 0
    5374:	cb 01       	movw	r24, r22
    5376:	88 0f       	add	r24, r24
    5378:	99 1f       	adc	r25, r25
    537a:	88 0f       	add	r24, r24
    537c:	99 1f       	adc	r25, r25
    537e:	8e 0f       	add	r24, r30
    5380:	9f 1f       	adc	r25, r31
    5382:	fc 01       	movw	r30, r24
    5384:	b1 96       	adiw	r30, 0x21	; 33
    5386:	20 83       	st	Z, r18
    5388:	31 83       	std	Z+1, r19	; 0x01
    538a:	42 83       	std	Z+2, r20	; 0x02
    538c:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    538e:	20 91 4e 06 	lds	r18, 0x064E
    5392:	30 91 4f 06 	lds	r19, 0x064F
    5396:	8d 81       	ldd	r24, Y+5	; 0x05
    5398:	88 2f       	mov	r24, r24
    539a:	90 e0       	ldi	r25, 0x00	; 0
    539c:	82 0f       	add	r24, r18
    539e:	93 1f       	adc	r25, r19
    53a0:	fc 01       	movw	r30, r24
    53a2:	b5 96       	adiw	r30, 0x25	; 37
    53a4:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    53a6:	0f 90       	pop	r0
    53a8:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    53aa:	89 81       	ldd	r24, Y+1	; 0x01
    53ac:	9a 81       	ldd	r25, Y+2	; 0x02
    53ae:	ab 81       	ldd	r26, Y+3	; 0x03
    53b0:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    53b2:	bc 01       	movw	r22, r24
    53b4:	cd 01       	movw	r24, r26
    53b6:	28 96       	adiw	r28, 0x08	; 8
    53b8:	0f b6       	in	r0, 0x3f	; 63
    53ba:	f8 94       	cli
    53bc:	de bf       	out	0x3e, r29	; 62
    53be:	0f be       	out	0x3f, r0	; 63
    53c0:	cd bf       	out	0x3d, r28	; 61
    53c2:	cf 91       	pop	r28
    53c4:	df 91       	pop	r29
    53c6:	08 95       	ret

000053c8 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    53c8:	cf 92       	push	r12
    53ca:	df 92       	push	r13
    53cc:	ef 92       	push	r14
    53ce:	ff 92       	push	r15
    53d0:	0f 93       	push	r16
    53d2:	1f 93       	push	r17
    53d4:	df 93       	push	r29
    53d6:	cf 93       	push	r28
    53d8:	cd b7       	in	r28, 0x3d	; 61
    53da:	de b7       	in	r29, 0x3e	; 62
    53dc:	2e 97       	sbiw	r28, 0x0e	; 14
    53de:	0f b6       	in	r0, 0x3f	; 63
    53e0:	f8 94       	cli
    53e2:	de bf       	out	0x3e, r29	; 62
    53e4:	0f be       	out	0x3f, r0	; 63
    53e6:	cd bf       	out	0x3d, r28	; 61
    53e8:	8a 83       	std	Y+2, r24	; 0x02
    53ea:	4b 83       	std	Y+3, r20	; 0x03
    53ec:	5c 83       	std	Y+4, r21	; 0x04
    53ee:	6d 83       	std	Y+5, r22	; 0x05
    53f0:	7e 83       	std	Y+6, r23	; 0x06
    53f2:	0f 83       	std	Y+7, r16	; 0x07
    53f4:	18 87       	std	Y+8, r17	; 0x08
    53f6:	29 87       	std	Y+9, r18	; 0x09
    53f8:	3a 87       	std	Y+10, r19	; 0x0a
    53fa:	fc 86       	std	Y+12, r15	; 0x0c
    53fc:	eb 86       	std	Y+11, r14	; 0x0b
    53fe:	de 86       	std	Y+14, r13	; 0x0e
    5400:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5402:	0f b6       	in	r0, 0x3f	; 63
    5404:	f8 94       	cli
    5406:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5408:	20 91 4e 06 	lds	r18, 0x064E
    540c:	30 91 4f 06 	lds	r19, 0x064F
    5410:	8a 81       	ldd	r24, Y+2	; 0x02
    5412:	88 2f       	mov	r24, r24
    5414:	90 e0       	ldi	r25, 0x00	; 0
    5416:	82 0f       	add	r24, r18
    5418:	93 1f       	adc	r25, r19
    541a:	fc 01       	movw	r30, r24
    541c:	b5 96       	adiw	r30, 0x25	; 37
    541e:	80 81       	ld	r24, Z
    5420:	82 30       	cpi	r24, 0x02	; 2
    5422:	09 f4       	brne	.+2      	; 0x5426 <xTaskGenericNotifyWait+0x5e>
    5424:	47 c0       	rjmp	.+142    	; 0x54b4 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5426:	60 91 4e 06 	lds	r22, 0x064E
    542a:	70 91 4f 06 	lds	r23, 0x064F
    542e:	8a 81       	ldd	r24, Y+2	; 0x02
    5430:	08 2f       	mov	r16, r24
    5432:	10 e0       	ldi	r17, 0x00	; 0
    5434:	8a 81       	ldd	r24, Y+2	; 0x02
    5436:	88 2f       	mov	r24, r24
    5438:	90 e0       	ldi	r25, 0x00	; 0
    543a:	88 0f       	add	r24, r24
    543c:	99 1f       	adc	r25, r25
    543e:	88 0f       	add	r24, r24
    5440:	99 1f       	adc	r25, r25
    5442:	86 0f       	add	r24, r22
    5444:	97 1f       	adc	r25, r23
    5446:	fc 01       	movw	r30, r24
    5448:	b1 96       	adiw	r30, 0x21	; 33
    544a:	20 81       	ld	r18, Z
    544c:	31 81       	ldd	r19, Z+1	; 0x01
    544e:	42 81       	ldd	r20, Z+2	; 0x02
    5450:	53 81       	ldd	r21, Z+3	; 0x03
    5452:	8b 81       	ldd	r24, Y+3	; 0x03
    5454:	9c 81       	ldd	r25, Y+4	; 0x04
    5456:	ad 81       	ldd	r26, Y+5	; 0x05
    5458:	be 81       	ldd	r27, Y+6	; 0x06
    545a:	80 95       	com	r24
    545c:	90 95       	com	r25
    545e:	a0 95       	com	r26
    5460:	b0 95       	com	r27
    5462:	28 23       	and	r18, r24
    5464:	39 23       	and	r19, r25
    5466:	4a 23       	and	r20, r26
    5468:	5b 23       	and	r21, r27
    546a:	c8 01       	movw	r24, r16
    546c:	88 0f       	add	r24, r24
    546e:	99 1f       	adc	r25, r25
    5470:	88 0f       	add	r24, r24
    5472:	99 1f       	adc	r25, r25
    5474:	86 0f       	add	r24, r22
    5476:	97 1f       	adc	r25, r23
    5478:	fc 01       	movw	r30, r24
    547a:	b1 96       	adiw	r30, 0x21	; 33
    547c:	20 83       	st	Z, r18
    547e:	31 83       	std	Z+1, r19	; 0x01
    5480:	42 83       	std	Z+2, r20	; 0x02
    5482:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5484:	20 91 4e 06 	lds	r18, 0x064E
    5488:	30 91 4f 06 	lds	r19, 0x064F
    548c:	8a 81       	ldd	r24, Y+2	; 0x02
    548e:	88 2f       	mov	r24, r24
    5490:	90 e0       	ldi	r25, 0x00	; 0
    5492:	82 0f       	add	r24, r18
    5494:	93 1f       	adc	r25, r19
    5496:	fc 01       	movw	r30, r24
    5498:	b5 96       	adiw	r30, 0x25	; 37
    549a:	81 e0       	ldi	r24, 0x01	; 1
    549c:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    549e:	8d 85       	ldd	r24, Y+13	; 0x0d
    54a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    54a2:	00 97       	sbiw	r24, 0x00	; 0
    54a4:	39 f0       	breq	.+14     	; 0x54b4 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    54a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    54a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    54aa:	61 e0       	ldi	r22, 0x01	; 1
    54ac:	0e 94 b3 30 	call	0x6166	; 0x6166 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    54b0:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    54b4:	0f 90       	pop	r0
    54b6:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    54b8:	0f b6       	in	r0, 0x3f	; 63
    54ba:	f8 94       	cli
    54bc:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    54be:	8b 85       	ldd	r24, Y+11	; 0x0b
    54c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    54c2:	00 97       	sbiw	r24, 0x00	; 0
    54c4:	c9 f0       	breq	.+50     	; 0x54f8 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    54c6:	20 91 4e 06 	lds	r18, 0x064E
    54ca:	30 91 4f 06 	lds	r19, 0x064F
    54ce:	8a 81       	ldd	r24, Y+2	; 0x02
    54d0:	88 2f       	mov	r24, r24
    54d2:	90 e0       	ldi	r25, 0x00	; 0
    54d4:	88 0f       	add	r24, r24
    54d6:	99 1f       	adc	r25, r25
    54d8:	88 0f       	add	r24, r24
    54da:	99 1f       	adc	r25, r25
    54dc:	82 0f       	add	r24, r18
    54de:	93 1f       	adc	r25, r19
    54e0:	fc 01       	movw	r30, r24
    54e2:	b1 96       	adiw	r30, 0x21	; 33
    54e4:	80 81       	ld	r24, Z
    54e6:	91 81       	ldd	r25, Z+1	; 0x01
    54e8:	a2 81       	ldd	r26, Z+2	; 0x02
    54ea:	b3 81       	ldd	r27, Z+3	; 0x03
    54ec:	eb 85       	ldd	r30, Y+11	; 0x0b
    54ee:	fc 85       	ldd	r31, Y+12	; 0x0c
    54f0:	80 83       	st	Z, r24
    54f2:	91 83       	std	Z+1, r25	; 0x01
    54f4:	a2 83       	std	Z+2, r26	; 0x02
    54f6:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    54f8:	20 91 4e 06 	lds	r18, 0x064E
    54fc:	30 91 4f 06 	lds	r19, 0x064F
    5500:	8a 81       	ldd	r24, Y+2	; 0x02
    5502:	88 2f       	mov	r24, r24
    5504:	90 e0       	ldi	r25, 0x00	; 0
    5506:	82 0f       	add	r24, r18
    5508:	93 1f       	adc	r25, r19
    550a:	fc 01       	movw	r30, r24
    550c:	b5 96       	adiw	r30, 0x25	; 37
    550e:	80 81       	ld	r24, Z
    5510:	82 30       	cpi	r24, 0x02	; 2
    5512:	11 f0       	breq	.+4      	; 0x5518 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5514:	19 82       	std	Y+1, r1	; 0x01
    5516:	31 c0       	rjmp	.+98     	; 0x557a <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5518:	60 91 4e 06 	lds	r22, 0x064E
    551c:	70 91 4f 06 	lds	r23, 0x064F
    5520:	8a 81       	ldd	r24, Y+2	; 0x02
    5522:	08 2f       	mov	r16, r24
    5524:	10 e0       	ldi	r17, 0x00	; 0
    5526:	8a 81       	ldd	r24, Y+2	; 0x02
    5528:	88 2f       	mov	r24, r24
    552a:	90 e0       	ldi	r25, 0x00	; 0
    552c:	88 0f       	add	r24, r24
    552e:	99 1f       	adc	r25, r25
    5530:	88 0f       	add	r24, r24
    5532:	99 1f       	adc	r25, r25
    5534:	86 0f       	add	r24, r22
    5536:	97 1f       	adc	r25, r23
    5538:	fc 01       	movw	r30, r24
    553a:	b1 96       	adiw	r30, 0x21	; 33
    553c:	20 81       	ld	r18, Z
    553e:	31 81       	ldd	r19, Z+1	; 0x01
    5540:	42 81       	ldd	r20, Z+2	; 0x02
    5542:	53 81       	ldd	r21, Z+3	; 0x03
    5544:	8f 81       	ldd	r24, Y+7	; 0x07
    5546:	98 85       	ldd	r25, Y+8	; 0x08
    5548:	a9 85       	ldd	r26, Y+9	; 0x09
    554a:	ba 85       	ldd	r27, Y+10	; 0x0a
    554c:	80 95       	com	r24
    554e:	90 95       	com	r25
    5550:	a0 95       	com	r26
    5552:	b0 95       	com	r27
    5554:	28 23       	and	r18, r24
    5556:	39 23       	and	r19, r25
    5558:	4a 23       	and	r20, r26
    555a:	5b 23       	and	r21, r27
    555c:	c8 01       	movw	r24, r16
    555e:	88 0f       	add	r24, r24
    5560:	99 1f       	adc	r25, r25
    5562:	88 0f       	add	r24, r24
    5564:	99 1f       	adc	r25, r25
    5566:	86 0f       	add	r24, r22
    5568:	97 1f       	adc	r25, r23
    556a:	fc 01       	movw	r30, r24
    556c:	b1 96       	adiw	r30, 0x21	; 33
    556e:	20 83       	st	Z, r18
    5570:	31 83       	std	Z+1, r19	; 0x01
    5572:	42 83       	std	Z+2, r20	; 0x02
    5574:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    5576:	81 e0       	ldi	r24, 0x01	; 1
    5578:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    557a:	20 91 4e 06 	lds	r18, 0x064E
    557e:	30 91 4f 06 	lds	r19, 0x064F
    5582:	8a 81       	ldd	r24, Y+2	; 0x02
    5584:	88 2f       	mov	r24, r24
    5586:	90 e0       	ldi	r25, 0x00	; 0
    5588:	82 0f       	add	r24, r18
    558a:	93 1f       	adc	r25, r19
    558c:	fc 01       	movw	r30, r24
    558e:	b5 96       	adiw	r30, 0x25	; 37
    5590:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5592:	0f 90       	pop	r0
    5594:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5596:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5598:	2e 96       	adiw	r28, 0x0e	; 14
    559a:	0f b6       	in	r0, 0x3f	; 63
    559c:	f8 94       	cli
    559e:	de bf       	out	0x3e, r29	; 62
    55a0:	0f be       	out	0x3f, r0	; 63
    55a2:	cd bf       	out	0x3d, r28	; 61
    55a4:	cf 91       	pop	r28
    55a6:	df 91       	pop	r29
    55a8:	1f 91       	pop	r17
    55aa:	0f 91       	pop	r16
    55ac:	ff 90       	pop	r15
    55ae:	ef 90       	pop	r14
    55b0:	df 90       	pop	r13
    55b2:	cf 90       	pop	r12
    55b4:	08 95       	ret

000055b6 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    55b6:	ef 92       	push	r14
    55b8:	ff 92       	push	r15
    55ba:	0f 93       	push	r16
    55bc:	1f 93       	push	r17
    55be:	df 93       	push	r29
    55c0:	cf 93       	push	r28
    55c2:	cd b7       	in	r28, 0x3d	; 61
    55c4:	de b7       	in	r29, 0x3e	; 62
    55c6:	64 97       	sbiw	r28, 0x14	; 20
    55c8:	0f b6       	in	r0, 0x3f	; 63
    55ca:	f8 94       	cli
    55cc:	de bf       	out	0x3e, r29	; 62
    55ce:	0f be       	out	0x3f, r0	; 63
    55d0:	cd bf       	out	0x3d, r28	; 61
    55d2:	9a 87       	std	Y+10, r25	; 0x0a
    55d4:	89 87       	std	Y+9, r24	; 0x09
    55d6:	6b 87       	std	Y+11, r22	; 0x0b
    55d8:	2c 87       	std	Y+12, r18	; 0x0c
    55da:	3d 87       	std	Y+13, r19	; 0x0d
    55dc:	4e 87       	std	Y+14, r20	; 0x0e
    55de:	5f 87       	std	Y+15, r21	; 0x0f
    55e0:	08 8b       	std	Y+16, r16	; 0x10
    55e2:	fa 8a       	std	Y+18, r15	; 0x12
    55e4:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    55e6:	81 e0       	ldi	r24, 0x01	; 1
    55e8:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    55ea:	89 85       	ldd	r24, Y+9	; 0x09
    55ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    55ee:	98 87       	std	Y+8, r25	; 0x08
    55f0:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    55f2:	0f b6       	in	r0, 0x3f	; 63
    55f4:	f8 94       	cli
    55f6:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    55f8:	89 89       	ldd	r24, Y+17	; 0x11
    55fa:	9a 89       	ldd	r25, Y+18	; 0x12
    55fc:	00 97       	sbiw	r24, 0x00	; 0
    55fe:	b9 f0       	breq	.+46     	; 0x562e <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5600:	8b 85       	ldd	r24, Y+11	; 0x0b
    5602:	88 2f       	mov	r24, r24
    5604:	90 e0       	ldi	r25, 0x00	; 0
    5606:	2f 81       	ldd	r18, Y+7	; 0x07
    5608:	38 85       	ldd	r19, Y+8	; 0x08
    560a:	88 0f       	add	r24, r24
    560c:	99 1f       	adc	r25, r25
    560e:	88 0f       	add	r24, r24
    5610:	99 1f       	adc	r25, r25
    5612:	82 0f       	add	r24, r18
    5614:	93 1f       	adc	r25, r19
    5616:	fc 01       	movw	r30, r24
    5618:	b1 96       	adiw	r30, 0x21	; 33
    561a:	80 81       	ld	r24, Z
    561c:	91 81       	ldd	r25, Z+1	; 0x01
    561e:	a2 81       	ldd	r26, Z+2	; 0x02
    5620:	b3 81       	ldd	r27, Z+3	; 0x03
    5622:	e9 89       	ldd	r30, Y+17	; 0x11
    5624:	fa 89       	ldd	r31, Y+18	; 0x12
    5626:	80 83       	st	Z, r24
    5628:	91 83       	std	Z+1, r25	; 0x01
    562a:	a2 83       	std	Z+2, r26	; 0x02
    562c:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    562e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5630:	28 2f       	mov	r18, r24
    5632:	30 e0       	ldi	r19, 0x00	; 0
    5634:	8f 81       	ldd	r24, Y+7	; 0x07
    5636:	98 85       	ldd	r25, Y+8	; 0x08
    5638:	82 0f       	add	r24, r18
    563a:	93 1f       	adc	r25, r19
    563c:	fc 01       	movw	r30, r24
    563e:	b5 96       	adiw	r30, 0x25	; 37
    5640:	80 81       	ld	r24, Z
    5642:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5644:	8b 85       	ldd	r24, Y+11	; 0x0b
    5646:	28 2f       	mov	r18, r24
    5648:	30 e0       	ldi	r19, 0x00	; 0
    564a:	8f 81       	ldd	r24, Y+7	; 0x07
    564c:	98 85       	ldd	r25, Y+8	; 0x08
    564e:	82 0f       	add	r24, r18
    5650:	93 1f       	adc	r25, r19
    5652:	fc 01       	movw	r30, r24
    5654:	b5 96       	adiw	r30, 0x25	; 37
    5656:	82 e0       	ldi	r24, 0x02	; 2
    5658:	80 83       	st	Z, r24

            switch( eAction )
    565a:	88 89       	ldd	r24, Y+16	; 0x10
    565c:	28 2f       	mov	r18, r24
    565e:	30 e0       	ldi	r19, 0x00	; 0
    5660:	3c 8b       	std	Y+20, r19	; 0x14
    5662:	2b 8b       	std	Y+19, r18	; 0x13
    5664:	8b 89       	ldd	r24, Y+19	; 0x13
    5666:	9c 89       	ldd	r25, Y+20	; 0x14
    5668:	82 30       	cpi	r24, 0x02	; 2
    566a:	91 05       	cpc	r25, r1
    566c:	09 f4       	brne	.+2      	; 0x5670 <xTaskGenericNotify+0xba>
    566e:	46 c0       	rjmp	.+140    	; 0x56fc <xTaskGenericNotify+0x146>
    5670:	2b 89       	ldd	r18, Y+19	; 0x13
    5672:	3c 89       	ldd	r19, Y+20	; 0x14
    5674:	23 30       	cpi	r18, 0x03	; 3
    5676:	31 05       	cpc	r19, r1
    5678:	34 f4       	brge	.+12     	; 0x5686 <xTaskGenericNotify+0xd0>
    567a:	8b 89       	ldd	r24, Y+19	; 0x13
    567c:	9c 89       	ldd	r25, Y+20	; 0x14
    567e:	81 30       	cpi	r24, 0x01	; 1
    5680:	91 05       	cpc	r25, r1
    5682:	71 f0       	breq	.+28     	; 0x56a0 <xTaskGenericNotify+0xea>
    5684:	93 c0       	rjmp	.+294    	; 0x57ac <xTaskGenericNotify+0x1f6>
    5686:	2b 89       	ldd	r18, Y+19	; 0x13
    5688:	3c 89       	ldd	r19, Y+20	; 0x14
    568a:	23 30       	cpi	r18, 0x03	; 3
    568c:	31 05       	cpc	r19, r1
    568e:	09 f4       	brne	.+2      	; 0x5692 <xTaskGenericNotify+0xdc>
    5690:	5d c0       	rjmp	.+186    	; 0x574c <xTaskGenericNotify+0x196>
    5692:	8b 89       	ldd	r24, Y+19	; 0x13
    5694:	9c 89       	ldd	r25, Y+20	; 0x14
    5696:	84 30       	cpi	r24, 0x04	; 4
    5698:	91 05       	cpc	r25, r1
    569a:	09 f4       	brne	.+2      	; 0x569e <xTaskGenericNotify+0xe8>
    569c:	6d c0       	rjmp	.+218    	; 0x5778 <xTaskGenericNotify+0x1c2>
    569e:	86 c0       	rjmp	.+268    	; 0x57ac <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    56a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    56a2:	08 2f       	mov	r16, r24
    56a4:	10 e0       	ldi	r17, 0x00	; 0
    56a6:	8b 85       	ldd	r24, Y+11	; 0x0b
    56a8:	88 2f       	mov	r24, r24
    56aa:	90 e0       	ldi	r25, 0x00	; 0
    56ac:	2f 81       	ldd	r18, Y+7	; 0x07
    56ae:	38 85       	ldd	r19, Y+8	; 0x08
    56b0:	88 0f       	add	r24, r24
    56b2:	99 1f       	adc	r25, r25
    56b4:	88 0f       	add	r24, r24
    56b6:	99 1f       	adc	r25, r25
    56b8:	82 0f       	add	r24, r18
    56ba:	93 1f       	adc	r25, r19
    56bc:	fc 01       	movw	r30, r24
    56be:	b1 96       	adiw	r30, 0x21	; 33
    56c0:	20 81       	ld	r18, Z
    56c2:	31 81       	ldd	r19, Z+1	; 0x01
    56c4:	42 81       	ldd	r20, Z+2	; 0x02
    56c6:	53 81       	ldd	r21, Z+3	; 0x03
    56c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    56ca:	9d 85       	ldd	r25, Y+13	; 0x0d
    56cc:	ae 85       	ldd	r26, Y+14	; 0x0e
    56ce:	bf 85       	ldd	r27, Y+15	; 0x0f
    56d0:	ba 01       	movw	r22, r20
    56d2:	a9 01       	movw	r20, r18
    56d4:	48 2b       	or	r20, r24
    56d6:	59 2b       	or	r21, r25
    56d8:	6a 2b       	or	r22, r26
    56da:	7b 2b       	or	r23, r27
    56dc:	2f 81       	ldd	r18, Y+7	; 0x07
    56de:	38 85       	ldd	r19, Y+8	; 0x08
    56e0:	c8 01       	movw	r24, r16
    56e2:	88 0f       	add	r24, r24
    56e4:	99 1f       	adc	r25, r25
    56e6:	88 0f       	add	r24, r24
    56e8:	99 1f       	adc	r25, r25
    56ea:	82 0f       	add	r24, r18
    56ec:	93 1f       	adc	r25, r19
    56ee:	fc 01       	movw	r30, r24
    56f0:	b1 96       	adiw	r30, 0x21	; 33
    56f2:	40 83       	st	Z, r20
    56f4:	51 83       	std	Z+1, r21	; 0x01
    56f6:	62 83       	std	Z+2, r22	; 0x02
    56f8:	73 83       	std	Z+3, r23	; 0x03
    56fa:	58 c0       	rjmp	.+176    	; 0x57ac <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    56fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    56fe:	08 2f       	mov	r16, r24
    5700:	10 e0       	ldi	r17, 0x00	; 0
    5702:	2f 81       	ldd	r18, Y+7	; 0x07
    5704:	38 85       	ldd	r19, Y+8	; 0x08
    5706:	c8 01       	movw	r24, r16
    5708:	88 0f       	add	r24, r24
    570a:	99 1f       	adc	r25, r25
    570c:	88 0f       	add	r24, r24
    570e:	99 1f       	adc	r25, r25
    5710:	82 0f       	add	r24, r18
    5712:	93 1f       	adc	r25, r19
    5714:	fc 01       	movw	r30, r24
    5716:	b1 96       	adiw	r30, 0x21	; 33
    5718:	80 81       	ld	r24, Z
    571a:	91 81       	ldd	r25, Z+1	; 0x01
    571c:	a2 81       	ldd	r26, Z+2	; 0x02
    571e:	b3 81       	ldd	r27, Z+3	; 0x03
    5720:	ac 01       	movw	r20, r24
    5722:	bd 01       	movw	r22, r26
    5724:	4f 5f       	subi	r20, 0xFF	; 255
    5726:	5f 4f       	sbci	r21, 0xFF	; 255
    5728:	6f 4f       	sbci	r22, 0xFF	; 255
    572a:	7f 4f       	sbci	r23, 0xFF	; 255
    572c:	2f 81       	ldd	r18, Y+7	; 0x07
    572e:	38 85       	ldd	r19, Y+8	; 0x08
    5730:	c8 01       	movw	r24, r16
    5732:	88 0f       	add	r24, r24
    5734:	99 1f       	adc	r25, r25
    5736:	88 0f       	add	r24, r24
    5738:	99 1f       	adc	r25, r25
    573a:	82 0f       	add	r24, r18
    573c:	93 1f       	adc	r25, r19
    573e:	fc 01       	movw	r30, r24
    5740:	b1 96       	adiw	r30, 0x21	; 33
    5742:	40 83       	st	Z, r20
    5744:	51 83       	std	Z+1, r21	; 0x01
    5746:	62 83       	std	Z+2, r22	; 0x02
    5748:	73 83       	std	Z+3, r23	; 0x03
    574a:	30 c0       	rjmp	.+96     	; 0x57ac <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    574c:	8b 85       	ldd	r24, Y+11	; 0x0b
    574e:	88 2f       	mov	r24, r24
    5750:	90 e0       	ldi	r25, 0x00	; 0
    5752:	2f 81       	ldd	r18, Y+7	; 0x07
    5754:	38 85       	ldd	r19, Y+8	; 0x08
    5756:	88 0f       	add	r24, r24
    5758:	99 1f       	adc	r25, r25
    575a:	88 0f       	add	r24, r24
    575c:	99 1f       	adc	r25, r25
    575e:	82 0f       	add	r24, r18
    5760:	93 1f       	adc	r25, r19
    5762:	fc 01       	movw	r30, r24
    5764:	b1 96       	adiw	r30, 0x21	; 33
    5766:	8c 85       	ldd	r24, Y+12	; 0x0c
    5768:	9d 85       	ldd	r25, Y+13	; 0x0d
    576a:	ae 85       	ldd	r26, Y+14	; 0x0e
    576c:	bf 85       	ldd	r27, Y+15	; 0x0f
    576e:	80 83       	st	Z, r24
    5770:	91 83       	std	Z+1, r25	; 0x01
    5772:	a2 83       	std	Z+2, r26	; 0x02
    5774:	b3 83       	std	Z+3, r27	; 0x03
    5776:	1a c0       	rjmp	.+52     	; 0x57ac <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5778:	8d 81       	ldd	r24, Y+5	; 0x05
    577a:	82 30       	cpi	r24, 0x02	; 2
    577c:	b1 f0       	breq	.+44     	; 0x57aa <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    577e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5780:	88 2f       	mov	r24, r24
    5782:	90 e0       	ldi	r25, 0x00	; 0
    5784:	2f 81       	ldd	r18, Y+7	; 0x07
    5786:	38 85       	ldd	r19, Y+8	; 0x08
    5788:	88 0f       	add	r24, r24
    578a:	99 1f       	adc	r25, r25
    578c:	88 0f       	add	r24, r24
    578e:	99 1f       	adc	r25, r25
    5790:	82 0f       	add	r24, r18
    5792:	93 1f       	adc	r25, r19
    5794:	fc 01       	movw	r30, r24
    5796:	b1 96       	adiw	r30, 0x21	; 33
    5798:	8c 85       	ldd	r24, Y+12	; 0x0c
    579a:	9d 85       	ldd	r25, Y+13	; 0x0d
    579c:	ae 85       	ldd	r26, Y+14	; 0x0e
    579e:	bf 85       	ldd	r27, Y+15	; 0x0f
    57a0:	80 83       	st	Z, r24
    57a2:	91 83       	std	Z+1, r25	; 0x01
    57a4:	a2 83       	std	Z+2, r26	; 0x02
    57a6:	b3 83       	std	Z+3, r27	; 0x03
    57a8:	01 c0       	rjmp	.+2      	; 0x57ac <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    57aa:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    57ac:	8d 81       	ldd	r24, Y+5	; 0x05
    57ae:	81 30       	cpi	r24, 0x01	; 1
    57b0:	09 f0       	breq	.+2      	; 0x57b4 <xTaskGenericNotify+0x1fe>
    57b2:	af c0       	rjmp	.+350    	; 0x5912 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    57b4:	ef 81       	ldd	r30, Y+7	; 0x07
    57b6:	f8 85       	ldd	r31, Y+8	; 0x08
    57b8:	82 85       	ldd	r24, Z+10	; 0x0a
    57ba:	93 85       	ldd	r25, Z+11	; 0x0b
    57bc:	9c 83       	std	Y+4, r25	; 0x04
    57be:	8b 83       	std	Y+3, r24	; 0x03
    57c0:	ef 81       	ldd	r30, Y+7	; 0x07
    57c2:	f8 85       	ldd	r31, Y+8	; 0x08
    57c4:	a4 81       	ldd	r26, Z+4	; 0x04
    57c6:	b5 81       	ldd	r27, Z+5	; 0x05
    57c8:	ef 81       	ldd	r30, Y+7	; 0x07
    57ca:	f8 85       	ldd	r31, Y+8	; 0x08
    57cc:	86 81       	ldd	r24, Z+6	; 0x06
    57ce:	97 81       	ldd	r25, Z+7	; 0x07
    57d0:	15 96       	adiw	r26, 0x05	; 5
    57d2:	9c 93       	st	X, r25
    57d4:	8e 93       	st	-X, r24
    57d6:	14 97       	sbiw	r26, 0x04	; 4
    57d8:	ef 81       	ldd	r30, Y+7	; 0x07
    57da:	f8 85       	ldd	r31, Y+8	; 0x08
    57dc:	a6 81       	ldd	r26, Z+6	; 0x06
    57de:	b7 81       	ldd	r27, Z+7	; 0x07
    57e0:	ef 81       	ldd	r30, Y+7	; 0x07
    57e2:	f8 85       	ldd	r31, Y+8	; 0x08
    57e4:	84 81       	ldd	r24, Z+4	; 0x04
    57e6:	95 81       	ldd	r25, Z+5	; 0x05
    57e8:	13 96       	adiw	r26, 0x03	; 3
    57ea:	9c 93       	st	X, r25
    57ec:	8e 93       	st	-X, r24
    57ee:	12 97       	sbiw	r26, 0x02	; 2
    57f0:	eb 81       	ldd	r30, Y+3	; 0x03
    57f2:	fc 81       	ldd	r31, Y+4	; 0x04
    57f4:	21 81       	ldd	r18, Z+1	; 0x01
    57f6:	32 81       	ldd	r19, Z+2	; 0x02
    57f8:	8f 81       	ldd	r24, Y+7	; 0x07
    57fa:	98 85       	ldd	r25, Y+8	; 0x08
    57fc:	02 96       	adiw	r24, 0x02	; 2
    57fe:	28 17       	cp	r18, r24
    5800:	39 07       	cpc	r19, r25
    5802:	41 f4       	brne	.+16     	; 0x5814 <xTaskGenericNotify+0x25e>
    5804:	ef 81       	ldd	r30, Y+7	; 0x07
    5806:	f8 85       	ldd	r31, Y+8	; 0x08
    5808:	86 81       	ldd	r24, Z+6	; 0x06
    580a:	97 81       	ldd	r25, Z+7	; 0x07
    580c:	eb 81       	ldd	r30, Y+3	; 0x03
    580e:	fc 81       	ldd	r31, Y+4	; 0x04
    5810:	92 83       	std	Z+2, r25	; 0x02
    5812:	81 83       	std	Z+1, r24	; 0x01
    5814:	ef 81       	ldd	r30, Y+7	; 0x07
    5816:	f8 85       	ldd	r31, Y+8	; 0x08
    5818:	13 86       	std	Z+11, r1	; 0x0b
    581a:	12 86       	std	Z+10, r1	; 0x0a
    581c:	eb 81       	ldd	r30, Y+3	; 0x03
    581e:	fc 81       	ldd	r31, Y+4	; 0x04
    5820:	80 81       	ld	r24, Z
    5822:	81 50       	subi	r24, 0x01	; 1
    5824:	eb 81       	ldd	r30, Y+3	; 0x03
    5826:	fc 81       	ldd	r31, Y+4	; 0x04
    5828:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    582a:	ef 81       	ldd	r30, Y+7	; 0x07
    582c:	f8 85       	ldd	r31, Y+8	; 0x08
    582e:	96 89       	ldd	r25, Z+22	; 0x16
    5830:	80 91 54 06 	lds	r24, 0x0654
    5834:	89 17       	cp	r24, r25
    5836:	28 f4       	brcc	.+10     	; 0x5842 <xTaskGenericNotify+0x28c>
    5838:	ef 81       	ldd	r30, Y+7	; 0x07
    583a:	f8 85       	ldd	r31, Y+8	; 0x08
    583c:	86 89       	ldd	r24, Z+22	; 0x16
    583e:	80 93 54 06 	sts	0x0654, r24
    5842:	ef 81       	ldd	r30, Y+7	; 0x07
    5844:	f8 85       	ldd	r31, Y+8	; 0x08
    5846:	86 89       	ldd	r24, Z+22	; 0x16
    5848:	28 2f       	mov	r18, r24
    584a:	30 e0       	ldi	r19, 0x00	; 0
    584c:	c9 01       	movw	r24, r18
    584e:	88 0f       	add	r24, r24
    5850:	99 1f       	adc	r25, r25
    5852:	88 0f       	add	r24, r24
    5854:	99 1f       	adc	r25, r25
    5856:	88 0f       	add	r24, r24
    5858:	99 1f       	adc	r25, r25
    585a:	82 0f       	add	r24, r18
    585c:	93 1f       	adc	r25, r19
    585e:	fc 01       	movw	r30, r24
    5860:	e0 5a       	subi	r30, 0xA0	; 160
    5862:	f9 4f       	sbci	r31, 0xF9	; 249
    5864:	81 81       	ldd	r24, Z+1	; 0x01
    5866:	92 81       	ldd	r25, Z+2	; 0x02
    5868:	9a 83       	std	Y+2, r25	; 0x02
    586a:	89 83       	std	Y+1, r24	; 0x01
    586c:	ef 81       	ldd	r30, Y+7	; 0x07
    586e:	f8 85       	ldd	r31, Y+8	; 0x08
    5870:	89 81       	ldd	r24, Y+1	; 0x01
    5872:	9a 81       	ldd	r25, Y+2	; 0x02
    5874:	95 83       	std	Z+5, r25	; 0x05
    5876:	84 83       	std	Z+4, r24	; 0x04
    5878:	e9 81       	ldd	r30, Y+1	; 0x01
    587a:	fa 81       	ldd	r31, Y+2	; 0x02
    587c:	84 81       	ldd	r24, Z+4	; 0x04
    587e:	95 81       	ldd	r25, Z+5	; 0x05
    5880:	ef 81       	ldd	r30, Y+7	; 0x07
    5882:	f8 85       	ldd	r31, Y+8	; 0x08
    5884:	97 83       	std	Z+7, r25	; 0x07
    5886:	86 83       	std	Z+6, r24	; 0x06
    5888:	e9 81       	ldd	r30, Y+1	; 0x01
    588a:	fa 81       	ldd	r31, Y+2	; 0x02
    588c:	04 80       	ldd	r0, Z+4	; 0x04
    588e:	f5 81       	ldd	r31, Z+5	; 0x05
    5890:	e0 2d       	mov	r30, r0
    5892:	8f 81       	ldd	r24, Y+7	; 0x07
    5894:	98 85       	ldd	r25, Y+8	; 0x08
    5896:	02 96       	adiw	r24, 0x02	; 2
    5898:	93 83       	std	Z+3, r25	; 0x03
    589a:	82 83       	std	Z+2, r24	; 0x02
    589c:	8f 81       	ldd	r24, Y+7	; 0x07
    589e:	98 85       	ldd	r25, Y+8	; 0x08
    58a0:	02 96       	adiw	r24, 0x02	; 2
    58a2:	e9 81       	ldd	r30, Y+1	; 0x01
    58a4:	fa 81       	ldd	r31, Y+2	; 0x02
    58a6:	95 83       	std	Z+5, r25	; 0x05
    58a8:	84 83       	std	Z+4, r24	; 0x04
    58aa:	ef 81       	ldd	r30, Y+7	; 0x07
    58ac:	f8 85       	ldd	r31, Y+8	; 0x08
    58ae:	86 89       	ldd	r24, Z+22	; 0x16
    58b0:	28 2f       	mov	r18, r24
    58b2:	30 e0       	ldi	r19, 0x00	; 0
    58b4:	c9 01       	movw	r24, r18
    58b6:	88 0f       	add	r24, r24
    58b8:	99 1f       	adc	r25, r25
    58ba:	88 0f       	add	r24, r24
    58bc:	99 1f       	adc	r25, r25
    58be:	88 0f       	add	r24, r24
    58c0:	99 1f       	adc	r25, r25
    58c2:	82 0f       	add	r24, r18
    58c4:	93 1f       	adc	r25, r19
    58c6:	80 5a       	subi	r24, 0xA0	; 160
    58c8:	99 4f       	sbci	r25, 0xF9	; 249
    58ca:	ef 81       	ldd	r30, Y+7	; 0x07
    58cc:	f8 85       	ldd	r31, Y+8	; 0x08
    58ce:	93 87       	std	Z+11, r25	; 0x0b
    58d0:	82 87       	std	Z+10, r24	; 0x0a
    58d2:	ef 81       	ldd	r30, Y+7	; 0x07
    58d4:	f8 85       	ldd	r31, Y+8	; 0x08
    58d6:	86 89       	ldd	r24, Z+22	; 0x16
    58d8:	28 2f       	mov	r18, r24
    58da:	30 e0       	ldi	r19, 0x00	; 0
    58dc:	c9 01       	movw	r24, r18
    58de:	88 0f       	add	r24, r24
    58e0:	99 1f       	adc	r25, r25
    58e2:	88 0f       	add	r24, r24
    58e4:	99 1f       	adc	r25, r25
    58e6:	88 0f       	add	r24, r24
    58e8:	99 1f       	adc	r25, r25
    58ea:	82 0f       	add	r24, r18
    58ec:	93 1f       	adc	r25, r19
    58ee:	fc 01       	movw	r30, r24
    58f0:	e0 5a       	subi	r30, 0xA0	; 160
    58f2:	f9 4f       	sbci	r31, 0xF9	; 249
    58f4:	80 81       	ld	r24, Z
    58f6:	8f 5f       	subi	r24, 0xFF	; 255
    58f8:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    58fa:	ef 81       	ldd	r30, Y+7	; 0x07
    58fc:	f8 85       	ldd	r31, Y+8	; 0x08
    58fe:	96 89       	ldd	r25, Z+22	; 0x16
    5900:	e0 91 4e 06 	lds	r30, 0x064E
    5904:	f0 91 4f 06 	lds	r31, 0x064F
    5908:	86 89       	ldd	r24, Z+22	; 0x16
    590a:	89 17       	cp	r24, r25
    590c:	10 f4       	brcc	.+4      	; 0x5912 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    590e:	0e 94 8e 08 	call	0x111c	; 0x111c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5912:	0f 90       	pop	r0
    5914:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5916:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    5918:	64 96       	adiw	r28, 0x14	; 20
    591a:	0f b6       	in	r0, 0x3f	; 63
    591c:	f8 94       	cli
    591e:	de bf       	out	0x3e, r29	; 62
    5920:	0f be       	out	0x3f, r0	; 63
    5922:	cd bf       	out	0x3d, r28	; 61
    5924:	cf 91       	pop	r28
    5926:	df 91       	pop	r29
    5928:	1f 91       	pop	r17
    592a:	0f 91       	pop	r16
    592c:	ff 90       	pop	r15
    592e:	ef 90       	pop	r14
    5930:	08 95       	ret

00005932 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    5932:	cf 92       	push	r12
    5934:	df 92       	push	r13
    5936:	ef 92       	push	r14
    5938:	ff 92       	push	r15
    593a:	0f 93       	push	r16
    593c:	1f 93       	push	r17
    593e:	df 93       	push	r29
    5940:	cf 93       	push	r28
    5942:	cd b7       	in	r28, 0x3d	; 61
    5944:	de b7       	in	r29, 0x3e	; 62
    5946:	69 97       	sbiw	r28, 0x19	; 25
    5948:	0f b6       	in	r0, 0x3f	; 63
    594a:	f8 94       	cli
    594c:	de bf       	out	0x3e, r29	; 62
    594e:	0f be       	out	0x3f, r0	; 63
    5950:	cd bf       	out	0x3d, r28	; 61
    5952:	9d 87       	std	Y+13, r25	; 0x0d
    5954:	8c 87       	std	Y+12, r24	; 0x0c
    5956:	6e 87       	std	Y+14, r22	; 0x0e
    5958:	2f 87       	std	Y+15, r18	; 0x0f
    595a:	38 8b       	std	Y+16, r19	; 0x10
    595c:	49 8b       	std	Y+17, r20	; 0x11
    595e:	5a 8b       	std	Y+18, r21	; 0x12
    5960:	0b 8b       	std	Y+19, r16	; 0x13
    5962:	fd 8a       	std	Y+21, r15	; 0x15
    5964:	ec 8a       	std	Y+20, r14	; 0x14
    5966:	df 8a       	std	Y+23, r13	; 0x17
    5968:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    596a:	81 e0       	ldi	r24, 0x01	; 1
    596c:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    596e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5970:	9d 85       	ldd	r25, Y+13	; 0x0d
    5972:	9b 87       	std	Y+11, r25	; 0x0b
    5974:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5976:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    5978:	8c 89       	ldd	r24, Y+20	; 0x14
    597a:	9d 89       	ldd	r25, Y+21	; 0x15
    597c:	00 97       	sbiw	r24, 0x00	; 0
    597e:	b9 f0       	breq	.+46     	; 0x59ae <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5980:	8e 85       	ldd	r24, Y+14	; 0x0e
    5982:	88 2f       	mov	r24, r24
    5984:	90 e0       	ldi	r25, 0x00	; 0
    5986:	2a 85       	ldd	r18, Y+10	; 0x0a
    5988:	3b 85       	ldd	r19, Y+11	; 0x0b
    598a:	88 0f       	add	r24, r24
    598c:	99 1f       	adc	r25, r25
    598e:	88 0f       	add	r24, r24
    5990:	99 1f       	adc	r25, r25
    5992:	82 0f       	add	r24, r18
    5994:	93 1f       	adc	r25, r19
    5996:	fc 01       	movw	r30, r24
    5998:	b1 96       	adiw	r30, 0x21	; 33
    599a:	80 81       	ld	r24, Z
    599c:	91 81       	ldd	r25, Z+1	; 0x01
    599e:	a2 81       	ldd	r26, Z+2	; 0x02
    59a0:	b3 81       	ldd	r27, Z+3	; 0x03
    59a2:	ec 89       	ldd	r30, Y+20	; 0x14
    59a4:	fd 89       	ldd	r31, Y+21	; 0x15
    59a6:	80 83       	st	Z, r24
    59a8:	91 83       	std	Z+1, r25	; 0x01
    59aa:	a2 83       	std	Z+2, r26	; 0x02
    59ac:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    59ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    59b0:	28 2f       	mov	r18, r24
    59b2:	30 e0       	ldi	r19, 0x00	; 0
    59b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    59b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    59b8:	82 0f       	add	r24, r18
    59ba:	93 1f       	adc	r25, r19
    59bc:	fc 01       	movw	r30, r24
    59be:	b5 96       	adiw	r30, 0x25	; 37
    59c0:	80 81       	ld	r24, Z
    59c2:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    59c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    59c6:	28 2f       	mov	r18, r24
    59c8:	30 e0       	ldi	r19, 0x00	; 0
    59ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    59cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    59ce:	82 0f       	add	r24, r18
    59d0:	93 1f       	adc	r25, r19
    59d2:	fc 01       	movw	r30, r24
    59d4:	b5 96       	adiw	r30, 0x25	; 37
    59d6:	82 e0       	ldi	r24, 0x02	; 2
    59d8:	80 83       	st	Z, r24

            switch( eAction )
    59da:	8b 89       	ldd	r24, Y+19	; 0x13
    59dc:	28 2f       	mov	r18, r24
    59de:	30 e0       	ldi	r19, 0x00	; 0
    59e0:	39 8f       	std	Y+25, r19	; 0x19
    59e2:	28 8f       	std	Y+24, r18	; 0x18
    59e4:	88 8d       	ldd	r24, Y+24	; 0x18
    59e6:	99 8d       	ldd	r25, Y+25	; 0x19
    59e8:	82 30       	cpi	r24, 0x02	; 2
    59ea:	91 05       	cpc	r25, r1
    59ec:	09 f4       	brne	.+2      	; 0x59f0 <xTaskGenericNotifyFromISR+0xbe>
    59ee:	46 c0       	rjmp	.+140    	; 0x5a7c <xTaskGenericNotifyFromISR+0x14a>
    59f0:	28 8d       	ldd	r18, Y+24	; 0x18
    59f2:	39 8d       	ldd	r19, Y+25	; 0x19
    59f4:	23 30       	cpi	r18, 0x03	; 3
    59f6:	31 05       	cpc	r19, r1
    59f8:	34 f4       	brge	.+12     	; 0x5a06 <xTaskGenericNotifyFromISR+0xd4>
    59fa:	88 8d       	ldd	r24, Y+24	; 0x18
    59fc:	99 8d       	ldd	r25, Y+25	; 0x19
    59fe:	81 30       	cpi	r24, 0x01	; 1
    5a00:	91 05       	cpc	r25, r1
    5a02:	71 f0       	breq	.+28     	; 0x5a20 <xTaskGenericNotifyFromISR+0xee>
    5a04:	93 c0       	rjmp	.+294    	; 0x5b2c <xTaskGenericNotifyFromISR+0x1fa>
    5a06:	28 8d       	ldd	r18, Y+24	; 0x18
    5a08:	39 8d       	ldd	r19, Y+25	; 0x19
    5a0a:	23 30       	cpi	r18, 0x03	; 3
    5a0c:	31 05       	cpc	r19, r1
    5a0e:	09 f4       	brne	.+2      	; 0x5a12 <xTaskGenericNotifyFromISR+0xe0>
    5a10:	5d c0       	rjmp	.+186    	; 0x5acc <xTaskGenericNotifyFromISR+0x19a>
    5a12:	88 8d       	ldd	r24, Y+24	; 0x18
    5a14:	99 8d       	ldd	r25, Y+25	; 0x19
    5a16:	84 30       	cpi	r24, 0x04	; 4
    5a18:	91 05       	cpc	r25, r1
    5a1a:	09 f4       	brne	.+2      	; 0x5a1e <xTaskGenericNotifyFromISR+0xec>
    5a1c:	6d c0       	rjmp	.+218    	; 0x5af8 <xTaskGenericNotifyFromISR+0x1c6>
    5a1e:	86 c0       	rjmp	.+268    	; 0x5b2c <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5a20:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a22:	08 2f       	mov	r16, r24
    5a24:	10 e0       	ldi	r17, 0x00	; 0
    5a26:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a28:	88 2f       	mov	r24, r24
    5a2a:	90 e0       	ldi	r25, 0x00	; 0
    5a2c:	2a 85       	ldd	r18, Y+10	; 0x0a
    5a2e:	3b 85       	ldd	r19, Y+11	; 0x0b
    5a30:	88 0f       	add	r24, r24
    5a32:	99 1f       	adc	r25, r25
    5a34:	88 0f       	add	r24, r24
    5a36:	99 1f       	adc	r25, r25
    5a38:	82 0f       	add	r24, r18
    5a3a:	93 1f       	adc	r25, r19
    5a3c:	fc 01       	movw	r30, r24
    5a3e:	b1 96       	adiw	r30, 0x21	; 33
    5a40:	20 81       	ld	r18, Z
    5a42:	31 81       	ldd	r19, Z+1	; 0x01
    5a44:	42 81       	ldd	r20, Z+2	; 0x02
    5a46:	53 81       	ldd	r21, Z+3	; 0x03
    5a48:	8f 85       	ldd	r24, Y+15	; 0x0f
    5a4a:	98 89       	ldd	r25, Y+16	; 0x10
    5a4c:	a9 89       	ldd	r26, Y+17	; 0x11
    5a4e:	ba 89       	ldd	r27, Y+18	; 0x12
    5a50:	ba 01       	movw	r22, r20
    5a52:	a9 01       	movw	r20, r18
    5a54:	48 2b       	or	r20, r24
    5a56:	59 2b       	or	r21, r25
    5a58:	6a 2b       	or	r22, r26
    5a5a:	7b 2b       	or	r23, r27
    5a5c:	2a 85       	ldd	r18, Y+10	; 0x0a
    5a5e:	3b 85       	ldd	r19, Y+11	; 0x0b
    5a60:	c8 01       	movw	r24, r16
    5a62:	88 0f       	add	r24, r24
    5a64:	99 1f       	adc	r25, r25
    5a66:	88 0f       	add	r24, r24
    5a68:	99 1f       	adc	r25, r25
    5a6a:	82 0f       	add	r24, r18
    5a6c:	93 1f       	adc	r25, r19
    5a6e:	fc 01       	movw	r30, r24
    5a70:	b1 96       	adiw	r30, 0x21	; 33
    5a72:	40 83       	st	Z, r20
    5a74:	51 83       	std	Z+1, r21	; 0x01
    5a76:	62 83       	std	Z+2, r22	; 0x02
    5a78:	73 83       	std	Z+3, r23	; 0x03
    5a7a:	58 c0       	rjmp	.+176    	; 0x5b2c <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5a7c:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a7e:	08 2f       	mov	r16, r24
    5a80:	10 e0       	ldi	r17, 0x00	; 0
    5a82:	2a 85       	ldd	r18, Y+10	; 0x0a
    5a84:	3b 85       	ldd	r19, Y+11	; 0x0b
    5a86:	c8 01       	movw	r24, r16
    5a88:	88 0f       	add	r24, r24
    5a8a:	99 1f       	adc	r25, r25
    5a8c:	88 0f       	add	r24, r24
    5a8e:	99 1f       	adc	r25, r25
    5a90:	82 0f       	add	r24, r18
    5a92:	93 1f       	adc	r25, r19
    5a94:	fc 01       	movw	r30, r24
    5a96:	b1 96       	adiw	r30, 0x21	; 33
    5a98:	80 81       	ld	r24, Z
    5a9a:	91 81       	ldd	r25, Z+1	; 0x01
    5a9c:	a2 81       	ldd	r26, Z+2	; 0x02
    5a9e:	b3 81       	ldd	r27, Z+3	; 0x03
    5aa0:	ac 01       	movw	r20, r24
    5aa2:	bd 01       	movw	r22, r26
    5aa4:	4f 5f       	subi	r20, 0xFF	; 255
    5aa6:	5f 4f       	sbci	r21, 0xFF	; 255
    5aa8:	6f 4f       	sbci	r22, 0xFF	; 255
    5aaa:	7f 4f       	sbci	r23, 0xFF	; 255
    5aac:	2a 85       	ldd	r18, Y+10	; 0x0a
    5aae:	3b 85       	ldd	r19, Y+11	; 0x0b
    5ab0:	c8 01       	movw	r24, r16
    5ab2:	88 0f       	add	r24, r24
    5ab4:	99 1f       	adc	r25, r25
    5ab6:	88 0f       	add	r24, r24
    5ab8:	99 1f       	adc	r25, r25
    5aba:	82 0f       	add	r24, r18
    5abc:	93 1f       	adc	r25, r19
    5abe:	fc 01       	movw	r30, r24
    5ac0:	b1 96       	adiw	r30, 0x21	; 33
    5ac2:	40 83       	st	Z, r20
    5ac4:	51 83       	std	Z+1, r21	; 0x01
    5ac6:	62 83       	std	Z+2, r22	; 0x02
    5ac8:	73 83       	std	Z+3, r23	; 0x03
    5aca:	30 c0       	rjmp	.+96     	; 0x5b2c <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5acc:	8e 85       	ldd	r24, Y+14	; 0x0e
    5ace:	88 2f       	mov	r24, r24
    5ad0:	90 e0       	ldi	r25, 0x00	; 0
    5ad2:	2a 85       	ldd	r18, Y+10	; 0x0a
    5ad4:	3b 85       	ldd	r19, Y+11	; 0x0b
    5ad6:	88 0f       	add	r24, r24
    5ad8:	99 1f       	adc	r25, r25
    5ada:	88 0f       	add	r24, r24
    5adc:	99 1f       	adc	r25, r25
    5ade:	82 0f       	add	r24, r18
    5ae0:	93 1f       	adc	r25, r19
    5ae2:	fc 01       	movw	r30, r24
    5ae4:	b1 96       	adiw	r30, 0x21	; 33
    5ae6:	8f 85       	ldd	r24, Y+15	; 0x0f
    5ae8:	98 89       	ldd	r25, Y+16	; 0x10
    5aea:	a9 89       	ldd	r26, Y+17	; 0x11
    5aec:	ba 89       	ldd	r27, Y+18	; 0x12
    5aee:	80 83       	st	Z, r24
    5af0:	91 83       	std	Z+1, r25	; 0x01
    5af2:	a2 83       	std	Z+2, r26	; 0x02
    5af4:	b3 83       	std	Z+3, r27	; 0x03
    5af6:	1a c0       	rjmp	.+52     	; 0x5b2c <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5af8:	89 85       	ldd	r24, Y+9	; 0x09
    5afa:	82 30       	cpi	r24, 0x02	; 2
    5afc:	b1 f0       	breq	.+44     	; 0x5b2a <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5afe:	8e 85       	ldd	r24, Y+14	; 0x0e
    5b00:	88 2f       	mov	r24, r24
    5b02:	90 e0       	ldi	r25, 0x00	; 0
    5b04:	2a 85       	ldd	r18, Y+10	; 0x0a
    5b06:	3b 85       	ldd	r19, Y+11	; 0x0b
    5b08:	88 0f       	add	r24, r24
    5b0a:	99 1f       	adc	r25, r25
    5b0c:	88 0f       	add	r24, r24
    5b0e:	99 1f       	adc	r25, r25
    5b10:	82 0f       	add	r24, r18
    5b12:	93 1f       	adc	r25, r19
    5b14:	fc 01       	movw	r30, r24
    5b16:	b1 96       	adiw	r30, 0x21	; 33
    5b18:	8f 85       	ldd	r24, Y+15	; 0x0f
    5b1a:	98 89       	ldd	r25, Y+16	; 0x10
    5b1c:	a9 89       	ldd	r26, Y+17	; 0x11
    5b1e:	ba 89       	ldd	r27, Y+18	; 0x12
    5b20:	80 83       	st	Z, r24
    5b22:	91 83       	std	Z+1, r25	; 0x01
    5b24:	a2 83       	std	Z+2, r26	; 0x02
    5b26:	b3 83       	std	Z+3, r27	; 0x03
    5b28:	01 c0       	rjmp	.+2      	; 0x5b2c <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5b2a:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5b2c:	89 85       	ldd	r24, Y+9	; 0x09
    5b2e:	81 30       	cpi	r24, 0x01	; 1
    5b30:	09 f0       	breq	.+2      	; 0x5b34 <xTaskGenericNotifyFromISR+0x202>
    5b32:	ee c0       	rjmp	.+476    	; 0x5d10 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5b34:	80 91 5f 06 	lds	r24, 0x065F
    5b38:	88 23       	and	r24, r24
    5b3a:	09 f0       	breq	.+2      	; 0x5b3e <xTaskGenericNotifyFromISR+0x20c>
    5b3c:	a4 c0       	rjmp	.+328    	; 0x5c86 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5b3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5b40:	fb 85       	ldd	r31, Y+11	; 0x0b
    5b42:	82 85       	ldd	r24, Z+10	; 0x0a
    5b44:	93 85       	ldd	r25, Z+11	; 0x0b
    5b46:	9e 83       	std	Y+6, r25	; 0x06
    5b48:	8d 83       	std	Y+5, r24	; 0x05
    5b4a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5b4c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5b4e:	a4 81       	ldd	r26, Z+4	; 0x04
    5b50:	b5 81       	ldd	r27, Z+5	; 0x05
    5b52:	ea 85       	ldd	r30, Y+10	; 0x0a
    5b54:	fb 85       	ldd	r31, Y+11	; 0x0b
    5b56:	86 81       	ldd	r24, Z+6	; 0x06
    5b58:	97 81       	ldd	r25, Z+7	; 0x07
    5b5a:	15 96       	adiw	r26, 0x05	; 5
    5b5c:	9c 93       	st	X, r25
    5b5e:	8e 93       	st	-X, r24
    5b60:	14 97       	sbiw	r26, 0x04	; 4
    5b62:	ea 85       	ldd	r30, Y+10	; 0x0a
    5b64:	fb 85       	ldd	r31, Y+11	; 0x0b
    5b66:	a6 81       	ldd	r26, Z+6	; 0x06
    5b68:	b7 81       	ldd	r27, Z+7	; 0x07
    5b6a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5b6c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5b6e:	84 81       	ldd	r24, Z+4	; 0x04
    5b70:	95 81       	ldd	r25, Z+5	; 0x05
    5b72:	13 96       	adiw	r26, 0x03	; 3
    5b74:	9c 93       	st	X, r25
    5b76:	8e 93       	st	-X, r24
    5b78:	12 97       	sbiw	r26, 0x02	; 2
    5b7a:	ed 81       	ldd	r30, Y+5	; 0x05
    5b7c:	fe 81       	ldd	r31, Y+6	; 0x06
    5b7e:	21 81       	ldd	r18, Z+1	; 0x01
    5b80:	32 81       	ldd	r19, Z+2	; 0x02
    5b82:	8a 85       	ldd	r24, Y+10	; 0x0a
    5b84:	9b 85       	ldd	r25, Y+11	; 0x0b
    5b86:	02 96       	adiw	r24, 0x02	; 2
    5b88:	28 17       	cp	r18, r24
    5b8a:	39 07       	cpc	r19, r25
    5b8c:	41 f4       	brne	.+16     	; 0x5b9e <xTaskGenericNotifyFromISR+0x26c>
    5b8e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5b90:	fb 85       	ldd	r31, Y+11	; 0x0b
    5b92:	86 81       	ldd	r24, Z+6	; 0x06
    5b94:	97 81       	ldd	r25, Z+7	; 0x07
    5b96:	ed 81       	ldd	r30, Y+5	; 0x05
    5b98:	fe 81       	ldd	r31, Y+6	; 0x06
    5b9a:	92 83       	std	Z+2, r25	; 0x02
    5b9c:	81 83       	std	Z+1, r24	; 0x01
    5b9e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ba0:	fb 85       	ldd	r31, Y+11	; 0x0b
    5ba2:	13 86       	std	Z+11, r1	; 0x0b
    5ba4:	12 86       	std	Z+10, r1	; 0x0a
    5ba6:	ed 81       	ldd	r30, Y+5	; 0x05
    5ba8:	fe 81       	ldd	r31, Y+6	; 0x06
    5baa:	80 81       	ld	r24, Z
    5bac:	81 50       	subi	r24, 0x01	; 1
    5bae:	ed 81       	ldd	r30, Y+5	; 0x05
    5bb0:	fe 81       	ldd	r31, Y+6	; 0x06
    5bb2:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5bb4:	ea 85       	ldd	r30, Y+10	; 0x0a
    5bb6:	fb 85       	ldd	r31, Y+11	; 0x0b
    5bb8:	96 89       	ldd	r25, Z+22	; 0x16
    5bba:	80 91 54 06 	lds	r24, 0x0654
    5bbe:	89 17       	cp	r24, r25
    5bc0:	28 f4       	brcc	.+10     	; 0x5bcc <xTaskGenericNotifyFromISR+0x29a>
    5bc2:	ea 85       	ldd	r30, Y+10	; 0x0a
    5bc4:	fb 85       	ldd	r31, Y+11	; 0x0b
    5bc6:	86 89       	ldd	r24, Z+22	; 0x16
    5bc8:	80 93 54 06 	sts	0x0654, r24
    5bcc:	ea 85       	ldd	r30, Y+10	; 0x0a
    5bce:	fb 85       	ldd	r31, Y+11	; 0x0b
    5bd0:	86 89       	ldd	r24, Z+22	; 0x16
    5bd2:	28 2f       	mov	r18, r24
    5bd4:	30 e0       	ldi	r19, 0x00	; 0
    5bd6:	c9 01       	movw	r24, r18
    5bd8:	88 0f       	add	r24, r24
    5bda:	99 1f       	adc	r25, r25
    5bdc:	88 0f       	add	r24, r24
    5bde:	99 1f       	adc	r25, r25
    5be0:	88 0f       	add	r24, r24
    5be2:	99 1f       	adc	r25, r25
    5be4:	82 0f       	add	r24, r18
    5be6:	93 1f       	adc	r25, r19
    5be8:	fc 01       	movw	r30, r24
    5bea:	e0 5a       	subi	r30, 0xA0	; 160
    5bec:	f9 4f       	sbci	r31, 0xF9	; 249
    5bee:	81 81       	ldd	r24, Z+1	; 0x01
    5bf0:	92 81       	ldd	r25, Z+2	; 0x02
    5bf2:	9c 83       	std	Y+4, r25	; 0x04
    5bf4:	8b 83       	std	Y+3, r24	; 0x03
    5bf6:	ea 85       	ldd	r30, Y+10	; 0x0a
    5bf8:	fb 85       	ldd	r31, Y+11	; 0x0b
    5bfa:	8b 81       	ldd	r24, Y+3	; 0x03
    5bfc:	9c 81       	ldd	r25, Y+4	; 0x04
    5bfe:	95 83       	std	Z+5, r25	; 0x05
    5c00:	84 83       	std	Z+4, r24	; 0x04
    5c02:	eb 81       	ldd	r30, Y+3	; 0x03
    5c04:	fc 81       	ldd	r31, Y+4	; 0x04
    5c06:	84 81       	ldd	r24, Z+4	; 0x04
    5c08:	95 81       	ldd	r25, Z+5	; 0x05
    5c0a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c0c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c0e:	97 83       	std	Z+7, r25	; 0x07
    5c10:	86 83       	std	Z+6, r24	; 0x06
    5c12:	eb 81       	ldd	r30, Y+3	; 0x03
    5c14:	fc 81       	ldd	r31, Y+4	; 0x04
    5c16:	04 80       	ldd	r0, Z+4	; 0x04
    5c18:	f5 81       	ldd	r31, Z+5	; 0x05
    5c1a:	e0 2d       	mov	r30, r0
    5c1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c20:	02 96       	adiw	r24, 0x02	; 2
    5c22:	93 83       	std	Z+3, r25	; 0x03
    5c24:	82 83       	std	Z+2, r24	; 0x02
    5c26:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c28:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c2a:	02 96       	adiw	r24, 0x02	; 2
    5c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    5c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    5c30:	95 83       	std	Z+5, r25	; 0x05
    5c32:	84 83       	std	Z+4, r24	; 0x04
    5c34:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c36:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c38:	86 89       	ldd	r24, Z+22	; 0x16
    5c3a:	28 2f       	mov	r18, r24
    5c3c:	30 e0       	ldi	r19, 0x00	; 0
    5c3e:	c9 01       	movw	r24, r18
    5c40:	88 0f       	add	r24, r24
    5c42:	99 1f       	adc	r25, r25
    5c44:	88 0f       	add	r24, r24
    5c46:	99 1f       	adc	r25, r25
    5c48:	88 0f       	add	r24, r24
    5c4a:	99 1f       	adc	r25, r25
    5c4c:	82 0f       	add	r24, r18
    5c4e:	93 1f       	adc	r25, r19
    5c50:	80 5a       	subi	r24, 0xA0	; 160
    5c52:	99 4f       	sbci	r25, 0xF9	; 249
    5c54:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c56:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c58:	93 87       	std	Z+11, r25	; 0x0b
    5c5a:	82 87       	std	Z+10, r24	; 0x0a
    5c5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c60:	86 89       	ldd	r24, Z+22	; 0x16
    5c62:	28 2f       	mov	r18, r24
    5c64:	30 e0       	ldi	r19, 0x00	; 0
    5c66:	c9 01       	movw	r24, r18
    5c68:	88 0f       	add	r24, r24
    5c6a:	99 1f       	adc	r25, r25
    5c6c:	88 0f       	add	r24, r24
    5c6e:	99 1f       	adc	r25, r25
    5c70:	88 0f       	add	r24, r24
    5c72:	99 1f       	adc	r25, r25
    5c74:	82 0f       	add	r24, r18
    5c76:	93 1f       	adc	r25, r19
    5c78:	fc 01       	movw	r30, r24
    5c7a:	e0 5a       	subi	r30, 0xA0	; 160
    5c7c:	f9 4f       	sbci	r31, 0xF9	; 249
    5c7e:	80 81       	ld	r24, Z
    5c80:	8f 5f       	subi	r24, 0xFF	; 255
    5c82:	80 83       	st	Z, r24
    5c84:	30 c0       	rjmp	.+96     	; 0x5ce6 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5c86:	80 91 9b 06 	lds	r24, 0x069B
    5c8a:	90 91 9c 06 	lds	r25, 0x069C
    5c8e:	9a 83       	std	Y+2, r25	; 0x02
    5c90:	89 83       	std	Y+1, r24	; 0x01
    5c92:	ea 85       	ldd	r30, Y+10	; 0x0a
    5c94:	fb 85       	ldd	r31, Y+11	; 0x0b
    5c96:	89 81       	ldd	r24, Y+1	; 0x01
    5c98:	9a 81       	ldd	r25, Y+2	; 0x02
    5c9a:	97 87       	std	Z+15, r25	; 0x0f
    5c9c:	86 87       	std	Z+14, r24	; 0x0e
    5c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    5ca0:	fa 81       	ldd	r31, Y+2	; 0x02
    5ca2:	84 81       	ldd	r24, Z+4	; 0x04
    5ca4:	95 81       	ldd	r25, Z+5	; 0x05
    5ca6:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ca8:	fb 85       	ldd	r31, Y+11	; 0x0b
    5caa:	91 8b       	std	Z+17, r25	; 0x11
    5cac:	80 8b       	std	Z+16, r24	; 0x10
    5cae:	e9 81       	ldd	r30, Y+1	; 0x01
    5cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    5cb2:	04 80       	ldd	r0, Z+4	; 0x04
    5cb4:	f5 81       	ldd	r31, Z+5	; 0x05
    5cb6:	e0 2d       	mov	r30, r0
    5cb8:	8a 85       	ldd	r24, Y+10	; 0x0a
    5cba:	9b 85       	ldd	r25, Y+11	; 0x0b
    5cbc:	0c 96       	adiw	r24, 0x0c	; 12
    5cbe:	93 83       	std	Z+3, r25	; 0x03
    5cc0:	82 83       	std	Z+2, r24	; 0x02
    5cc2:	8a 85       	ldd	r24, Y+10	; 0x0a
    5cc4:	9b 85       	ldd	r25, Y+11	; 0x0b
    5cc6:	0c 96       	adiw	r24, 0x0c	; 12
    5cc8:	e9 81       	ldd	r30, Y+1	; 0x01
    5cca:	fa 81       	ldd	r31, Y+2	; 0x02
    5ccc:	95 83       	std	Z+5, r25	; 0x05
    5cce:	84 83       	std	Z+4, r24	; 0x04
    5cd0:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cd2:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cd4:	8a e9       	ldi	r24, 0x9A	; 154
    5cd6:	96 e0       	ldi	r25, 0x06	; 6
    5cd8:	95 8b       	std	Z+21, r25	; 0x15
    5cda:	84 8b       	std	Z+20, r24	; 0x14
    5cdc:	80 91 9a 06 	lds	r24, 0x069A
    5ce0:	8f 5f       	subi	r24, 0xFF	; 255
    5ce2:	80 93 9a 06 	sts	0x069A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ce6:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ce8:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cea:	96 89       	ldd	r25, Z+22	; 0x16
    5cec:	e0 91 4e 06 	lds	r30, 0x064E
    5cf0:	f0 91 4f 06 	lds	r31, 0x064F
    5cf4:	86 89       	ldd	r24, Z+22	; 0x16
    5cf6:	89 17       	cp	r24, r25
    5cf8:	58 f4       	brcc	.+22     	; 0x5d10 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5cfa:	8e 89       	ldd	r24, Y+22	; 0x16
    5cfc:	9f 89       	ldd	r25, Y+23	; 0x17
    5cfe:	00 97       	sbiw	r24, 0x00	; 0
    5d00:	21 f0       	breq	.+8      	; 0x5d0a <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5d02:	ee 89       	ldd	r30, Y+22	; 0x16
    5d04:	ff 89       	ldd	r31, Y+23	; 0x17
    5d06:	81 e0       	ldi	r24, 0x01	; 1
    5d08:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5d0a:	81 e0       	ldi	r24, 0x01	; 1
    5d0c:	80 93 58 06 	sts	0x0658, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    5d10:	88 85       	ldd	r24, Y+8	; 0x08
    }
    5d12:	69 96       	adiw	r28, 0x19	; 25
    5d14:	0f b6       	in	r0, 0x3f	; 63
    5d16:	f8 94       	cli
    5d18:	de bf       	out	0x3e, r29	; 62
    5d1a:	0f be       	out	0x3f, r0	; 63
    5d1c:	cd bf       	out	0x3d, r28	; 61
    5d1e:	cf 91       	pop	r28
    5d20:	df 91       	pop	r29
    5d22:	1f 91       	pop	r17
    5d24:	0f 91       	pop	r16
    5d26:	ff 90       	pop	r15
    5d28:	ef 90       	pop	r14
    5d2a:	df 90       	pop	r13
    5d2c:	cf 90       	pop	r12
    5d2e:	08 95       	ret

00005d30 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5d30:	0f 93       	push	r16
    5d32:	1f 93       	push	r17
    5d34:	df 93       	push	r29
    5d36:	cf 93       	push	r28
    5d38:	cd b7       	in	r28, 0x3d	; 61
    5d3a:	de b7       	in	r29, 0x3e	; 62
    5d3c:	2f 97       	sbiw	r28, 0x0f	; 15
    5d3e:	0f b6       	in	r0, 0x3f	; 63
    5d40:	f8 94       	cli
    5d42:	de bf       	out	0x3e, r29	; 62
    5d44:	0f be       	out	0x3f, r0	; 63
    5d46:	cd bf       	out	0x3d, r28	; 61
    5d48:	9c 87       	std	Y+12, r25	; 0x0c
    5d4a:	8b 87       	std	Y+11, r24	; 0x0b
    5d4c:	6d 87       	std	Y+13, r22	; 0x0d
    5d4e:	5f 87       	std	Y+15, r21	; 0x0f
    5d50:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5d52:	8b 85       	ldd	r24, Y+11	; 0x0b
    5d54:	9c 85       	ldd	r25, Y+12	; 0x0c
    5d56:	9a 87       	std	Y+10, r25	; 0x0a
    5d58:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5d5a:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5d5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    5d5e:	28 2f       	mov	r18, r24
    5d60:	30 e0       	ldi	r19, 0x00	; 0
    5d62:	89 85       	ldd	r24, Y+9	; 0x09
    5d64:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d66:	82 0f       	add	r24, r18
    5d68:	93 1f       	adc	r25, r19
    5d6a:	fc 01       	movw	r30, r24
    5d6c:	b5 96       	adiw	r30, 0x25	; 37
    5d6e:	80 81       	ld	r24, Z
    5d70:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5d72:	8d 85       	ldd	r24, Y+13	; 0x0d
    5d74:	28 2f       	mov	r18, r24
    5d76:	30 e0       	ldi	r19, 0x00	; 0
    5d78:	89 85       	ldd	r24, Y+9	; 0x09
    5d7a:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d7c:	82 0f       	add	r24, r18
    5d7e:	93 1f       	adc	r25, r19
    5d80:	fc 01       	movw	r30, r24
    5d82:	b5 96       	adiw	r30, 0x25	; 37
    5d84:	82 e0       	ldi	r24, 0x02	; 2
    5d86:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5d88:	8d 85       	ldd	r24, Y+13	; 0x0d
    5d8a:	08 2f       	mov	r16, r24
    5d8c:	10 e0       	ldi	r17, 0x00	; 0
    5d8e:	29 85       	ldd	r18, Y+9	; 0x09
    5d90:	3a 85       	ldd	r19, Y+10	; 0x0a
    5d92:	c8 01       	movw	r24, r16
    5d94:	88 0f       	add	r24, r24
    5d96:	99 1f       	adc	r25, r25
    5d98:	88 0f       	add	r24, r24
    5d9a:	99 1f       	adc	r25, r25
    5d9c:	82 0f       	add	r24, r18
    5d9e:	93 1f       	adc	r25, r19
    5da0:	fc 01       	movw	r30, r24
    5da2:	b1 96       	adiw	r30, 0x21	; 33
    5da4:	80 81       	ld	r24, Z
    5da6:	91 81       	ldd	r25, Z+1	; 0x01
    5da8:	a2 81       	ldd	r26, Z+2	; 0x02
    5daa:	b3 81       	ldd	r27, Z+3	; 0x03
    5dac:	ac 01       	movw	r20, r24
    5dae:	bd 01       	movw	r22, r26
    5db0:	4f 5f       	subi	r20, 0xFF	; 255
    5db2:	5f 4f       	sbci	r21, 0xFF	; 255
    5db4:	6f 4f       	sbci	r22, 0xFF	; 255
    5db6:	7f 4f       	sbci	r23, 0xFF	; 255
    5db8:	29 85       	ldd	r18, Y+9	; 0x09
    5dba:	3a 85       	ldd	r19, Y+10	; 0x0a
    5dbc:	c8 01       	movw	r24, r16
    5dbe:	88 0f       	add	r24, r24
    5dc0:	99 1f       	adc	r25, r25
    5dc2:	88 0f       	add	r24, r24
    5dc4:	99 1f       	adc	r25, r25
    5dc6:	82 0f       	add	r24, r18
    5dc8:	93 1f       	adc	r25, r19
    5dca:	fc 01       	movw	r30, r24
    5dcc:	b1 96       	adiw	r30, 0x21	; 33
    5dce:	40 83       	st	Z, r20
    5dd0:	51 83       	std	Z+1, r21	; 0x01
    5dd2:	62 83       	std	Z+2, r22	; 0x02
    5dd4:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5dd6:	88 85       	ldd	r24, Y+8	; 0x08
    5dd8:	81 30       	cpi	r24, 0x01	; 1
    5dda:	09 f0       	breq	.+2      	; 0x5dde <vTaskGenericNotifyGiveFromISR+0xae>
    5ddc:	ee c0       	rjmp	.+476    	; 0x5fba <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5dde:	80 91 5f 06 	lds	r24, 0x065F
    5de2:	88 23       	and	r24, r24
    5de4:	09 f0       	breq	.+2      	; 0x5de8 <vTaskGenericNotifyGiveFromISR+0xb8>
    5de6:	a4 c0       	rjmp	.+328    	; 0x5f30 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5de8:	e9 85       	ldd	r30, Y+9	; 0x09
    5dea:	fa 85       	ldd	r31, Y+10	; 0x0a
    5dec:	82 85       	ldd	r24, Z+10	; 0x0a
    5dee:	93 85       	ldd	r25, Z+11	; 0x0b
    5df0:	9e 83       	std	Y+6, r25	; 0x06
    5df2:	8d 83       	std	Y+5, r24	; 0x05
    5df4:	e9 85       	ldd	r30, Y+9	; 0x09
    5df6:	fa 85       	ldd	r31, Y+10	; 0x0a
    5df8:	a4 81       	ldd	r26, Z+4	; 0x04
    5dfa:	b5 81       	ldd	r27, Z+5	; 0x05
    5dfc:	e9 85       	ldd	r30, Y+9	; 0x09
    5dfe:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e00:	86 81       	ldd	r24, Z+6	; 0x06
    5e02:	97 81       	ldd	r25, Z+7	; 0x07
    5e04:	15 96       	adiw	r26, 0x05	; 5
    5e06:	9c 93       	st	X, r25
    5e08:	8e 93       	st	-X, r24
    5e0a:	14 97       	sbiw	r26, 0x04	; 4
    5e0c:	e9 85       	ldd	r30, Y+9	; 0x09
    5e0e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e10:	a6 81       	ldd	r26, Z+6	; 0x06
    5e12:	b7 81       	ldd	r27, Z+7	; 0x07
    5e14:	e9 85       	ldd	r30, Y+9	; 0x09
    5e16:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e18:	84 81       	ldd	r24, Z+4	; 0x04
    5e1a:	95 81       	ldd	r25, Z+5	; 0x05
    5e1c:	13 96       	adiw	r26, 0x03	; 3
    5e1e:	9c 93       	st	X, r25
    5e20:	8e 93       	st	-X, r24
    5e22:	12 97       	sbiw	r26, 0x02	; 2
    5e24:	ed 81       	ldd	r30, Y+5	; 0x05
    5e26:	fe 81       	ldd	r31, Y+6	; 0x06
    5e28:	21 81       	ldd	r18, Z+1	; 0x01
    5e2a:	32 81       	ldd	r19, Z+2	; 0x02
    5e2c:	89 85       	ldd	r24, Y+9	; 0x09
    5e2e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e30:	02 96       	adiw	r24, 0x02	; 2
    5e32:	28 17       	cp	r18, r24
    5e34:	39 07       	cpc	r19, r25
    5e36:	41 f4       	brne	.+16     	; 0x5e48 <vTaskGenericNotifyGiveFromISR+0x118>
    5e38:	e9 85       	ldd	r30, Y+9	; 0x09
    5e3a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e3c:	86 81       	ldd	r24, Z+6	; 0x06
    5e3e:	97 81       	ldd	r25, Z+7	; 0x07
    5e40:	ed 81       	ldd	r30, Y+5	; 0x05
    5e42:	fe 81       	ldd	r31, Y+6	; 0x06
    5e44:	92 83       	std	Z+2, r25	; 0x02
    5e46:	81 83       	std	Z+1, r24	; 0x01
    5e48:	e9 85       	ldd	r30, Y+9	; 0x09
    5e4a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e4c:	13 86       	std	Z+11, r1	; 0x0b
    5e4e:	12 86       	std	Z+10, r1	; 0x0a
    5e50:	ed 81       	ldd	r30, Y+5	; 0x05
    5e52:	fe 81       	ldd	r31, Y+6	; 0x06
    5e54:	80 81       	ld	r24, Z
    5e56:	81 50       	subi	r24, 0x01	; 1
    5e58:	ed 81       	ldd	r30, Y+5	; 0x05
    5e5a:	fe 81       	ldd	r31, Y+6	; 0x06
    5e5c:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5e5e:	e9 85       	ldd	r30, Y+9	; 0x09
    5e60:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e62:	96 89       	ldd	r25, Z+22	; 0x16
    5e64:	80 91 54 06 	lds	r24, 0x0654
    5e68:	89 17       	cp	r24, r25
    5e6a:	28 f4       	brcc	.+10     	; 0x5e76 <vTaskGenericNotifyGiveFromISR+0x146>
    5e6c:	e9 85       	ldd	r30, Y+9	; 0x09
    5e6e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e70:	86 89       	ldd	r24, Z+22	; 0x16
    5e72:	80 93 54 06 	sts	0x0654, r24
    5e76:	e9 85       	ldd	r30, Y+9	; 0x09
    5e78:	fa 85       	ldd	r31, Y+10	; 0x0a
    5e7a:	86 89       	ldd	r24, Z+22	; 0x16
    5e7c:	28 2f       	mov	r18, r24
    5e7e:	30 e0       	ldi	r19, 0x00	; 0
    5e80:	c9 01       	movw	r24, r18
    5e82:	88 0f       	add	r24, r24
    5e84:	99 1f       	adc	r25, r25
    5e86:	88 0f       	add	r24, r24
    5e88:	99 1f       	adc	r25, r25
    5e8a:	88 0f       	add	r24, r24
    5e8c:	99 1f       	adc	r25, r25
    5e8e:	82 0f       	add	r24, r18
    5e90:	93 1f       	adc	r25, r19
    5e92:	fc 01       	movw	r30, r24
    5e94:	e0 5a       	subi	r30, 0xA0	; 160
    5e96:	f9 4f       	sbci	r31, 0xF9	; 249
    5e98:	81 81       	ldd	r24, Z+1	; 0x01
    5e9a:	92 81       	ldd	r25, Z+2	; 0x02
    5e9c:	9c 83       	std	Y+4, r25	; 0x04
    5e9e:	8b 83       	std	Y+3, r24	; 0x03
    5ea0:	e9 85       	ldd	r30, Y+9	; 0x09
    5ea2:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ea4:	8b 81       	ldd	r24, Y+3	; 0x03
    5ea6:	9c 81       	ldd	r25, Y+4	; 0x04
    5ea8:	95 83       	std	Z+5, r25	; 0x05
    5eaa:	84 83       	std	Z+4, r24	; 0x04
    5eac:	eb 81       	ldd	r30, Y+3	; 0x03
    5eae:	fc 81       	ldd	r31, Y+4	; 0x04
    5eb0:	84 81       	ldd	r24, Z+4	; 0x04
    5eb2:	95 81       	ldd	r25, Z+5	; 0x05
    5eb4:	e9 85       	ldd	r30, Y+9	; 0x09
    5eb6:	fa 85       	ldd	r31, Y+10	; 0x0a
    5eb8:	97 83       	std	Z+7, r25	; 0x07
    5eba:	86 83       	std	Z+6, r24	; 0x06
    5ebc:	eb 81       	ldd	r30, Y+3	; 0x03
    5ebe:	fc 81       	ldd	r31, Y+4	; 0x04
    5ec0:	04 80       	ldd	r0, Z+4	; 0x04
    5ec2:	f5 81       	ldd	r31, Z+5	; 0x05
    5ec4:	e0 2d       	mov	r30, r0
    5ec6:	89 85       	ldd	r24, Y+9	; 0x09
    5ec8:	9a 85       	ldd	r25, Y+10	; 0x0a
    5eca:	02 96       	adiw	r24, 0x02	; 2
    5ecc:	93 83       	std	Z+3, r25	; 0x03
    5ece:	82 83       	std	Z+2, r24	; 0x02
    5ed0:	89 85       	ldd	r24, Y+9	; 0x09
    5ed2:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ed4:	02 96       	adiw	r24, 0x02	; 2
    5ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    5ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    5eda:	95 83       	std	Z+5, r25	; 0x05
    5edc:	84 83       	std	Z+4, r24	; 0x04
    5ede:	e9 85       	ldd	r30, Y+9	; 0x09
    5ee0:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ee2:	86 89       	ldd	r24, Z+22	; 0x16
    5ee4:	28 2f       	mov	r18, r24
    5ee6:	30 e0       	ldi	r19, 0x00	; 0
    5ee8:	c9 01       	movw	r24, r18
    5eea:	88 0f       	add	r24, r24
    5eec:	99 1f       	adc	r25, r25
    5eee:	88 0f       	add	r24, r24
    5ef0:	99 1f       	adc	r25, r25
    5ef2:	88 0f       	add	r24, r24
    5ef4:	99 1f       	adc	r25, r25
    5ef6:	82 0f       	add	r24, r18
    5ef8:	93 1f       	adc	r25, r19
    5efa:	80 5a       	subi	r24, 0xA0	; 160
    5efc:	99 4f       	sbci	r25, 0xF9	; 249
    5efe:	e9 85       	ldd	r30, Y+9	; 0x09
    5f00:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f02:	93 87       	std	Z+11, r25	; 0x0b
    5f04:	82 87       	std	Z+10, r24	; 0x0a
    5f06:	e9 85       	ldd	r30, Y+9	; 0x09
    5f08:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f0a:	86 89       	ldd	r24, Z+22	; 0x16
    5f0c:	28 2f       	mov	r18, r24
    5f0e:	30 e0       	ldi	r19, 0x00	; 0
    5f10:	c9 01       	movw	r24, r18
    5f12:	88 0f       	add	r24, r24
    5f14:	99 1f       	adc	r25, r25
    5f16:	88 0f       	add	r24, r24
    5f18:	99 1f       	adc	r25, r25
    5f1a:	88 0f       	add	r24, r24
    5f1c:	99 1f       	adc	r25, r25
    5f1e:	82 0f       	add	r24, r18
    5f20:	93 1f       	adc	r25, r19
    5f22:	fc 01       	movw	r30, r24
    5f24:	e0 5a       	subi	r30, 0xA0	; 160
    5f26:	f9 4f       	sbci	r31, 0xF9	; 249
    5f28:	80 81       	ld	r24, Z
    5f2a:	8f 5f       	subi	r24, 0xFF	; 255
    5f2c:	80 83       	st	Z, r24
    5f2e:	30 c0       	rjmp	.+96     	; 0x5f90 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5f30:	80 91 9b 06 	lds	r24, 0x069B
    5f34:	90 91 9c 06 	lds	r25, 0x069C
    5f38:	9a 83       	std	Y+2, r25	; 0x02
    5f3a:	89 83       	std	Y+1, r24	; 0x01
    5f3c:	e9 85       	ldd	r30, Y+9	; 0x09
    5f3e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f40:	89 81       	ldd	r24, Y+1	; 0x01
    5f42:	9a 81       	ldd	r25, Y+2	; 0x02
    5f44:	97 87       	std	Z+15, r25	; 0x0f
    5f46:	86 87       	std	Z+14, r24	; 0x0e
    5f48:	e9 81       	ldd	r30, Y+1	; 0x01
    5f4a:	fa 81       	ldd	r31, Y+2	; 0x02
    5f4c:	84 81       	ldd	r24, Z+4	; 0x04
    5f4e:	95 81       	ldd	r25, Z+5	; 0x05
    5f50:	e9 85       	ldd	r30, Y+9	; 0x09
    5f52:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f54:	91 8b       	std	Z+17, r25	; 0x11
    5f56:	80 8b       	std	Z+16, r24	; 0x10
    5f58:	e9 81       	ldd	r30, Y+1	; 0x01
    5f5a:	fa 81       	ldd	r31, Y+2	; 0x02
    5f5c:	04 80       	ldd	r0, Z+4	; 0x04
    5f5e:	f5 81       	ldd	r31, Z+5	; 0x05
    5f60:	e0 2d       	mov	r30, r0
    5f62:	89 85       	ldd	r24, Y+9	; 0x09
    5f64:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f66:	0c 96       	adiw	r24, 0x0c	; 12
    5f68:	93 83       	std	Z+3, r25	; 0x03
    5f6a:	82 83       	std	Z+2, r24	; 0x02
    5f6c:	89 85       	ldd	r24, Y+9	; 0x09
    5f6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f70:	0c 96       	adiw	r24, 0x0c	; 12
    5f72:	e9 81       	ldd	r30, Y+1	; 0x01
    5f74:	fa 81       	ldd	r31, Y+2	; 0x02
    5f76:	95 83       	std	Z+5, r25	; 0x05
    5f78:	84 83       	std	Z+4, r24	; 0x04
    5f7a:	e9 85       	ldd	r30, Y+9	; 0x09
    5f7c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f7e:	8a e9       	ldi	r24, 0x9A	; 154
    5f80:	96 e0       	ldi	r25, 0x06	; 6
    5f82:	95 8b       	std	Z+21, r25	; 0x15
    5f84:	84 8b       	std	Z+20, r24	; 0x14
    5f86:	80 91 9a 06 	lds	r24, 0x069A
    5f8a:	8f 5f       	subi	r24, 0xFF	; 255
    5f8c:	80 93 9a 06 	sts	0x069A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5f90:	e9 85       	ldd	r30, Y+9	; 0x09
    5f92:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f94:	96 89       	ldd	r25, Z+22	; 0x16
    5f96:	e0 91 4e 06 	lds	r30, 0x064E
    5f9a:	f0 91 4f 06 	lds	r31, 0x064F
    5f9e:	86 89       	ldd	r24, Z+22	; 0x16
    5fa0:	89 17       	cp	r24, r25
    5fa2:	58 f4       	brcc	.+22     	; 0x5fba <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5fa4:	8e 85       	ldd	r24, Y+14	; 0x0e
    5fa6:	9f 85       	ldd	r25, Y+15	; 0x0f
    5fa8:	00 97       	sbiw	r24, 0x00	; 0
    5faa:	21 f0       	breq	.+8      	; 0x5fb4 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5fac:	ee 85       	ldd	r30, Y+14	; 0x0e
    5fae:	ff 85       	ldd	r31, Y+15	; 0x0f
    5fb0:	81 e0       	ldi	r24, 0x01	; 1
    5fb2:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5fb4:	81 e0       	ldi	r24, 0x01	; 1
    5fb6:	80 93 58 06 	sts	0x0658, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5fba:	2f 96       	adiw	r28, 0x0f	; 15
    5fbc:	0f b6       	in	r0, 0x3f	; 63
    5fbe:	f8 94       	cli
    5fc0:	de bf       	out	0x3e, r29	; 62
    5fc2:	0f be       	out	0x3f, r0	; 63
    5fc4:	cd bf       	out	0x3d, r28	; 61
    5fc6:	cf 91       	pop	r28
    5fc8:	df 91       	pop	r29
    5fca:	1f 91       	pop	r17
    5fcc:	0f 91       	pop	r16
    5fce:	08 95       	ret

00005fd0 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5fd0:	df 93       	push	r29
    5fd2:	cf 93       	push	r28
    5fd4:	cd b7       	in	r28, 0x3d	; 61
    5fd6:	de b7       	in	r29, 0x3e	; 62
    5fd8:	28 97       	sbiw	r28, 0x08	; 8
    5fda:	0f b6       	in	r0, 0x3f	; 63
    5fdc:	f8 94       	cli
    5fde:	de bf       	out	0x3e, r29	; 62
    5fe0:	0f be       	out	0x3f, r0	; 63
    5fe2:	cd bf       	out	0x3d, r28	; 61
    5fe4:	9d 83       	std	Y+5, r25	; 0x05
    5fe6:	8c 83       	std	Y+4, r24	; 0x04
    5fe8:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5fea:	8c 81       	ldd	r24, Y+4	; 0x04
    5fec:	9d 81       	ldd	r25, Y+5	; 0x05
    5fee:	00 97       	sbiw	r24, 0x00	; 0
    5ff0:	39 f4       	brne	.+14     	; 0x6000 <xTaskGenericNotifyStateClear+0x30>
    5ff2:	80 91 4e 06 	lds	r24, 0x064E
    5ff6:	90 91 4f 06 	lds	r25, 0x064F
    5ffa:	98 87       	std	Y+8, r25	; 0x08
    5ffc:	8f 83       	std	Y+7, r24	; 0x07
    5ffe:	04 c0       	rjmp	.+8      	; 0x6008 <xTaskGenericNotifyStateClear+0x38>
    6000:	8c 81       	ldd	r24, Y+4	; 0x04
    6002:	9d 81       	ldd	r25, Y+5	; 0x05
    6004:	98 87       	std	Y+8, r25	; 0x08
    6006:	8f 83       	std	Y+7, r24	; 0x07
    6008:	8f 81       	ldd	r24, Y+7	; 0x07
    600a:	98 85       	ldd	r25, Y+8	; 0x08
    600c:	9b 83       	std	Y+3, r25	; 0x03
    600e:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    6010:	0f b6       	in	r0, 0x3f	; 63
    6012:	f8 94       	cli
    6014:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    6016:	8e 81       	ldd	r24, Y+6	; 0x06
    6018:	28 2f       	mov	r18, r24
    601a:	30 e0       	ldi	r19, 0x00	; 0
    601c:	8a 81       	ldd	r24, Y+2	; 0x02
    601e:	9b 81       	ldd	r25, Y+3	; 0x03
    6020:	82 0f       	add	r24, r18
    6022:	93 1f       	adc	r25, r19
    6024:	fc 01       	movw	r30, r24
    6026:	b5 96       	adiw	r30, 0x25	; 37
    6028:	80 81       	ld	r24, Z
    602a:	82 30       	cpi	r24, 0x02	; 2
    602c:	69 f4       	brne	.+26     	; 0x6048 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    602e:	8e 81       	ldd	r24, Y+6	; 0x06
    6030:	28 2f       	mov	r18, r24
    6032:	30 e0       	ldi	r19, 0x00	; 0
    6034:	8a 81       	ldd	r24, Y+2	; 0x02
    6036:	9b 81       	ldd	r25, Y+3	; 0x03
    6038:	82 0f       	add	r24, r18
    603a:	93 1f       	adc	r25, r19
    603c:	fc 01       	movw	r30, r24
    603e:	b5 96       	adiw	r30, 0x25	; 37
    6040:	10 82       	st	Z, r1
                xReturn = pdPASS;
    6042:	81 e0       	ldi	r24, 0x01	; 1
    6044:	89 83       	std	Y+1, r24	; 0x01
    6046:	01 c0       	rjmp	.+2      	; 0x604a <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    6048:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    604a:	0f 90       	pop	r0
    604c:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    604e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6050:	28 96       	adiw	r28, 0x08	; 8
    6052:	0f b6       	in	r0, 0x3f	; 63
    6054:	f8 94       	cli
    6056:	de bf       	out	0x3e, r29	; 62
    6058:	0f be       	out	0x3f, r0	; 63
    605a:	cd bf       	out	0x3d, r28	; 61
    605c:	cf 91       	pop	r28
    605e:	df 91       	pop	r29
    6060:	08 95       	ret

00006062 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    6062:	0f 93       	push	r16
    6064:	1f 93       	push	r17
    6066:	df 93       	push	r29
    6068:	cf 93       	push	r28
    606a:	cd b7       	in	r28, 0x3d	; 61
    606c:	de b7       	in	r29, 0x3e	; 62
    606e:	2f 97       	sbiw	r28, 0x0f	; 15
    6070:	0f b6       	in	r0, 0x3f	; 63
    6072:	f8 94       	cli
    6074:	de bf       	out	0x3e, r29	; 62
    6076:	0f be       	out	0x3f, r0	; 63
    6078:	cd bf       	out	0x3d, r28	; 61
    607a:	98 87       	std	Y+8, r25	; 0x08
    607c:	8f 83       	std	Y+7, r24	; 0x07
    607e:	69 87       	std	Y+9, r22	; 0x09
    6080:	2a 87       	std	Y+10, r18	; 0x0a
    6082:	3b 87       	std	Y+11, r19	; 0x0b
    6084:	4c 87       	std	Y+12, r20	; 0x0c
    6086:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6088:	8f 81       	ldd	r24, Y+7	; 0x07
    608a:	98 85       	ldd	r25, Y+8	; 0x08
    608c:	00 97       	sbiw	r24, 0x00	; 0
    608e:	39 f4       	brne	.+14     	; 0x609e <ulTaskGenericNotifyValueClear+0x3c>
    6090:	80 91 4e 06 	lds	r24, 0x064E
    6094:	90 91 4f 06 	lds	r25, 0x064F
    6098:	9f 87       	std	Y+15, r25	; 0x0f
    609a:	8e 87       	std	Y+14, r24	; 0x0e
    609c:	04 c0       	rjmp	.+8      	; 0x60a6 <ulTaskGenericNotifyValueClear+0x44>
    609e:	8f 81       	ldd	r24, Y+7	; 0x07
    60a0:	98 85       	ldd	r25, Y+8	; 0x08
    60a2:	9f 87       	std	Y+15, r25	; 0x0f
    60a4:	8e 87       	std	Y+14, r24	; 0x0e
    60a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    60a8:	9f 85       	ldd	r25, Y+15	; 0x0f
    60aa:	9e 83       	std	Y+6, r25	; 0x06
    60ac:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    60ae:	0f b6       	in	r0, 0x3f	; 63
    60b0:	f8 94       	cli
    60b2:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    60b4:	89 85       	ldd	r24, Y+9	; 0x09
    60b6:	88 2f       	mov	r24, r24
    60b8:	90 e0       	ldi	r25, 0x00	; 0
    60ba:	2d 81       	ldd	r18, Y+5	; 0x05
    60bc:	3e 81       	ldd	r19, Y+6	; 0x06
    60be:	88 0f       	add	r24, r24
    60c0:	99 1f       	adc	r25, r25
    60c2:	88 0f       	add	r24, r24
    60c4:	99 1f       	adc	r25, r25
    60c6:	82 0f       	add	r24, r18
    60c8:	93 1f       	adc	r25, r19
    60ca:	fc 01       	movw	r30, r24
    60cc:	b1 96       	adiw	r30, 0x21	; 33
    60ce:	80 81       	ld	r24, Z
    60d0:	91 81       	ldd	r25, Z+1	; 0x01
    60d2:	a2 81       	ldd	r26, Z+2	; 0x02
    60d4:	b3 81       	ldd	r27, Z+3	; 0x03
    60d6:	89 83       	std	Y+1, r24	; 0x01
    60d8:	9a 83       	std	Y+2, r25	; 0x02
    60da:	ab 83       	std	Y+3, r26	; 0x03
    60dc:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    60de:	89 85       	ldd	r24, Y+9	; 0x09
    60e0:	08 2f       	mov	r16, r24
    60e2:	10 e0       	ldi	r17, 0x00	; 0
    60e4:	89 85       	ldd	r24, Y+9	; 0x09
    60e6:	88 2f       	mov	r24, r24
    60e8:	90 e0       	ldi	r25, 0x00	; 0
    60ea:	2d 81       	ldd	r18, Y+5	; 0x05
    60ec:	3e 81       	ldd	r19, Y+6	; 0x06
    60ee:	88 0f       	add	r24, r24
    60f0:	99 1f       	adc	r25, r25
    60f2:	88 0f       	add	r24, r24
    60f4:	99 1f       	adc	r25, r25
    60f6:	82 0f       	add	r24, r18
    60f8:	93 1f       	adc	r25, r19
    60fa:	fc 01       	movw	r30, r24
    60fc:	b1 96       	adiw	r30, 0x21	; 33
    60fe:	20 81       	ld	r18, Z
    6100:	31 81       	ldd	r19, Z+1	; 0x01
    6102:	42 81       	ldd	r20, Z+2	; 0x02
    6104:	53 81       	ldd	r21, Z+3	; 0x03
    6106:	8a 85       	ldd	r24, Y+10	; 0x0a
    6108:	9b 85       	ldd	r25, Y+11	; 0x0b
    610a:	ac 85       	ldd	r26, Y+12	; 0x0c
    610c:	bd 85       	ldd	r27, Y+13	; 0x0d
    610e:	80 95       	com	r24
    6110:	90 95       	com	r25
    6112:	a0 95       	com	r26
    6114:	b0 95       	com	r27
    6116:	ba 01       	movw	r22, r20
    6118:	a9 01       	movw	r20, r18
    611a:	48 23       	and	r20, r24
    611c:	59 23       	and	r21, r25
    611e:	6a 23       	and	r22, r26
    6120:	7b 23       	and	r23, r27
    6122:	2d 81       	ldd	r18, Y+5	; 0x05
    6124:	3e 81       	ldd	r19, Y+6	; 0x06
    6126:	c8 01       	movw	r24, r16
    6128:	88 0f       	add	r24, r24
    612a:	99 1f       	adc	r25, r25
    612c:	88 0f       	add	r24, r24
    612e:	99 1f       	adc	r25, r25
    6130:	82 0f       	add	r24, r18
    6132:	93 1f       	adc	r25, r19
    6134:	fc 01       	movw	r30, r24
    6136:	b1 96       	adiw	r30, 0x21	; 33
    6138:	40 83       	st	Z, r20
    613a:	51 83       	std	Z+1, r21	; 0x01
    613c:	62 83       	std	Z+2, r22	; 0x02
    613e:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    6140:	0f 90       	pop	r0
    6142:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    6144:	89 81       	ldd	r24, Y+1	; 0x01
    6146:	9a 81       	ldd	r25, Y+2	; 0x02
    6148:	ab 81       	ldd	r26, Y+3	; 0x03
    614a:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    614c:	bc 01       	movw	r22, r24
    614e:	cd 01       	movw	r24, r26
    6150:	2f 96       	adiw	r28, 0x0f	; 15
    6152:	0f b6       	in	r0, 0x3f	; 63
    6154:	f8 94       	cli
    6156:	de bf       	out	0x3e, r29	; 62
    6158:	0f be       	out	0x3f, r0	; 63
    615a:	cd bf       	out	0x3d, r28	; 61
    615c:	cf 91       	pop	r28
    615e:	df 91       	pop	r29
    6160:	1f 91       	pop	r17
    6162:	0f 91       	pop	r16
    6164:	08 95       	ret

00006166 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    6166:	df 93       	push	r29
    6168:	cf 93       	push	r28
    616a:	cd b7       	in	r28, 0x3d	; 61
    616c:	de b7       	in	r29, 0x3e	; 62
    616e:	27 97       	sbiw	r28, 0x07	; 7
    6170:	0f b6       	in	r0, 0x3f	; 63
    6172:	f8 94       	cli
    6174:	de bf       	out	0x3e, r29	; 62
    6176:	0f be       	out	0x3f, r0	; 63
    6178:	cd bf       	out	0x3d, r28	; 61
    617a:	9e 83       	std	Y+6, r25	; 0x06
    617c:	8d 83       	std	Y+5, r24	; 0x05
    617e:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    6180:	80 91 52 06 	lds	r24, 0x0652
    6184:	90 91 53 06 	lds	r25, 0x0653
    6188:	9a 83       	std	Y+2, r25	; 0x02
    618a:	89 83       	std	Y+1, r24	; 0x01
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    618c:	80 91 4e 06 	lds	r24, 0x064E
    6190:	90 91 4f 06 	lds	r25, 0x064F
    6194:	02 96       	adiw	r24, 0x02	; 2
    6196:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    619a:	29 81       	ldd	r18, Y+1	; 0x01
    619c:	3a 81       	ldd	r19, Y+2	; 0x02
    619e:	8d 81       	ldd	r24, Y+5	; 0x05
    61a0:	9e 81       	ldd	r25, Y+6	; 0x06
    61a2:	82 0f       	add	r24, r18
    61a4:	93 1f       	adc	r25, r19
    61a6:	9c 83       	std	Y+4, r25	; 0x04
    61a8:	8b 83       	std	Y+3, r24	; 0x03

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    61aa:	e0 91 4e 06 	lds	r30, 0x064E
    61ae:	f0 91 4f 06 	lds	r31, 0x064F
    61b2:	8b 81       	ldd	r24, Y+3	; 0x03
    61b4:	9c 81       	ldd	r25, Y+4	; 0x04
    61b6:	93 83       	std	Z+3, r25	; 0x03
    61b8:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xConstTickCount )
    61ba:	2b 81       	ldd	r18, Y+3	; 0x03
    61bc:	3c 81       	ldd	r19, Y+4	; 0x04
    61be:	89 81       	ldd	r24, Y+1	; 0x01
    61c0:	9a 81       	ldd	r25, Y+2	; 0x02
    61c2:	28 17       	cp	r18, r24
    61c4:	39 07       	cpc	r19, r25
    61c6:	70 f4       	brcc	.+28     	; 0x61e4 <prvAddCurrentTaskToDelayedList+0x7e>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    61c8:	80 91 98 06 	lds	r24, 0x0698
    61cc:	90 91 99 06 	lds	r25, 0x0699
    61d0:	20 91 4e 06 	lds	r18, 0x064E
    61d4:	30 91 4f 06 	lds	r19, 0x064F
    61d8:	2e 5f       	subi	r18, 0xFE	; 254
    61da:	3f 4f       	sbci	r19, 0xFF	; 255
    61dc:	b9 01       	movw	r22, r18
    61de:	0e 94 66 0d 	call	0x1acc	; 0x1acc <vListInsert>
    61e2:	1e c0       	rjmp	.+60     	; 0x6220 <prvAddCurrentTaskToDelayedList+0xba>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    61e4:	40 91 96 06 	lds	r20, 0x0696
    61e8:	50 91 97 06 	lds	r21, 0x0697
    61ec:	80 91 4e 06 	lds	r24, 0x064E
    61f0:	90 91 4f 06 	lds	r25, 0x064F
    61f4:	9c 01       	movw	r18, r24
    61f6:	2e 5f       	subi	r18, 0xFE	; 254
    61f8:	3f 4f       	sbci	r19, 0xFF	; 255
    61fa:	ca 01       	movw	r24, r20
    61fc:	b9 01       	movw	r22, r18
    61fe:	0e 94 66 0d 	call	0x1acc	; 0x1acc <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    6202:	20 91 5b 06 	lds	r18, 0x065B
    6206:	30 91 5c 06 	lds	r19, 0x065C
    620a:	8b 81       	ldd	r24, Y+3	; 0x03
    620c:	9c 81       	ldd	r25, Y+4	; 0x04
    620e:	82 17       	cp	r24, r18
    6210:	93 07       	cpc	r25, r19
    6212:	30 f4       	brcc	.+12     	; 0x6220 <prvAddCurrentTaskToDelayedList+0xba>
            {
                xNextTaskUnblockTime = xTimeToWake;
    6214:	8b 81       	ldd	r24, Y+3	; 0x03
    6216:	9c 81       	ldd	r25, Y+4	; 0x04
    6218:	90 93 5c 06 	sts	0x065C, r25
    621c:	80 93 5b 06 	sts	0x065B, r24

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    6220:	27 96       	adiw	r28, 0x07	; 7
    6222:	0f b6       	in	r0, 0x3f	; 63
    6224:	f8 94       	cli
    6226:	de bf       	out	0x3e, r29	; 62
    6228:	0f be       	out	0x3f, r0	; 63
    622a:	cd bf       	out	0x3d, r28	; 61
    622c:	cf 91       	pop	r28
    622e:	df 91       	pop	r29
    6230:	08 95       	ret

00006232 <PWM_u8Init>:




uint8 PWM_u8Init(uint8 Copy_u8Channel , uint16 Copy_u8Frequency , uint16 Copy_u16OCRValue)
{
    6232:	df 93       	push	r29
    6234:	cf 93       	push	r28
    6236:	cd b7       	in	r28, 0x3d	; 61
    6238:	de b7       	in	r29, 0x3e	; 62
    623a:	2a 97       	sbiw	r28, 0x0a	; 10
    623c:	0f b6       	in	r0, 0x3f	; 63
    623e:	f8 94       	cli
    6240:	de bf       	out	0x3e, r29	; 62
    6242:	0f be       	out	0x3f, r0	; 63
    6244:	cd bf       	out	0x3d, r28	; 61
    6246:	8a 83       	std	Y+2, r24	; 0x02
    6248:	7c 83       	std	Y+4, r23	; 0x04
    624a:	6b 83       	std	Y+3, r22	; 0x03
    624c:	5e 83       	std	Y+6, r21	; 0x06
    624e:	4d 83       	std	Y+5, r20	; 0x05
	/*local variable for error checking*/
	uint8 Local_u8ErrorState = OK ;
    6250:	19 82       	std	Y+1, r1	; 0x01

	/* 1- setting mode of TIMER/COUNTER1 to be fast PWM (mode no.14)*/
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
    6252:	af e4       	ldi	r26, 0x4F	; 79
    6254:	b0 e0       	ldi	r27, 0x00	; 0
    6256:	ef e4       	ldi	r30, 0x4F	; 79
    6258:	f0 e0       	ldi	r31, 0x00	; 0
    625a:	80 81       	ld	r24, Z
    625c:	8e 7f       	andi	r24, 0xFE	; 254
    625e:	8c 93       	st	X, r24
	SET_BIT(TCCR1A,TCCR1A_WGM11);
    6260:	af e4       	ldi	r26, 0x4F	; 79
    6262:	b0 e0       	ldi	r27, 0x00	; 0
    6264:	ef e4       	ldi	r30, 0x4F	; 79
    6266:	f0 e0       	ldi	r31, 0x00	; 0
    6268:	80 81       	ld	r24, Z
    626a:	82 60       	ori	r24, 0x02	; 2
    626c:	8c 93       	st	X, r24
	SET_BIT(TCCR1B,TCCR1B_WGM12);
    626e:	ae e4       	ldi	r26, 0x4E	; 78
    6270:	b0 e0       	ldi	r27, 0x00	; 0
    6272:	ee e4       	ldi	r30, 0x4E	; 78
    6274:	f0 e0       	ldi	r31, 0x00	; 0
    6276:	80 81       	ld	r24, Z
    6278:	88 60       	ori	r24, 0x08	; 8
    627a:	8c 93       	st	X, r24
	SET_BIT(TCCR1B,TCCR1B_WGM13);
    627c:	ae e4       	ldi	r26, 0x4E	; 78
    627e:	b0 e0       	ldi	r27, 0x00	; 0
    6280:	ee e4       	ldi	r30, 0x4E	; 78
    6282:	f0 e0       	ldi	r31, 0x00	; 0
    6284:	80 81       	ld	r24, Z
    6286:	80 61       	ori	r24, 0x10	; 16
    6288:	8c 93       	st	X, r24

	/* 2-setting non inverted mode on OC1A | OC1B pins */
	/*switching over channels*/
	switch(Copy_u8Channel)
    628a:	8a 81       	ldd	r24, Y+2	; 0x02
    628c:	28 2f       	mov	r18, r24
    628e:	30 e0       	ldi	r19, 0x00	; 0
    6290:	3a 87       	std	Y+10, r19	; 0x0a
    6292:	29 87       	std	Y+9, r18	; 0x09
    6294:	89 85       	ldd	r24, Y+9	; 0x09
    6296:	9a 85       	ldd	r25, Y+10	; 0x0a
    6298:	81 30       	cpi	r24, 0x01	; 1
    629a:	91 05       	cpc	r25, r1
    629c:	31 f0       	breq	.+12     	; 0x62aa <PWM_u8Init+0x78>
    629e:	29 85       	ldd	r18, Y+9	; 0x09
    62a0:	3a 85       	ldd	r19, Y+10	; 0x0a
    62a2:	22 30       	cpi	r18, 0x02	; 2
    62a4:	31 05       	cpc	r19, r1
    62a6:	81 f0       	breq	.+32     	; 0x62c8 <PWM_u8Init+0x96>
    62a8:	1e c0       	rjmp	.+60     	; 0x62e6 <PWM_u8Init+0xb4>
		{
			/*choosing Channel A*/
			case CHANNEL_A :
				CLR_BIT(TCCR1A ,TCCR1A_COM1A0);
    62aa:	af e4       	ldi	r26, 0x4F	; 79
    62ac:	b0 e0       	ldi	r27, 0x00	; 0
    62ae:	ef e4       	ldi	r30, 0x4F	; 79
    62b0:	f0 e0       	ldi	r31, 0x00	; 0
    62b2:	80 81       	ld	r24, Z
    62b4:	8f 7b       	andi	r24, 0xBF	; 191
    62b6:	8c 93       	st	X, r24
				SET_BIT(TCCR1A ,TCCR1A_COM1A1);
    62b8:	af e4       	ldi	r26, 0x4F	; 79
    62ba:	b0 e0       	ldi	r27, 0x00	; 0
    62bc:	ef e4       	ldi	r30, 0x4F	; 79
    62be:	f0 e0       	ldi	r31, 0x00	; 0
    62c0:	80 81       	ld	r24, Z
    62c2:	80 68       	ori	r24, 0x80	; 128
    62c4:	8c 93       	st	X, r24
    62c6:	11 c0       	rjmp	.+34     	; 0x62ea <PWM_u8Init+0xb8>
				break ;

			/*choosing Channel B*/
			case CHANNEL_B :
				CLR_BIT(TCCR1A ,TCCR1A_COM1B0);
    62c8:	af e4       	ldi	r26, 0x4F	; 79
    62ca:	b0 e0       	ldi	r27, 0x00	; 0
    62cc:	ef e4       	ldi	r30, 0x4F	; 79
    62ce:	f0 e0       	ldi	r31, 0x00	; 0
    62d0:	80 81       	ld	r24, Z
    62d2:	8f 7e       	andi	r24, 0xEF	; 239
    62d4:	8c 93       	st	X, r24
				SET_BIT(TCCR1A ,TCCR1A_COM1B1);
    62d6:	af e4       	ldi	r26, 0x4F	; 79
    62d8:	b0 e0       	ldi	r27, 0x00	; 0
    62da:	ef e4       	ldi	r30, 0x4F	; 79
    62dc:	f0 e0       	ldi	r31, 0x00	; 0
    62de:	80 81       	ld	r24, Z
    62e0:	80 62       	ori	r24, 0x20	; 32
    62e2:	8c 93       	st	X, r24
    62e4:	02 c0       	rjmp	.+4      	; 0x62ea <PWM_u8Init+0xb8>
				break ;

			default :
				Local_u8ErrorState = WRONG_CHANNEL ;
    62e6:	84 e0       	ldi	r24, 0x04	; 4
    62e8:	89 83       	std	Y+1, r24	; 0x01
		}


	/* 3- Setting value of ICR register to set frequency*/
	/*checking for right configuration of frequency*/
	if(Copy_u8Frequency >= FREQUENCY_1000 || Copy_u8Frequency <= FREQUENCY_20)
    62ea:	8b 81       	ldd	r24, Y+3	; 0x03
    62ec:	9c 81       	ldd	r25, Y+4	; 0x04
    62ee:	33 e0       	ldi	r19, 0x03	; 3
    62f0:	88 3e       	cpi	r24, 0xE8	; 232
    62f2:	93 07       	cpc	r25, r19
    62f4:	30 f4       	brcc	.+12     	; 0x6302 <PWM_u8Init+0xd0>
    62f6:	8b 81       	ldd	r24, Y+3	; 0x03
    62f8:	9c 81       	ldd	r25, Y+4	; 0x04
    62fa:	23 ec       	ldi	r18, 0xC3	; 195
    62fc:	81 35       	cpi	r24, 0x51	; 81
    62fe:	92 07       	cpc	r25, r18
    6300:	38 f4       	brcc	.+14     	; 0x6310 <PWM_u8Init+0xde>
	{
		ICR1 = Copy_u8Frequency ;
    6302:	e6 e4       	ldi	r30, 0x46	; 70
    6304:	f0 e0       	ldi	r31, 0x00	; 0
    6306:	8b 81       	ldd	r24, Y+3	; 0x03
    6308:	9c 81       	ldd	r25, Y+4	; 0x04
    630a:	91 83       	std	Z+1, r25	; 0x01
    630c:	80 83       	st	Z, r24
    630e:	02 c0       	rjmp	.+4      	; 0x6314 <PWM_u8Init+0xe2>
	}
	else
	{
		Local_u8ErrorState = WRONG_FREQ ;
    6310:	85 e0       	ldi	r24, 0x05	; 5
    6312:	89 83       	std	Y+1, r24	; 0x01
	/* 4-setting value of OCR to set duty cycle*/
	/*checking for valid value of duty cycle*/
	if(Copy_u16OCRValue >= 0 && Copy_u16OCRValue <=65536)
	{
		/*switching over channels*/
		switch(Copy_u8Channel)
    6314:	8a 81       	ldd	r24, Y+2	; 0x02
    6316:	28 2f       	mov	r18, r24
    6318:	30 e0       	ldi	r19, 0x00	; 0
    631a:	38 87       	std	Y+8, r19	; 0x08
    631c:	2f 83       	std	Y+7, r18	; 0x07
    631e:	8f 81       	ldd	r24, Y+7	; 0x07
    6320:	98 85       	ldd	r25, Y+8	; 0x08
    6322:	81 30       	cpi	r24, 0x01	; 1
    6324:	91 05       	cpc	r25, r1
    6326:	31 f0       	breq	.+12     	; 0x6334 <PWM_u8Init+0x102>
    6328:	2f 81       	ldd	r18, Y+7	; 0x07
    632a:	38 85       	ldd	r19, Y+8	; 0x08
    632c:	22 30       	cpi	r18, 0x02	; 2
    632e:	31 05       	cpc	r19, r1
    6330:	41 f0       	breq	.+16     	; 0x6342 <PWM_u8Init+0x110>
    6332:	0e c0       	rjmp	.+28     	; 0x6350 <PWM_u8Init+0x11e>
			{
				/*choosing Channel A*/
				case CHANNEL_A :
					OCR1A = Copy_u16OCRValue ;
    6334:	ea e4       	ldi	r30, 0x4A	; 74
    6336:	f0 e0       	ldi	r31, 0x00	; 0
    6338:	8d 81       	ldd	r24, Y+5	; 0x05
    633a:	9e 81       	ldd	r25, Y+6	; 0x06
    633c:	91 83       	std	Z+1, r25	; 0x01
    633e:	80 83       	st	Z, r24
    6340:	09 c0       	rjmp	.+18     	; 0x6354 <PWM_u8Init+0x122>
					break ;

				/*choosing Channel B*/
				case CHANNEL_B :
					OCR1B = Copy_u16OCRValue ;
    6342:	e8 e4       	ldi	r30, 0x48	; 72
    6344:	f0 e0       	ldi	r31, 0x00	; 0
    6346:	8d 81       	ldd	r24, Y+5	; 0x05
    6348:	9e 81       	ldd	r25, Y+6	; 0x06
    634a:	91 83       	std	Z+1, r25	; 0x01
    634c:	80 83       	st	Z, r24
    634e:	02 c0       	rjmp	.+4      	; 0x6354 <PWM_u8Init+0x122>
					break ;

				default :
					Local_u8ErrorState = WRONG_CHANNEL ;
    6350:	84 e0       	ldi	r24, 0x04	; 4
    6352:	89 83       	std	Y+1, r24	; 0x01
	{
		Local_u8ErrorState = NOK ;
	}

	/* 5-disable all interrupts*/
	TIMSK = 0 ;
    6354:	e9 e5       	ldi	r30, 0x59	; 89
    6356:	f0 e0       	ldi	r31, 0x00	; 0
    6358:	10 82       	st	Z, r1

	/* 6- setting prescaler to run TIMER/COUNTER1*/
	/*setting prescaler=8 to get tick time = 1us*/
	TCCR1B &= CLK_MASK ;
    635a:	ae e4       	ldi	r26, 0x4E	; 78
    635c:	b0 e0       	ldi	r27, 0x00	; 0
    635e:	ee e4       	ldi	r30, 0x4E	; 78
    6360:	f0 e0       	ldi	r31, 0x00	; 0
    6362:	80 81       	ld	r24, Z
    6364:	88 7f       	andi	r24, 0xF8	; 248
    6366:	8c 93       	st	X, r24
	TCCR1B |= PRESCALER_8 ;
    6368:	ae e4       	ldi	r26, 0x4E	; 78
    636a:	b0 e0       	ldi	r27, 0x00	; 0
    636c:	ee e4       	ldi	r30, 0x4E	; 78
    636e:	f0 e0       	ldi	r31, 0x00	; 0
    6370:	80 81       	ld	r24, Z
    6372:	82 60       	ori	r24, 0x02	; 2
    6374:	8c 93       	st	X, r24

	/*return from this function*/
	return Local_u8ErrorState ;
    6376:	89 81       	ldd	r24, Y+1	; 0x01
}
    6378:	2a 96       	adiw	r28, 0x0a	; 10
    637a:	0f b6       	in	r0, 0x3f	; 63
    637c:	f8 94       	cli
    637e:	de bf       	out	0x3e, r29	; 62
    6380:	0f be       	out	0x3f, r0	; 63
    6382:	cd bf       	out	0x3d, r28	; 61
    6384:	cf 91       	pop	r28
    6386:	df 91       	pop	r29
    6388:	08 95       	ret

0000638a <__vector_6>:
/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_CAPT_vect)
{
    638a:	1f 92       	push	r1
    638c:	0f 92       	push	r0
    638e:	0f b6       	in	r0, 0x3f	; 63
    6390:	0f 92       	push	r0
    6392:	11 24       	eor	r1, r1
    6394:	2f 93       	push	r18
    6396:	3f 93       	push	r19
    6398:	4f 93       	push	r20
    639a:	5f 93       	push	r21
    639c:	6f 93       	push	r22
    639e:	7f 93       	push	r23
    63a0:	8f 93       	push	r24
    63a2:	9f 93       	push	r25
    63a4:	af 93       	push	r26
    63a6:	bf 93       	push	r27
    63a8:	ef 93       	push	r30
    63aa:	ff 93       	push	r31
    63ac:	df 93       	push	r29
    63ae:	cf 93       	push	r28
    63b0:	cd b7       	in	r28, 0x3d	; 61
    63b2:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
    63b4:	80 91 ac 06 	lds	r24, 0x06AC
    63b8:	90 91 ad 06 	lds	r25, 0x06AD
    63bc:	00 97       	sbiw	r24, 0x00	; 0
    63be:	29 f0       	breq	.+10     	; 0x63ca <__vector_6+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    63c0:	e0 91 ac 06 	lds	r30, 0x06AC
    63c4:	f0 91 ad 06 	lds	r31, 0x06AD
    63c8:	09 95       	icall
	}
}
    63ca:	cf 91       	pop	r28
    63cc:	df 91       	pop	r29
    63ce:	ff 91       	pop	r31
    63d0:	ef 91       	pop	r30
    63d2:	bf 91       	pop	r27
    63d4:	af 91       	pop	r26
    63d6:	9f 91       	pop	r25
    63d8:	8f 91       	pop	r24
    63da:	7f 91       	pop	r23
    63dc:	6f 91       	pop	r22
    63de:	5f 91       	pop	r21
    63e0:	4f 91       	pop	r20
    63e2:	3f 91       	pop	r19
    63e4:	2f 91       	pop	r18
    63e6:	0f 90       	pop	r0
    63e8:	0f be       	out	0x3f, r0	; 63
    63ea:	0f 90       	pop	r0
    63ec:	1f 90       	pop	r1
    63ee:	18 95       	reti

000063f0 <Icu_init>:
 * 	2. Set the required edge detection.
 * 	3. Enable the Input Capture Interrupt.
 * 	4. Initialize Timer1 Registers
 */
void Icu_init(const Icu_ConfigType * Config_Ptr)
{
    63f0:	df 93       	push	r29
    63f2:	cf 93       	push	r28
    63f4:	00 d0       	rcall	.+0      	; 0x63f6 <Icu_init+0x6>
    63f6:	cd b7       	in	r28, 0x3d	; 61
    63f8:	de b7       	in	r29, 0x3e	; 62
    63fa:	9a 83       	std	Y+2, r25	; 0x02
    63fc:	89 83       	std	Y+1, r24	; 0x01
	/* Configure ICP1/PD6 as i/p pin */
	DDRD &= ~(1<<PD6);
    63fe:	a1 e3       	ldi	r26, 0x31	; 49
    6400:	b0 e0       	ldi	r27, 0x00	; 0
    6402:	e1 e3       	ldi	r30, 0x31	; 49
    6404:	f0 e0       	ldi	r31, 0x00	; 0
    6406:	80 81       	ld	r24, Z
    6408:	8f 7b       	andi	r24, 0xBF	; 191
    640a:	8c 93       	st	X, r24

	/* Timer1 always operates in Normal Mode */
	TCCR1A = (1<<FOC1A) | (1<<FOC1B);
    640c:	ef e4       	ldi	r30, 0x4F	; 79
    640e:	f0 e0       	ldi	r31, 0x00	; 0
    6410:	8c e0       	ldi	r24, 0x0C	; 12
    6412:	80 83       	st	Z, r24

	/*
	 * insert the required clock value in the first three bits (CS10, CS11 and CS12)
	 * of TCCR1B Register
	 */
	TCCR1B = (TCCR1B & 0xF8) | (Config_Ptr->clock);
    6414:	ae e4       	ldi	r26, 0x4E	; 78
    6416:	b0 e0       	ldi	r27, 0x00	; 0
    6418:	ee e4       	ldi	r30, 0x4E	; 78
    641a:	f0 e0       	ldi	r31, 0x00	; 0
    641c:	80 81       	ld	r24, Z
    641e:	98 2f       	mov	r25, r24
    6420:	98 7f       	andi	r25, 0xF8	; 248
    6422:	e9 81       	ldd	r30, Y+1	; 0x01
    6424:	fa 81       	ldd	r31, Y+2	; 0x02
    6426:	80 81       	ld	r24, Z
    6428:	89 2b       	or	r24, r25
    642a:	8c 93       	st	X, r24
	/*
     * insert the required edge type in ICES1 bit in TCCR1B Register
	 */
	TCCR1B = (TCCR1B & 0xBF) | ((Config_Ptr->edge)<<6);
    642c:	ae e4       	ldi	r26, 0x4E	; 78
    642e:	b0 e0       	ldi	r27, 0x00	; 0
    6430:	ee e4       	ldi	r30, 0x4E	; 78
    6432:	f0 e0       	ldi	r31, 0x00	; 0
    6434:	80 81       	ld	r24, Z
    6436:	28 2f       	mov	r18, r24
    6438:	2f 7b       	andi	r18, 0xBF	; 191
    643a:	e9 81       	ldd	r30, Y+1	; 0x01
    643c:	fa 81       	ldd	r31, Y+2	; 0x02
    643e:	81 81       	ldd	r24, Z+1	; 0x01
    6440:	88 2f       	mov	r24, r24
    6442:	90 e0       	ldi	r25, 0x00	; 0
    6444:	00 24       	eor	r0, r0
    6446:	96 95       	lsr	r25
    6448:	87 95       	ror	r24
    644a:	07 94       	ror	r0
    644c:	96 95       	lsr	r25
    644e:	87 95       	ror	r24
    6450:	07 94       	ror	r0
    6452:	98 2f       	mov	r25, r24
    6454:	80 2d       	mov	r24, r0
    6456:	82 2b       	or	r24, r18
    6458:	8c 93       	st	X, r24

	/* Initial Value for Timer1 */
	TCNT1 = 0;
    645a:	ec e4       	ldi	r30, 0x4C	; 76
    645c:	f0 e0       	ldi	r31, 0x00	; 0
    645e:	11 82       	std	Z+1, r1	; 0x01
    6460:	10 82       	st	Z, r1

	/* Initial Value for the input capture register */
	ICR1 = 0;
    6462:	e6 e4       	ldi	r30, 0x46	; 70
    6464:	f0 e0       	ldi	r31, 0x00	; 0
    6466:	11 82       	std	Z+1, r1	; 0x01
    6468:	10 82       	st	Z, r1

	/* Enable the Input Capture interrupt to generate an interrupt when edge is detected on ICP1/PD6 pin */
	TIMSK |= (1<<TICIE1);
    646a:	a9 e5       	ldi	r26, 0x59	; 89
    646c:	b0 e0       	ldi	r27, 0x00	; 0
    646e:	e9 e5       	ldi	r30, 0x59	; 89
    6470:	f0 e0       	ldi	r31, 0x00	; 0
    6472:	80 81       	ld	r24, Z
    6474:	80 62       	ori	r24, 0x20	; 32
    6476:	8c 93       	st	X, r24
}
    6478:	0f 90       	pop	r0
    647a:	0f 90       	pop	r0
    647c:	cf 91       	pop	r28
    647e:	df 91       	pop	r29
    6480:	08 95       	ret

00006482 <Icu_setCallBack>:

/*
 * Description: Function to set the Call Back function address.
 */
void Icu_setCallBack(void(*a_ptr)(void))
{
    6482:	df 93       	push	r29
    6484:	cf 93       	push	r28
    6486:	00 d0       	rcall	.+0      	; 0x6488 <Icu_setCallBack+0x6>
    6488:	cd b7       	in	r28, 0x3d	; 61
    648a:	de b7       	in	r29, 0x3e	; 62
    648c:	9a 83       	std	Y+2, r25	; 0x02
    648e:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
	g_callBackPtr = a_ptr;
    6490:	89 81       	ldd	r24, Y+1	; 0x01
    6492:	9a 81       	ldd	r25, Y+2	; 0x02
    6494:	90 93 ad 06 	sts	0x06AD, r25
    6498:	80 93 ac 06 	sts	0x06AC, r24
}
    649c:	0f 90       	pop	r0
    649e:	0f 90       	pop	r0
    64a0:	cf 91       	pop	r28
    64a2:	df 91       	pop	r29
    64a4:	08 95       	ret

000064a6 <Icu_setEdgeDetectionType>:

/*
 * Description: Function to set the required edge detection.
 */
void Icu_setEdgeDetectionType(const Icu_EdgeType a_edgeType)
{
    64a6:	df 93       	push	r29
    64a8:	cf 93       	push	r28
    64aa:	0f 92       	push	r0
    64ac:	cd b7       	in	r28, 0x3d	; 61
    64ae:	de b7       	in	r29, 0x3e	; 62
    64b0:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * insert the required edge type in ICES1 bit in TCCR1B Register
	 */
	TCCR1B = (TCCR1B & 0xBF) | (a_edgeType<<6);
    64b2:	ae e4       	ldi	r26, 0x4E	; 78
    64b4:	b0 e0       	ldi	r27, 0x00	; 0
    64b6:	ee e4       	ldi	r30, 0x4E	; 78
    64b8:	f0 e0       	ldi	r31, 0x00	; 0
    64ba:	80 81       	ld	r24, Z
    64bc:	28 2f       	mov	r18, r24
    64be:	2f 7b       	andi	r18, 0xBF	; 191
    64c0:	89 81       	ldd	r24, Y+1	; 0x01
    64c2:	88 2f       	mov	r24, r24
    64c4:	90 e0       	ldi	r25, 0x00	; 0
    64c6:	00 24       	eor	r0, r0
    64c8:	96 95       	lsr	r25
    64ca:	87 95       	ror	r24
    64cc:	07 94       	ror	r0
    64ce:	96 95       	lsr	r25
    64d0:	87 95       	ror	r24
    64d2:	07 94       	ror	r0
    64d4:	98 2f       	mov	r25, r24
    64d6:	80 2d       	mov	r24, r0
    64d8:	82 2b       	or	r24, r18
    64da:	8c 93       	st	X, r24
}
    64dc:	0f 90       	pop	r0
    64de:	cf 91       	pop	r28
    64e0:	df 91       	pop	r29
    64e2:	08 95       	ret

000064e4 <Icu_getInputCaptureValue>:
/*
 * Description: Function to get the Timer1 Value when the input is captured
 *              The value stored at Input Capture Register ICR1
 */
uint16 Icu_getInputCaptureValue(void)
{
    64e4:	df 93       	push	r29
    64e6:	cf 93       	push	r28
    64e8:	cd b7       	in	r28, 0x3d	; 61
    64ea:	de b7       	in	r29, 0x3e	; 62
	return ICR1;
    64ec:	e6 e4       	ldi	r30, 0x46	; 70
    64ee:	f0 e0       	ldi	r31, 0x00	; 0
    64f0:	80 81       	ld	r24, Z
    64f2:	91 81       	ldd	r25, Z+1	; 0x01
}
    64f4:	cf 91       	pop	r28
    64f6:	df 91       	pop	r29
    64f8:	08 95       	ret

000064fa <Icu_clearTimerValue>:

/*
 * Description: Function to clear the Timer1 Value to start count from ZERO
 */
void Icu_clearTimerValue(void)
{
    64fa:	df 93       	push	r29
    64fc:	cf 93       	push	r28
    64fe:	cd b7       	in	r28, 0x3d	; 61
    6500:	de b7       	in	r29, 0x3e	; 62
	TCNT1 = 0;
    6502:	ec e4       	ldi	r30, 0x4C	; 76
    6504:	f0 e0       	ldi	r31, 0x00	; 0
    6506:	11 82       	std	Z+1, r1	; 0x01
    6508:	10 82       	st	Z, r1
}
    650a:	cf 91       	pop	r28
    650c:	df 91       	pop	r29
    650e:	08 95       	ret

00006510 <Icu_DeInit>:

/*
 * Description: Function to disable the Timer1 to stop the ICU Driver
 */
void Icu_DeInit(void)
{
    6510:	df 93       	push	r29
    6512:	cf 93       	push	r28
    6514:	cd b7       	in	r28, 0x3d	; 61
    6516:	de b7       	in	r29, 0x3e	; 62
	/* Clear All Timer1 Registers */
	TCCR1A = 0;
    6518:	ef e4       	ldi	r30, 0x4F	; 79
    651a:	f0 e0       	ldi	r31, 0x00	; 0
    651c:	10 82       	st	Z, r1
	TCCR1B = 0;
    651e:	ee e4       	ldi	r30, 0x4E	; 78
    6520:	f0 e0       	ldi	r31, 0x00	; 0
    6522:	10 82       	st	Z, r1
	TCNT1 = 0;
    6524:	ec e4       	ldi	r30, 0x4C	; 76
    6526:	f0 e0       	ldi	r31, 0x00	; 0
    6528:	11 82       	std	Z+1, r1	; 0x01
    652a:	10 82       	st	Z, r1
	ICR1 = 0;
    652c:	e6 e4       	ldi	r30, 0x46	; 70
    652e:	f0 e0       	ldi	r31, 0x00	; 0
    6530:	11 82       	std	Z+1, r1	; 0x01
    6532:	10 82       	st	Z, r1

	/* Disable the Input Capture interrupt */
	TIMSK &= ~(1<<TICIE1);
    6534:	a9 e5       	ldi	r26, 0x59	; 89
    6536:	b0 e0       	ldi	r27, 0x00	; 0
    6538:	e9 e5       	ldi	r30, 0x59	; 89
    653a:	f0 e0       	ldi	r31, 0x00	; 0
    653c:	80 81       	ld	r24, Z
    653e:	8f 7d       	andi	r24, 0xDF	; 223
    6540:	8c 93       	st	X, r24
}
    6542:	cf 91       	pop	r28
    6544:	df 91       	pop	r29
    6546:	08 95       	ret

00006548 <DIO_SET_PORT_DIREC>:



void DIO_SET_PORT_DIREC (DIO_PORT_ID PORT,  DIO_DIRECTION DIRECTION)

{
    6548:	df 93       	push	r29
    654a:	cf 93       	push	r28
    654c:	00 d0       	rcall	.+0      	; 0x654e <DIO_SET_PORT_DIREC+0x6>
    654e:	00 d0       	rcall	.+0      	; 0x6550 <DIO_SET_PORT_DIREC+0x8>
    6550:	cd b7       	in	r28, 0x3d	; 61
    6552:	de b7       	in	r29, 0x3e	; 62
    6554:	89 83       	std	Y+1, r24	; 0x01
    6556:	6a 83       	std	Y+2, r22	; 0x02
	switch(PORT)
    6558:	89 81       	ldd	r24, Y+1	; 0x01
    655a:	28 2f       	mov	r18, r24
    655c:	30 e0       	ldi	r19, 0x00	; 0
    655e:	3c 83       	std	Y+4, r19	; 0x04
    6560:	2b 83       	std	Y+3, r18	; 0x03
    6562:	8b 81       	ldd	r24, Y+3	; 0x03
    6564:	9c 81       	ldd	r25, Y+4	; 0x04
    6566:	81 30       	cpi	r24, 0x01	; 1
    6568:	91 05       	cpc	r25, r1
    656a:	d1 f0       	breq	.+52     	; 0x65a0 <DIO_SET_PORT_DIREC+0x58>
    656c:	2b 81       	ldd	r18, Y+3	; 0x03
    656e:	3c 81       	ldd	r19, Y+4	; 0x04
    6570:	22 30       	cpi	r18, 0x02	; 2
    6572:	31 05       	cpc	r19, r1
    6574:	2c f4       	brge	.+10     	; 0x6580 <DIO_SET_PORT_DIREC+0x38>
    6576:	8b 81       	ldd	r24, Y+3	; 0x03
    6578:	9c 81       	ldd	r25, Y+4	; 0x04
    657a:	00 97       	sbiw	r24, 0x00	; 0
    657c:	61 f0       	breq	.+24     	; 0x6596 <DIO_SET_PORT_DIREC+0x4e>
    657e:	1e c0       	rjmp	.+60     	; 0x65bc <DIO_SET_PORT_DIREC+0x74>
    6580:	2b 81       	ldd	r18, Y+3	; 0x03
    6582:	3c 81       	ldd	r19, Y+4	; 0x04
    6584:	22 30       	cpi	r18, 0x02	; 2
    6586:	31 05       	cpc	r19, r1
    6588:	81 f0       	breq	.+32     	; 0x65aa <DIO_SET_PORT_DIREC+0x62>
    658a:	8b 81       	ldd	r24, Y+3	; 0x03
    658c:	9c 81       	ldd	r25, Y+4	; 0x04
    658e:	83 30       	cpi	r24, 0x03	; 3
    6590:	91 05       	cpc	r25, r1
    6592:	81 f0       	breq	.+32     	; 0x65b4 <DIO_SET_PORT_DIREC+0x6c>
    6594:	13 c0       	rjmp	.+38     	; 0x65bc <DIO_SET_PORT_DIREC+0x74>
	{
		case DIO_PORTA:
		
		DDRA = DIRECTION;
    6596:	ea e3       	ldi	r30, 0x3A	; 58
    6598:	f0 e0       	ldi	r31, 0x00	; 0
    659a:	8a 81       	ldd	r24, Y+2	; 0x02
    659c:	80 83       	st	Z, r24
    659e:	0e c0       	rjmp	.+28     	; 0x65bc <DIO_SET_PORT_DIREC+0x74>
		
		break;
		
		case DIO_PORTB:
		
		DDRB = DIRECTION;
    65a0:	e7 e3       	ldi	r30, 0x37	; 55
    65a2:	f0 e0       	ldi	r31, 0x00	; 0
    65a4:	8a 81       	ldd	r24, Y+2	; 0x02
    65a6:	80 83       	st	Z, r24
    65a8:	09 c0       	rjmp	.+18     	; 0x65bc <DIO_SET_PORT_DIREC+0x74>
		
		break;
		
		case DIO_PORTC:
		
		DDRC = DIRECTION;
    65aa:	e4 e3       	ldi	r30, 0x34	; 52
    65ac:	f0 e0       	ldi	r31, 0x00	; 0
    65ae:	8a 81       	ldd	r24, Y+2	; 0x02
    65b0:	80 83       	st	Z, r24
    65b2:	04 c0       	rjmp	.+8      	; 0x65bc <DIO_SET_PORT_DIREC+0x74>
		
		break;
		
		case DIO_PORTD:
		
		DDRD = DIRECTION;
    65b4:	e1 e3       	ldi	r30, 0x31	; 49
    65b6:	f0 e0       	ldi	r31, 0x00	; 0
    65b8:	8a 81       	ldd	r24, Y+2	; 0x02
    65ba:	80 83       	st	Z, r24
		
		default:
		break;
		
	}
}
    65bc:	0f 90       	pop	r0
    65be:	0f 90       	pop	r0
    65c0:	0f 90       	pop	r0
    65c2:	0f 90       	pop	r0
    65c4:	cf 91       	pop	r28
    65c6:	df 91       	pop	r29
    65c8:	08 95       	ret

000065ca <DIO_SET_PIN_DIREC>:



void DIO_SET_PIN_DIREC (DIO_PORT_ID PORT , DIO_PIN_ID PIN  , DIO_DIRECTION DIRECTION)
{
    65ca:	df 93       	push	r29
    65cc:	cf 93       	push	r28
    65ce:	00 d0       	rcall	.+0      	; 0x65d0 <DIO_SET_PIN_DIREC+0x6>
    65d0:	00 d0       	rcall	.+0      	; 0x65d2 <DIO_SET_PIN_DIREC+0x8>
    65d2:	0f 92       	push	r0
    65d4:	cd b7       	in	r28, 0x3d	; 61
    65d6:	de b7       	in	r29, 0x3e	; 62
    65d8:	89 83       	std	Y+1, r24	; 0x01
    65da:	6a 83       	std	Y+2, r22	; 0x02
    65dc:	4b 83       	std	Y+3, r20	; 0x03
	switch (PORT)
    65de:	89 81       	ldd	r24, Y+1	; 0x01
    65e0:	28 2f       	mov	r18, r24
    65e2:	30 e0       	ldi	r19, 0x00	; 0
    65e4:	3d 83       	std	Y+5, r19	; 0x05
    65e6:	2c 83       	std	Y+4, r18	; 0x04
    65e8:	8c 81       	ldd	r24, Y+4	; 0x04
    65ea:	9d 81       	ldd	r25, Y+5	; 0x05
    65ec:	81 30       	cpi	r24, 0x01	; 1
    65ee:	91 05       	cpc	r25, r1
    65f0:	09 f4       	brne	.+2      	; 0x65f4 <DIO_SET_PIN_DIREC+0x2a>
    65f2:	43 c0       	rjmp	.+134    	; 0x667a <DIO_SET_PIN_DIREC+0xb0>
    65f4:	2c 81       	ldd	r18, Y+4	; 0x04
    65f6:	3d 81       	ldd	r19, Y+5	; 0x05
    65f8:	22 30       	cpi	r18, 0x02	; 2
    65fa:	31 05       	cpc	r19, r1
    65fc:	2c f4       	brge	.+10     	; 0x6608 <DIO_SET_PIN_DIREC+0x3e>
    65fe:	8c 81       	ldd	r24, Y+4	; 0x04
    6600:	9d 81       	ldd	r25, Y+5	; 0x05
    6602:	00 97       	sbiw	r24, 0x00	; 0
    6604:	71 f0       	breq	.+28     	; 0x6622 <DIO_SET_PIN_DIREC+0x58>
    6606:	bc c0       	rjmp	.+376    	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
    6608:	2c 81       	ldd	r18, Y+4	; 0x04
    660a:	3d 81       	ldd	r19, Y+5	; 0x05
    660c:	22 30       	cpi	r18, 0x02	; 2
    660e:	31 05       	cpc	r19, r1
    6610:	09 f4       	brne	.+2      	; 0x6614 <DIO_SET_PIN_DIREC+0x4a>
    6612:	5f c0       	rjmp	.+190    	; 0x66d2 <DIO_SET_PIN_DIREC+0x108>
    6614:	8c 81       	ldd	r24, Y+4	; 0x04
    6616:	9d 81       	ldd	r25, Y+5	; 0x05
    6618:	83 30       	cpi	r24, 0x03	; 3
    661a:	91 05       	cpc	r25, r1
    661c:	09 f4       	brne	.+2      	; 0x6620 <DIO_SET_PIN_DIREC+0x56>
    661e:	85 c0       	rjmp	.+266    	; 0x672a <DIO_SET_PIN_DIREC+0x160>
    6620:	af c0       	rjmp	.+350    	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
	{
		case DIO_PORTA:
		if (DIRECTION == OUTPUT)
    6622:	8b 81       	ldd	r24, Y+3	; 0x03
    6624:	81 30       	cpi	r24, 0x01	; 1
    6626:	a1 f4       	brne	.+40     	; 0x6650 <DIO_SET_PIN_DIREC+0x86>
		{
			SET_BIT (DDRA,PIN);
    6628:	aa e3       	ldi	r26, 0x3A	; 58
    662a:	b0 e0       	ldi	r27, 0x00	; 0
    662c:	ea e3       	ldi	r30, 0x3A	; 58
    662e:	f0 e0       	ldi	r31, 0x00	; 0
    6630:	80 81       	ld	r24, Z
    6632:	48 2f       	mov	r20, r24
    6634:	8a 81       	ldd	r24, Y+2	; 0x02
    6636:	28 2f       	mov	r18, r24
    6638:	30 e0       	ldi	r19, 0x00	; 0
    663a:	81 e0       	ldi	r24, 0x01	; 1
    663c:	90 e0       	ldi	r25, 0x00	; 0
    663e:	02 2e       	mov	r0, r18
    6640:	02 c0       	rjmp	.+4      	; 0x6646 <DIO_SET_PIN_DIREC+0x7c>
    6642:	88 0f       	add	r24, r24
    6644:	99 1f       	adc	r25, r25
    6646:	0a 94       	dec	r0
    6648:	e2 f7       	brpl	.-8      	; 0x6642 <DIO_SET_PIN_DIREC+0x78>
    664a:	84 2b       	or	r24, r20
    664c:	8c 93       	st	X, r24
    664e:	98 c0       	rjmp	.+304    	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
		}
		else
		{
			CLR_BIT (DDRA,PIN);
    6650:	aa e3       	ldi	r26, 0x3A	; 58
    6652:	b0 e0       	ldi	r27, 0x00	; 0
    6654:	ea e3       	ldi	r30, 0x3A	; 58
    6656:	f0 e0       	ldi	r31, 0x00	; 0
    6658:	80 81       	ld	r24, Z
    665a:	48 2f       	mov	r20, r24
    665c:	8a 81       	ldd	r24, Y+2	; 0x02
    665e:	28 2f       	mov	r18, r24
    6660:	30 e0       	ldi	r19, 0x00	; 0
    6662:	81 e0       	ldi	r24, 0x01	; 1
    6664:	90 e0       	ldi	r25, 0x00	; 0
    6666:	02 2e       	mov	r0, r18
    6668:	02 c0       	rjmp	.+4      	; 0x666e <DIO_SET_PIN_DIREC+0xa4>
    666a:	88 0f       	add	r24, r24
    666c:	99 1f       	adc	r25, r25
    666e:	0a 94       	dec	r0
    6670:	e2 f7       	brpl	.-8      	; 0x666a <DIO_SET_PIN_DIREC+0xa0>
    6672:	80 95       	com	r24
    6674:	84 23       	and	r24, r20
    6676:	8c 93       	st	X, r24
    6678:	83 c0       	rjmp	.+262    	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
		}
		break;

		case DIO_PORTB:
		if (DIRECTION == OUTPUT)
    667a:	8b 81       	ldd	r24, Y+3	; 0x03
    667c:	81 30       	cpi	r24, 0x01	; 1
    667e:	a1 f4       	brne	.+40     	; 0x66a8 <DIO_SET_PIN_DIREC+0xde>
		{
			SET_BIT (DDRB,PIN);
    6680:	a7 e3       	ldi	r26, 0x37	; 55
    6682:	b0 e0       	ldi	r27, 0x00	; 0
    6684:	e7 e3       	ldi	r30, 0x37	; 55
    6686:	f0 e0       	ldi	r31, 0x00	; 0
    6688:	80 81       	ld	r24, Z
    668a:	48 2f       	mov	r20, r24
    668c:	8a 81       	ldd	r24, Y+2	; 0x02
    668e:	28 2f       	mov	r18, r24
    6690:	30 e0       	ldi	r19, 0x00	; 0
    6692:	81 e0       	ldi	r24, 0x01	; 1
    6694:	90 e0       	ldi	r25, 0x00	; 0
    6696:	02 2e       	mov	r0, r18
    6698:	02 c0       	rjmp	.+4      	; 0x669e <DIO_SET_PIN_DIREC+0xd4>
    669a:	88 0f       	add	r24, r24
    669c:	99 1f       	adc	r25, r25
    669e:	0a 94       	dec	r0
    66a0:	e2 f7       	brpl	.-8      	; 0x669a <DIO_SET_PIN_DIREC+0xd0>
    66a2:	84 2b       	or	r24, r20
    66a4:	8c 93       	st	X, r24
    66a6:	6c c0       	rjmp	.+216    	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
		}
		else
		{
			CLR_BIT (DDRB,PIN);
    66a8:	a7 e3       	ldi	r26, 0x37	; 55
    66aa:	b0 e0       	ldi	r27, 0x00	; 0
    66ac:	e7 e3       	ldi	r30, 0x37	; 55
    66ae:	f0 e0       	ldi	r31, 0x00	; 0
    66b0:	80 81       	ld	r24, Z
    66b2:	48 2f       	mov	r20, r24
    66b4:	8a 81       	ldd	r24, Y+2	; 0x02
    66b6:	28 2f       	mov	r18, r24
    66b8:	30 e0       	ldi	r19, 0x00	; 0
    66ba:	81 e0       	ldi	r24, 0x01	; 1
    66bc:	90 e0       	ldi	r25, 0x00	; 0
    66be:	02 2e       	mov	r0, r18
    66c0:	02 c0       	rjmp	.+4      	; 0x66c6 <DIO_SET_PIN_DIREC+0xfc>
    66c2:	88 0f       	add	r24, r24
    66c4:	99 1f       	adc	r25, r25
    66c6:	0a 94       	dec	r0
    66c8:	e2 f7       	brpl	.-8      	; 0x66c2 <DIO_SET_PIN_DIREC+0xf8>
    66ca:	80 95       	com	r24
    66cc:	84 23       	and	r24, r20
    66ce:	8c 93       	st	X, r24
    66d0:	57 c0       	rjmp	.+174    	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
		}
		break;

		case DIO_PORTC:
		if (DIRECTION == OUTPUT)
    66d2:	8b 81       	ldd	r24, Y+3	; 0x03
    66d4:	81 30       	cpi	r24, 0x01	; 1
    66d6:	a1 f4       	brne	.+40     	; 0x6700 <DIO_SET_PIN_DIREC+0x136>
		{
			SET_BIT (DDRC,PIN);
    66d8:	a4 e3       	ldi	r26, 0x34	; 52
    66da:	b0 e0       	ldi	r27, 0x00	; 0
    66dc:	e4 e3       	ldi	r30, 0x34	; 52
    66de:	f0 e0       	ldi	r31, 0x00	; 0
    66e0:	80 81       	ld	r24, Z
    66e2:	48 2f       	mov	r20, r24
    66e4:	8a 81       	ldd	r24, Y+2	; 0x02
    66e6:	28 2f       	mov	r18, r24
    66e8:	30 e0       	ldi	r19, 0x00	; 0
    66ea:	81 e0       	ldi	r24, 0x01	; 1
    66ec:	90 e0       	ldi	r25, 0x00	; 0
    66ee:	02 2e       	mov	r0, r18
    66f0:	02 c0       	rjmp	.+4      	; 0x66f6 <DIO_SET_PIN_DIREC+0x12c>
    66f2:	88 0f       	add	r24, r24
    66f4:	99 1f       	adc	r25, r25
    66f6:	0a 94       	dec	r0
    66f8:	e2 f7       	brpl	.-8      	; 0x66f2 <DIO_SET_PIN_DIREC+0x128>
    66fa:	84 2b       	or	r24, r20
    66fc:	8c 93       	st	X, r24
    66fe:	40 c0       	rjmp	.+128    	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
		}
		else
		{
			CLR_BIT (DDRC,PIN);
    6700:	a4 e3       	ldi	r26, 0x34	; 52
    6702:	b0 e0       	ldi	r27, 0x00	; 0
    6704:	e4 e3       	ldi	r30, 0x34	; 52
    6706:	f0 e0       	ldi	r31, 0x00	; 0
    6708:	80 81       	ld	r24, Z
    670a:	48 2f       	mov	r20, r24
    670c:	8a 81       	ldd	r24, Y+2	; 0x02
    670e:	28 2f       	mov	r18, r24
    6710:	30 e0       	ldi	r19, 0x00	; 0
    6712:	81 e0       	ldi	r24, 0x01	; 1
    6714:	90 e0       	ldi	r25, 0x00	; 0
    6716:	02 2e       	mov	r0, r18
    6718:	02 c0       	rjmp	.+4      	; 0x671e <DIO_SET_PIN_DIREC+0x154>
    671a:	88 0f       	add	r24, r24
    671c:	99 1f       	adc	r25, r25
    671e:	0a 94       	dec	r0
    6720:	e2 f7       	brpl	.-8      	; 0x671a <DIO_SET_PIN_DIREC+0x150>
    6722:	80 95       	com	r24
    6724:	84 23       	and	r24, r20
    6726:	8c 93       	st	X, r24
    6728:	2b c0       	rjmp	.+86     	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
		}
		break;

		case DIO_PORTD:
		if (DIRECTION == OUTPUT)
    672a:	8b 81       	ldd	r24, Y+3	; 0x03
    672c:	81 30       	cpi	r24, 0x01	; 1
    672e:	a1 f4       	brne	.+40     	; 0x6758 <DIO_SET_PIN_DIREC+0x18e>
		{
			SET_BIT (DDRD,PIN);
    6730:	a1 e3       	ldi	r26, 0x31	; 49
    6732:	b0 e0       	ldi	r27, 0x00	; 0
    6734:	e1 e3       	ldi	r30, 0x31	; 49
    6736:	f0 e0       	ldi	r31, 0x00	; 0
    6738:	80 81       	ld	r24, Z
    673a:	48 2f       	mov	r20, r24
    673c:	8a 81       	ldd	r24, Y+2	; 0x02
    673e:	28 2f       	mov	r18, r24
    6740:	30 e0       	ldi	r19, 0x00	; 0
    6742:	81 e0       	ldi	r24, 0x01	; 1
    6744:	90 e0       	ldi	r25, 0x00	; 0
    6746:	02 2e       	mov	r0, r18
    6748:	02 c0       	rjmp	.+4      	; 0x674e <DIO_SET_PIN_DIREC+0x184>
    674a:	88 0f       	add	r24, r24
    674c:	99 1f       	adc	r25, r25
    674e:	0a 94       	dec	r0
    6750:	e2 f7       	brpl	.-8      	; 0x674a <DIO_SET_PIN_DIREC+0x180>
    6752:	84 2b       	or	r24, r20
    6754:	8c 93       	st	X, r24
    6756:	14 c0       	rjmp	.+40     	; 0x6780 <DIO_SET_PIN_DIREC+0x1b6>
		}
		else
		{
			CLR_BIT (DDRD,PIN);
    6758:	a1 e3       	ldi	r26, 0x31	; 49
    675a:	b0 e0       	ldi	r27, 0x00	; 0
    675c:	e1 e3       	ldi	r30, 0x31	; 49
    675e:	f0 e0       	ldi	r31, 0x00	; 0
    6760:	80 81       	ld	r24, Z
    6762:	48 2f       	mov	r20, r24
    6764:	8a 81       	ldd	r24, Y+2	; 0x02
    6766:	28 2f       	mov	r18, r24
    6768:	30 e0       	ldi	r19, 0x00	; 0
    676a:	81 e0       	ldi	r24, 0x01	; 1
    676c:	90 e0       	ldi	r25, 0x00	; 0
    676e:	02 2e       	mov	r0, r18
    6770:	02 c0       	rjmp	.+4      	; 0x6776 <DIO_SET_PIN_DIREC+0x1ac>
    6772:	88 0f       	add	r24, r24
    6774:	99 1f       	adc	r25, r25
    6776:	0a 94       	dec	r0
    6778:	e2 f7       	brpl	.-8      	; 0x6772 <DIO_SET_PIN_DIREC+0x1a8>
    677a:	80 95       	com	r24
    677c:	84 23       	and	r24, r20
    677e:	8c 93       	st	X, r24
		}
		break;
	}
}
    6780:	0f 90       	pop	r0
    6782:	0f 90       	pop	r0
    6784:	0f 90       	pop	r0
    6786:	0f 90       	pop	r0
    6788:	0f 90       	pop	r0
    678a:	cf 91       	pop	r28
    678c:	df 91       	pop	r29
    678e:	08 95       	ret

00006790 <DIO_SET_PIN_VALUE>:


void DIO_SET_PIN_VALUE (DIO_PORT_ID PORT , DIO_PIN_ID PIN , DIO_LEVEL VALUE)

{
    6790:	df 93       	push	r29
    6792:	cf 93       	push	r28
    6794:	00 d0       	rcall	.+0      	; 0x6796 <DIO_SET_PIN_VALUE+0x6>
    6796:	00 d0       	rcall	.+0      	; 0x6798 <DIO_SET_PIN_VALUE+0x8>
    6798:	0f 92       	push	r0
    679a:	cd b7       	in	r28, 0x3d	; 61
    679c:	de b7       	in	r29, 0x3e	; 62
    679e:	89 83       	std	Y+1, r24	; 0x01
    67a0:	6a 83       	std	Y+2, r22	; 0x02
    67a2:	4b 83       	std	Y+3, r20	; 0x03
	switch (PORT)
    67a4:	89 81       	ldd	r24, Y+1	; 0x01
    67a6:	28 2f       	mov	r18, r24
    67a8:	30 e0       	ldi	r19, 0x00	; 0
    67aa:	3d 83       	std	Y+5, r19	; 0x05
    67ac:	2c 83       	std	Y+4, r18	; 0x04
    67ae:	8c 81       	ldd	r24, Y+4	; 0x04
    67b0:	9d 81       	ldd	r25, Y+5	; 0x05
    67b2:	81 30       	cpi	r24, 0x01	; 1
    67b4:	91 05       	cpc	r25, r1
    67b6:	09 f4       	brne	.+2      	; 0x67ba <DIO_SET_PIN_VALUE+0x2a>
    67b8:	43 c0       	rjmp	.+134    	; 0x6840 <DIO_SET_PIN_VALUE+0xb0>
    67ba:	2c 81       	ldd	r18, Y+4	; 0x04
    67bc:	3d 81       	ldd	r19, Y+5	; 0x05
    67be:	22 30       	cpi	r18, 0x02	; 2
    67c0:	31 05       	cpc	r19, r1
    67c2:	2c f4       	brge	.+10     	; 0x67ce <DIO_SET_PIN_VALUE+0x3e>
    67c4:	8c 81       	ldd	r24, Y+4	; 0x04
    67c6:	9d 81       	ldd	r25, Y+5	; 0x05
    67c8:	00 97       	sbiw	r24, 0x00	; 0
    67ca:	71 f0       	breq	.+28     	; 0x67e8 <DIO_SET_PIN_VALUE+0x58>
    67cc:	bc c0       	rjmp	.+376    	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
    67ce:	2c 81       	ldd	r18, Y+4	; 0x04
    67d0:	3d 81       	ldd	r19, Y+5	; 0x05
    67d2:	22 30       	cpi	r18, 0x02	; 2
    67d4:	31 05       	cpc	r19, r1
    67d6:	09 f4       	brne	.+2      	; 0x67da <DIO_SET_PIN_VALUE+0x4a>
    67d8:	5f c0       	rjmp	.+190    	; 0x6898 <DIO_SET_PIN_VALUE+0x108>
    67da:	8c 81       	ldd	r24, Y+4	; 0x04
    67dc:	9d 81       	ldd	r25, Y+5	; 0x05
    67de:	83 30       	cpi	r24, 0x03	; 3
    67e0:	91 05       	cpc	r25, r1
    67e2:	09 f4       	brne	.+2      	; 0x67e6 <DIO_SET_PIN_VALUE+0x56>
    67e4:	85 c0       	rjmp	.+266    	; 0x68f0 <DIO_SET_PIN_VALUE+0x160>
    67e6:	af c0       	rjmp	.+350    	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
	{
		case DIO_PORTA:
		if (VALUE == STD_LOW)
    67e8:	8b 81       	ldd	r24, Y+3	; 0x03
    67ea:	88 23       	and	r24, r24
    67ec:	a9 f4       	brne	.+42     	; 0x6818 <DIO_SET_PIN_VALUE+0x88>
		{
			CLR_BIT ( PORTA, PIN);
    67ee:	ab e3       	ldi	r26, 0x3B	; 59
    67f0:	b0 e0       	ldi	r27, 0x00	; 0
    67f2:	eb e3       	ldi	r30, 0x3B	; 59
    67f4:	f0 e0       	ldi	r31, 0x00	; 0
    67f6:	80 81       	ld	r24, Z
    67f8:	48 2f       	mov	r20, r24
    67fa:	8a 81       	ldd	r24, Y+2	; 0x02
    67fc:	28 2f       	mov	r18, r24
    67fe:	30 e0       	ldi	r19, 0x00	; 0
    6800:	81 e0       	ldi	r24, 0x01	; 1
    6802:	90 e0       	ldi	r25, 0x00	; 0
    6804:	02 2e       	mov	r0, r18
    6806:	02 c0       	rjmp	.+4      	; 0x680c <DIO_SET_PIN_VALUE+0x7c>
    6808:	88 0f       	add	r24, r24
    680a:	99 1f       	adc	r25, r25
    680c:	0a 94       	dec	r0
    680e:	e2 f7       	brpl	.-8      	; 0x6808 <DIO_SET_PIN_VALUE+0x78>
    6810:	80 95       	com	r24
    6812:	84 23       	and	r24, r20
    6814:	8c 93       	st	X, r24
    6816:	97 c0       	rjmp	.+302    	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
		}
		else
		{
			SET_BIT(PORTA,PIN);
    6818:	ab e3       	ldi	r26, 0x3B	; 59
    681a:	b0 e0       	ldi	r27, 0x00	; 0
    681c:	eb e3       	ldi	r30, 0x3B	; 59
    681e:	f0 e0       	ldi	r31, 0x00	; 0
    6820:	80 81       	ld	r24, Z
    6822:	48 2f       	mov	r20, r24
    6824:	8a 81       	ldd	r24, Y+2	; 0x02
    6826:	28 2f       	mov	r18, r24
    6828:	30 e0       	ldi	r19, 0x00	; 0
    682a:	81 e0       	ldi	r24, 0x01	; 1
    682c:	90 e0       	ldi	r25, 0x00	; 0
    682e:	02 2e       	mov	r0, r18
    6830:	02 c0       	rjmp	.+4      	; 0x6836 <DIO_SET_PIN_VALUE+0xa6>
    6832:	88 0f       	add	r24, r24
    6834:	99 1f       	adc	r25, r25
    6836:	0a 94       	dec	r0
    6838:	e2 f7       	brpl	.-8      	; 0x6832 <DIO_SET_PIN_VALUE+0xa2>
    683a:	84 2b       	or	r24, r20
    683c:	8c 93       	st	X, r24
    683e:	83 c0       	rjmp	.+262    	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
		}
		break;

		case DIO_PORTB:
		if (VALUE == STD_LOW)
    6840:	8b 81       	ldd	r24, Y+3	; 0x03
    6842:	88 23       	and	r24, r24
    6844:	a9 f4       	brne	.+42     	; 0x6870 <DIO_SET_PIN_VALUE+0xe0>
		{
			CLR_BIT (PORTB,PIN);
    6846:	a8 e3       	ldi	r26, 0x38	; 56
    6848:	b0 e0       	ldi	r27, 0x00	; 0
    684a:	e8 e3       	ldi	r30, 0x38	; 56
    684c:	f0 e0       	ldi	r31, 0x00	; 0
    684e:	80 81       	ld	r24, Z
    6850:	48 2f       	mov	r20, r24
    6852:	8a 81       	ldd	r24, Y+2	; 0x02
    6854:	28 2f       	mov	r18, r24
    6856:	30 e0       	ldi	r19, 0x00	; 0
    6858:	81 e0       	ldi	r24, 0x01	; 1
    685a:	90 e0       	ldi	r25, 0x00	; 0
    685c:	02 2e       	mov	r0, r18
    685e:	02 c0       	rjmp	.+4      	; 0x6864 <DIO_SET_PIN_VALUE+0xd4>
    6860:	88 0f       	add	r24, r24
    6862:	99 1f       	adc	r25, r25
    6864:	0a 94       	dec	r0
    6866:	e2 f7       	brpl	.-8      	; 0x6860 <DIO_SET_PIN_VALUE+0xd0>
    6868:	80 95       	com	r24
    686a:	84 23       	and	r24, r20
    686c:	8c 93       	st	X, r24
    686e:	6b c0       	rjmp	.+214    	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
		}
		else
		{
			SET_BIT(PORTB,PIN);
    6870:	a8 e3       	ldi	r26, 0x38	; 56
    6872:	b0 e0       	ldi	r27, 0x00	; 0
    6874:	e8 e3       	ldi	r30, 0x38	; 56
    6876:	f0 e0       	ldi	r31, 0x00	; 0
    6878:	80 81       	ld	r24, Z
    687a:	48 2f       	mov	r20, r24
    687c:	8a 81       	ldd	r24, Y+2	; 0x02
    687e:	28 2f       	mov	r18, r24
    6880:	30 e0       	ldi	r19, 0x00	; 0
    6882:	81 e0       	ldi	r24, 0x01	; 1
    6884:	90 e0       	ldi	r25, 0x00	; 0
    6886:	02 2e       	mov	r0, r18
    6888:	02 c0       	rjmp	.+4      	; 0x688e <DIO_SET_PIN_VALUE+0xfe>
    688a:	88 0f       	add	r24, r24
    688c:	99 1f       	adc	r25, r25
    688e:	0a 94       	dec	r0
    6890:	e2 f7       	brpl	.-8      	; 0x688a <DIO_SET_PIN_VALUE+0xfa>
    6892:	84 2b       	or	r24, r20
    6894:	8c 93       	st	X, r24
    6896:	57 c0       	rjmp	.+174    	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
		}
		break;

		case DIO_PORTC:
		if (VALUE == STD_LOW)
    6898:	8b 81       	ldd	r24, Y+3	; 0x03
    689a:	88 23       	and	r24, r24
    689c:	a9 f4       	brne	.+42     	; 0x68c8 <DIO_SET_PIN_VALUE+0x138>
		{
			CLR_BIT (PORTC,PIN);
    689e:	a5 e3       	ldi	r26, 0x35	; 53
    68a0:	b0 e0       	ldi	r27, 0x00	; 0
    68a2:	e5 e3       	ldi	r30, 0x35	; 53
    68a4:	f0 e0       	ldi	r31, 0x00	; 0
    68a6:	80 81       	ld	r24, Z
    68a8:	48 2f       	mov	r20, r24
    68aa:	8a 81       	ldd	r24, Y+2	; 0x02
    68ac:	28 2f       	mov	r18, r24
    68ae:	30 e0       	ldi	r19, 0x00	; 0
    68b0:	81 e0       	ldi	r24, 0x01	; 1
    68b2:	90 e0       	ldi	r25, 0x00	; 0
    68b4:	02 2e       	mov	r0, r18
    68b6:	02 c0       	rjmp	.+4      	; 0x68bc <DIO_SET_PIN_VALUE+0x12c>
    68b8:	88 0f       	add	r24, r24
    68ba:	99 1f       	adc	r25, r25
    68bc:	0a 94       	dec	r0
    68be:	e2 f7       	brpl	.-8      	; 0x68b8 <DIO_SET_PIN_VALUE+0x128>
    68c0:	80 95       	com	r24
    68c2:	84 23       	and	r24, r20
    68c4:	8c 93       	st	X, r24
    68c6:	3f c0       	rjmp	.+126    	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
		}
		else
		{
			SET_BIT(PORTC,PIN);
    68c8:	a5 e3       	ldi	r26, 0x35	; 53
    68ca:	b0 e0       	ldi	r27, 0x00	; 0
    68cc:	e5 e3       	ldi	r30, 0x35	; 53
    68ce:	f0 e0       	ldi	r31, 0x00	; 0
    68d0:	80 81       	ld	r24, Z
    68d2:	48 2f       	mov	r20, r24
    68d4:	8a 81       	ldd	r24, Y+2	; 0x02
    68d6:	28 2f       	mov	r18, r24
    68d8:	30 e0       	ldi	r19, 0x00	; 0
    68da:	81 e0       	ldi	r24, 0x01	; 1
    68dc:	90 e0       	ldi	r25, 0x00	; 0
    68de:	02 2e       	mov	r0, r18
    68e0:	02 c0       	rjmp	.+4      	; 0x68e6 <DIO_SET_PIN_VALUE+0x156>
    68e2:	88 0f       	add	r24, r24
    68e4:	99 1f       	adc	r25, r25
    68e6:	0a 94       	dec	r0
    68e8:	e2 f7       	brpl	.-8      	; 0x68e2 <DIO_SET_PIN_VALUE+0x152>
    68ea:	84 2b       	or	r24, r20
    68ec:	8c 93       	st	X, r24
    68ee:	2b c0       	rjmp	.+86     	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
		}
		break;

		case DIO_PORTD:
		if (VALUE == STD_LOW)
    68f0:	8b 81       	ldd	r24, Y+3	; 0x03
    68f2:	88 23       	and	r24, r24
    68f4:	a9 f4       	brne	.+42     	; 0x6920 <DIO_SET_PIN_VALUE+0x190>
		{
			CLR_BIT (PORTD,PIN);
    68f6:	a2 e3       	ldi	r26, 0x32	; 50
    68f8:	b0 e0       	ldi	r27, 0x00	; 0
    68fa:	e2 e3       	ldi	r30, 0x32	; 50
    68fc:	f0 e0       	ldi	r31, 0x00	; 0
    68fe:	80 81       	ld	r24, Z
    6900:	48 2f       	mov	r20, r24
    6902:	8a 81       	ldd	r24, Y+2	; 0x02
    6904:	28 2f       	mov	r18, r24
    6906:	30 e0       	ldi	r19, 0x00	; 0
    6908:	81 e0       	ldi	r24, 0x01	; 1
    690a:	90 e0       	ldi	r25, 0x00	; 0
    690c:	02 2e       	mov	r0, r18
    690e:	02 c0       	rjmp	.+4      	; 0x6914 <DIO_SET_PIN_VALUE+0x184>
    6910:	88 0f       	add	r24, r24
    6912:	99 1f       	adc	r25, r25
    6914:	0a 94       	dec	r0
    6916:	e2 f7       	brpl	.-8      	; 0x6910 <DIO_SET_PIN_VALUE+0x180>
    6918:	80 95       	com	r24
    691a:	84 23       	and	r24, r20
    691c:	8c 93       	st	X, r24
    691e:	13 c0       	rjmp	.+38     	; 0x6946 <DIO_SET_PIN_VALUE+0x1b6>
		}
		else
		{
			SET_BIT(PORTD,PIN);
    6920:	a2 e3       	ldi	r26, 0x32	; 50
    6922:	b0 e0       	ldi	r27, 0x00	; 0
    6924:	e2 e3       	ldi	r30, 0x32	; 50
    6926:	f0 e0       	ldi	r31, 0x00	; 0
    6928:	80 81       	ld	r24, Z
    692a:	48 2f       	mov	r20, r24
    692c:	8a 81       	ldd	r24, Y+2	; 0x02
    692e:	28 2f       	mov	r18, r24
    6930:	30 e0       	ldi	r19, 0x00	; 0
    6932:	81 e0       	ldi	r24, 0x01	; 1
    6934:	90 e0       	ldi	r25, 0x00	; 0
    6936:	02 2e       	mov	r0, r18
    6938:	02 c0       	rjmp	.+4      	; 0x693e <DIO_SET_PIN_VALUE+0x1ae>
    693a:	88 0f       	add	r24, r24
    693c:	99 1f       	adc	r25, r25
    693e:	0a 94       	dec	r0
    6940:	e2 f7       	brpl	.-8      	; 0x693a <DIO_SET_PIN_VALUE+0x1aa>
    6942:	84 2b       	or	r24, r20
    6944:	8c 93       	st	X, r24
		}
		break;
	}
}
    6946:	0f 90       	pop	r0
    6948:	0f 90       	pop	r0
    694a:	0f 90       	pop	r0
    694c:	0f 90       	pop	r0
    694e:	0f 90       	pop	r0
    6950:	cf 91       	pop	r28
    6952:	df 91       	pop	r29
    6954:	08 95       	ret

00006956 <DIO_SET_PORT_VALUE>:


void DIO_SET_PORT_VALUE (DIO_PORT_ID PORT, uint8 VALUE)
{
    6956:	df 93       	push	r29
    6958:	cf 93       	push	r28
    695a:	00 d0       	rcall	.+0      	; 0x695c <DIO_SET_PORT_VALUE+0x6>
    695c:	00 d0       	rcall	.+0      	; 0x695e <DIO_SET_PORT_VALUE+0x8>
    695e:	cd b7       	in	r28, 0x3d	; 61
    6960:	de b7       	in	r29, 0x3e	; 62
    6962:	89 83       	std	Y+1, r24	; 0x01
    6964:	6a 83       	std	Y+2, r22	; 0x02
	switch(PORT)
    6966:	89 81       	ldd	r24, Y+1	; 0x01
    6968:	28 2f       	mov	r18, r24
    696a:	30 e0       	ldi	r19, 0x00	; 0
    696c:	3c 83       	std	Y+4, r19	; 0x04
    696e:	2b 83       	std	Y+3, r18	; 0x03
    6970:	8b 81       	ldd	r24, Y+3	; 0x03
    6972:	9c 81       	ldd	r25, Y+4	; 0x04
    6974:	81 30       	cpi	r24, 0x01	; 1
    6976:	91 05       	cpc	r25, r1
    6978:	d1 f0       	breq	.+52     	; 0x69ae <DIO_SET_PORT_VALUE+0x58>
    697a:	2b 81       	ldd	r18, Y+3	; 0x03
    697c:	3c 81       	ldd	r19, Y+4	; 0x04
    697e:	22 30       	cpi	r18, 0x02	; 2
    6980:	31 05       	cpc	r19, r1
    6982:	2c f4       	brge	.+10     	; 0x698e <DIO_SET_PORT_VALUE+0x38>
    6984:	8b 81       	ldd	r24, Y+3	; 0x03
    6986:	9c 81       	ldd	r25, Y+4	; 0x04
    6988:	00 97       	sbiw	r24, 0x00	; 0
    698a:	61 f0       	breq	.+24     	; 0x69a4 <DIO_SET_PORT_VALUE+0x4e>
    698c:	1e c0       	rjmp	.+60     	; 0x69ca <DIO_SET_PORT_VALUE+0x74>
    698e:	2b 81       	ldd	r18, Y+3	; 0x03
    6990:	3c 81       	ldd	r19, Y+4	; 0x04
    6992:	22 30       	cpi	r18, 0x02	; 2
    6994:	31 05       	cpc	r19, r1
    6996:	81 f0       	breq	.+32     	; 0x69b8 <DIO_SET_PORT_VALUE+0x62>
    6998:	8b 81       	ldd	r24, Y+3	; 0x03
    699a:	9c 81       	ldd	r25, Y+4	; 0x04
    699c:	83 30       	cpi	r24, 0x03	; 3
    699e:	91 05       	cpc	r25, r1
    69a0:	81 f0       	breq	.+32     	; 0x69c2 <DIO_SET_PORT_VALUE+0x6c>
    69a2:	13 c0       	rjmp	.+38     	; 0x69ca <DIO_SET_PORT_VALUE+0x74>
	{
		case DIO_PORTA:
		
		PORTA = VALUE;
    69a4:	eb e3       	ldi	r30, 0x3B	; 59
    69a6:	f0 e0       	ldi	r31, 0x00	; 0
    69a8:	8a 81       	ldd	r24, Y+2	; 0x02
    69aa:	80 83       	st	Z, r24
    69ac:	0e c0       	rjmp	.+28     	; 0x69ca <DIO_SET_PORT_VALUE+0x74>
		
		break;
		
		case DIO_PORTB:
		
		PORTB = VALUE;
    69ae:	e8 e3       	ldi	r30, 0x38	; 56
    69b0:	f0 e0       	ldi	r31, 0x00	; 0
    69b2:	8a 81       	ldd	r24, Y+2	; 0x02
    69b4:	80 83       	st	Z, r24
    69b6:	09 c0       	rjmp	.+18     	; 0x69ca <DIO_SET_PORT_VALUE+0x74>
		
		break;
		
		case DIO_PORTC:
		
		PORTC = VALUE;
    69b8:	e5 e3       	ldi	r30, 0x35	; 53
    69ba:	f0 e0       	ldi	r31, 0x00	; 0
    69bc:	8a 81       	ldd	r24, Y+2	; 0x02
    69be:	80 83       	st	Z, r24
    69c0:	04 c0       	rjmp	.+8      	; 0x69ca <DIO_SET_PORT_VALUE+0x74>
		
		break;
		
		case DIO_PORTD:
		
		PORTD = VALUE;
    69c2:	e2 e3       	ldi	r30, 0x32	; 50
    69c4:	f0 e0       	ldi	r31, 0x00	; 0
    69c6:	8a 81       	ldd	r24, Y+2	; 0x02
    69c8:	80 83       	st	Z, r24
		break;
		
		default:
		break;
	}
}
    69ca:	0f 90       	pop	r0
    69cc:	0f 90       	pop	r0
    69ce:	0f 90       	pop	r0
    69d0:	0f 90       	pop	r0
    69d2:	cf 91       	pop	r28
    69d4:	df 91       	pop	r29
    69d6:	08 95       	ret

000069d8 <DIO_TOOGLE_PIN>:

void DIO_TOOGLE_PIN (DIO_PORT_ID PORT, DIO_PIN_ID PIN)
{
    69d8:	df 93       	push	r29
    69da:	cf 93       	push	r28
    69dc:	00 d0       	rcall	.+0      	; 0x69de <DIO_TOOGLE_PIN+0x6>
    69de:	00 d0       	rcall	.+0      	; 0x69e0 <DIO_TOOGLE_PIN+0x8>
    69e0:	cd b7       	in	r28, 0x3d	; 61
    69e2:	de b7       	in	r29, 0x3e	; 62
    69e4:	89 83       	std	Y+1, r24	; 0x01
    69e6:	6a 83       	std	Y+2, r22	; 0x02
	switch (PORT)
    69e8:	89 81       	ldd	r24, Y+1	; 0x01
    69ea:	28 2f       	mov	r18, r24
    69ec:	30 e0       	ldi	r19, 0x00	; 0
    69ee:	3c 83       	std	Y+4, r19	; 0x04
    69f0:	2b 83       	std	Y+3, r18	; 0x03
    69f2:	8b 81       	ldd	r24, Y+3	; 0x03
    69f4:	9c 81       	ldd	r25, Y+4	; 0x04
    69f6:	81 30       	cpi	r24, 0x01	; 1
    69f8:	91 05       	cpc	r25, r1
    69fa:	49 f1       	breq	.+82     	; 0x6a4e <DIO_TOOGLE_PIN+0x76>
    69fc:	2b 81       	ldd	r18, Y+3	; 0x03
    69fe:	3c 81       	ldd	r19, Y+4	; 0x04
    6a00:	22 30       	cpi	r18, 0x02	; 2
    6a02:	31 05       	cpc	r19, r1
    6a04:	2c f4       	brge	.+10     	; 0x6a10 <DIO_TOOGLE_PIN+0x38>
    6a06:	8b 81       	ldd	r24, Y+3	; 0x03
    6a08:	9c 81       	ldd	r25, Y+4	; 0x04
    6a0a:	00 97       	sbiw	r24, 0x00	; 0
    6a0c:	61 f0       	breq	.+24     	; 0x6a26 <DIO_TOOGLE_PIN+0x4e>
    6a0e:	5a c0       	rjmp	.+180    	; 0x6ac4 <DIO_TOOGLE_PIN+0xec>
    6a10:	2b 81       	ldd	r18, Y+3	; 0x03
    6a12:	3c 81       	ldd	r19, Y+4	; 0x04
    6a14:	22 30       	cpi	r18, 0x02	; 2
    6a16:	31 05       	cpc	r19, r1
    6a18:	71 f1       	breq	.+92     	; 0x6a76 <DIO_TOOGLE_PIN+0x9e>
    6a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    6a1e:	83 30       	cpi	r24, 0x03	; 3
    6a20:	91 05       	cpc	r25, r1
    6a22:	e9 f1       	breq	.+122    	; 0x6a9e <DIO_TOOGLE_PIN+0xc6>
    6a24:	4f c0       	rjmp	.+158    	; 0x6ac4 <DIO_TOOGLE_PIN+0xec>
	{
		case DIO_PORTA:
		TOOGLE_BIT (PORTA,PIN);
    6a26:	ab e3       	ldi	r26, 0x3B	; 59
    6a28:	b0 e0       	ldi	r27, 0x00	; 0
    6a2a:	eb e3       	ldi	r30, 0x3B	; 59
    6a2c:	f0 e0       	ldi	r31, 0x00	; 0
    6a2e:	80 81       	ld	r24, Z
    6a30:	48 2f       	mov	r20, r24
    6a32:	8a 81       	ldd	r24, Y+2	; 0x02
    6a34:	28 2f       	mov	r18, r24
    6a36:	30 e0       	ldi	r19, 0x00	; 0
    6a38:	81 e0       	ldi	r24, 0x01	; 1
    6a3a:	90 e0       	ldi	r25, 0x00	; 0
    6a3c:	02 2e       	mov	r0, r18
    6a3e:	02 c0       	rjmp	.+4      	; 0x6a44 <DIO_TOOGLE_PIN+0x6c>
    6a40:	88 0f       	add	r24, r24
    6a42:	99 1f       	adc	r25, r25
    6a44:	0a 94       	dec	r0
    6a46:	e2 f7       	brpl	.-8      	; 0x6a40 <DIO_TOOGLE_PIN+0x68>
    6a48:	84 27       	eor	r24, r20
    6a4a:	8c 93       	st	X, r24
    6a4c:	3b c0       	rjmp	.+118    	; 0x6ac4 <DIO_TOOGLE_PIN+0xec>
		break;

		case DIO_PORTB:
		TOOGLE_BIT (PORTB,PIN);
    6a4e:	a8 e3       	ldi	r26, 0x38	; 56
    6a50:	b0 e0       	ldi	r27, 0x00	; 0
    6a52:	e8 e3       	ldi	r30, 0x38	; 56
    6a54:	f0 e0       	ldi	r31, 0x00	; 0
    6a56:	80 81       	ld	r24, Z
    6a58:	48 2f       	mov	r20, r24
    6a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    6a5c:	28 2f       	mov	r18, r24
    6a5e:	30 e0       	ldi	r19, 0x00	; 0
    6a60:	81 e0       	ldi	r24, 0x01	; 1
    6a62:	90 e0       	ldi	r25, 0x00	; 0
    6a64:	02 2e       	mov	r0, r18
    6a66:	02 c0       	rjmp	.+4      	; 0x6a6c <DIO_TOOGLE_PIN+0x94>
    6a68:	88 0f       	add	r24, r24
    6a6a:	99 1f       	adc	r25, r25
    6a6c:	0a 94       	dec	r0
    6a6e:	e2 f7       	brpl	.-8      	; 0x6a68 <DIO_TOOGLE_PIN+0x90>
    6a70:	84 27       	eor	r24, r20
    6a72:	8c 93       	st	X, r24
    6a74:	27 c0       	rjmp	.+78     	; 0x6ac4 <DIO_TOOGLE_PIN+0xec>
		break;

		case DIO_PORTC:
		TOOGLE_BIT (PORTC,PIN);
    6a76:	a5 e3       	ldi	r26, 0x35	; 53
    6a78:	b0 e0       	ldi	r27, 0x00	; 0
    6a7a:	e5 e3       	ldi	r30, 0x35	; 53
    6a7c:	f0 e0       	ldi	r31, 0x00	; 0
    6a7e:	80 81       	ld	r24, Z
    6a80:	48 2f       	mov	r20, r24
    6a82:	8a 81       	ldd	r24, Y+2	; 0x02
    6a84:	28 2f       	mov	r18, r24
    6a86:	30 e0       	ldi	r19, 0x00	; 0
    6a88:	81 e0       	ldi	r24, 0x01	; 1
    6a8a:	90 e0       	ldi	r25, 0x00	; 0
    6a8c:	02 2e       	mov	r0, r18
    6a8e:	02 c0       	rjmp	.+4      	; 0x6a94 <DIO_TOOGLE_PIN+0xbc>
    6a90:	88 0f       	add	r24, r24
    6a92:	99 1f       	adc	r25, r25
    6a94:	0a 94       	dec	r0
    6a96:	e2 f7       	brpl	.-8      	; 0x6a90 <DIO_TOOGLE_PIN+0xb8>
    6a98:	84 27       	eor	r24, r20
    6a9a:	8c 93       	st	X, r24
    6a9c:	13 c0       	rjmp	.+38     	; 0x6ac4 <DIO_TOOGLE_PIN+0xec>
		break;

		case DIO_PORTD:
		TOOGLE_BIT (PORTD,PIN);
    6a9e:	a2 e3       	ldi	r26, 0x32	; 50
    6aa0:	b0 e0       	ldi	r27, 0x00	; 0
    6aa2:	e2 e3       	ldi	r30, 0x32	; 50
    6aa4:	f0 e0       	ldi	r31, 0x00	; 0
    6aa6:	80 81       	ld	r24, Z
    6aa8:	48 2f       	mov	r20, r24
    6aaa:	8a 81       	ldd	r24, Y+2	; 0x02
    6aac:	28 2f       	mov	r18, r24
    6aae:	30 e0       	ldi	r19, 0x00	; 0
    6ab0:	81 e0       	ldi	r24, 0x01	; 1
    6ab2:	90 e0       	ldi	r25, 0x00	; 0
    6ab4:	02 2e       	mov	r0, r18
    6ab6:	02 c0       	rjmp	.+4      	; 0x6abc <DIO_TOOGLE_PIN+0xe4>
    6ab8:	88 0f       	add	r24, r24
    6aba:	99 1f       	adc	r25, r25
    6abc:	0a 94       	dec	r0
    6abe:	e2 f7       	brpl	.-8      	; 0x6ab8 <DIO_TOOGLE_PIN+0xe0>
    6ac0:	84 27       	eor	r24, r20
    6ac2:	8c 93       	st	X, r24
		break;
	}
}
    6ac4:	0f 90       	pop	r0
    6ac6:	0f 90       	pop	r0
    6ac8:	0f 90       	pop	r0
    6aca:	0f 90       	pop	r0
    6acc:	cf 91       	pop	r28
    6ace:	df 91       	pop	r29
    6ad0:	08 95       	ret

00006ad2 <DIO_READ_PIN>:


DIO_LEVEL DIO_READ_PIN (DIO_PORT_ID PORT, DIO_PIN_ID PIN )
{
    6ad2:	df 93       	push	r29
    6ad4:	cf 93       	push	r28
    6ad6:	00 d0       	rcall	.+0      	; 0x6ad8 <DIO_READ_PIN+0x6>
    6ad8:	00 d0       	rcall	.+0      	; 0x6ada <DIO_READ_PIN+0x8>
    6ada:	0f 92       	push	r0
    6adc:	cd b7       	in	r28, 0x3d	; 61
    6ade:	de b7       	in	r29, 0x3e	; 62
    6ae0:	8a 83       	std	Y+2, r24	; 0x02
    6ae2:	6b 83       	std	Y+3, r22	; 0x03
	DIO_LEVEL VALUE;
	
	switch(PORT)
    6ae4:	8a 81       	ldd	r24, Y+2	; 0x02
    6ae6:	28 2f       	mov	r18, r24
    6ae8:	30 e0       	ldi	r19, 0x00	; 0
    6aea:	3d 83       	std	Y+5, r19	; 0x05
    6aec:	2c 83       	std	Y+4, r18	; 0x04
    6aee:	4c 81       	ldd	r20, Y+4	; 0x04
    6af0:	5d 81       	ldd	r21, Y+5	; 0x05
    6af2:	41 30       	cpi	r20, 0x01	; 1
    6af4:	51 05       	cpc	r21, r1
    6af6:	41 f1       	breq	.+80     	; 0x6b48 <DIO_READ_PIN+0x76>
    6af8:	8c 81       	ldd	r24, Y+4	; 0x04
    6afa:	9d 81       	ldd	r25, Y+5	; 0x05
    6afc:	82 30       	cpi	r24, 0x02	; 2
    6afe:	91 05       	cpc	r25, r1
    6b00:	34 f4       	brge	.+12     	; 0x6b0e <DIO_READ_PIN+0x3c>
    6b02:	2c 81       	ldd	r18, Y+4	; 0x04
    6b04:	3d 81       	ldd	r19, Y+5	; 0x05
    6b06:	21 15       	cp	r18, r1
    6b08:	31 05       	cpc	r19, r1
    6b0a:	61 f0       	breq	.+24     	; 0x6b24 <DIO_READ_PIN+0x52>
    6b0c:	52 c0       	rjmp	.+164    	; 0x6bb2 <DIO_READ_PIN+0xe0>
    6b0e:	4c 81       	ldd	r20, Y+4	; 0x04
    6b10:	5d 81       	ldd	r21, Y+5	; 0x05
    6b12:	42 30       	cpi	r20, 0x02	; 2
    6b14:	51 05       	cpc	r21, r1
    6b16:	51 f1       	breq	.+84     	; 0x6b6c <DIO_READ_PIN+0x9a>
    6b18:	8c 81       	ldd	r24, Y+4	; 0x04
    6b1a:	9d 81       	ldd	r25, Y+5	; 0x05
    6b1c:	83 30       	cpi	r24, 0x03	; 3
    6b1e:	91 05       	cpc	r25, r1
    6b20:	b9 f1       	breq	.+110    	; 0x6b90 <DIO_READ_PIN+0xbe>
    6b22:	47 c0       	rjmp	.+142    	; 0x6bb2 <DIO_READ_PIN+0xe0>
	{
		case DIO_PORTA:
		
		VALUE = GET_BIT(PINA,PIN);
    6b24:	e9 e3       	ldi	r30, 0x39	; 57
    6b26:	f0 e0       	ldi	r31, 0x00	; 0
    6b28:	80 81       	ld	r24, Z
    6b2a:	28 2f       	mov	r18, r24
    6b2c:	30 e0       	ldi	r19, 0x00	; 0
    6b2e:	8b 81       	ldd	r24, Y+3	; 0x03
    6b30:	88 2f       	mov	r24, r24
    6b32:	90 e0       	ldi	r25, 0x00	; 0
    6b34:	a9 01       	movw	r20, r18
    6b36:	02 c0       	rjmp	.+4      	; 0x6b3c <DIO_READ_PIN+0x6a>
    6b38:	55 95       	asr	r21
    6b3a:	47 95       	ror	r20
    6b3c:	8a 95       	dec	r24
    6b3e:	e2 f7       	brpl	.-8      	; 0x6b38 <DIO_READ_PIN+0x66>
    6b40:	ca 01       	movw	r24, r20
    6b42:	81 70       	andi	r24, 0x01	; 1
    6b44:	89 83       	std	Y+1, r24	; 0x01
    6b46:	35 c0       	rjmp	.+106    	; 0x6bb2 <DIO_READ_PIN+0xe0>
		
		break;
		
		case DIO_PORTB:
		
		VALUE = GET_BIT(PINB,PIN);
    6b48:	e6 e3       	ldi	r30, 0x36	; 54
    6b4a:	f0 e0       	ldi	r31, 0x00	; 0
    6b4c:	80 81       	ld	r24, Z
    6b4e:	28 2f       	mov	r18, r24
    6b50:	30 e0       	ldi	r19, 0x00	; 0
    6b52:	8b 81       	ldd	r24, Y+3	; 0x03
    6b54:	88 2f       	mov	r24, r24
    6b56:	90 e0       	ldi	r25, 0x00	; 0
    6b58:	a9 01       	movw	r20, r18
    6b5a:	02 c0       	rjmp	.+4      	; 0x6b60 <DIO_READ_PIN+0x8e>
    6b5c:	55 95       	asr	r21
    6b5e:	47 95       	ror	r20
    6b60:	8a 95       	dec	r24
    6b62:	e2 f7       	brpl	.-8      	; 0x6b5c <DIO_READ_PIN+0x8a>
    6b64:	ca 01       	movw	r24, r20
    6b66:	81 70       	andi	r24, 0x01	; 1
    6b68:	89 83       	std	Y+1, r24	; 0x01
    6b6a:	23 c0       	rjmp	.+70     	; 0x6bb2 <DIO_READ_PIN+0xe0>
		
		break;
		
		case DIO_PORTC:
		
		VALUE = GET_BIT(PINC,PIN);
    6b6c:	e3 e3       	ldi	r30, 0x33	; 51
    6b6e:	f0 e0       	ldi	r31, 0x00	; 0
    6b70:	80 81       	ld	r24, Z
    6b72:	28 2f       	mov	r18, r24
    6b74:	30 e0       	ldi	r19, 0x00	; 0
    6b76:	8b 81       	ldd	r24, Y+3	; 0x03
    6b78:	88 2f       	mov	r24, r24
    6b7a:	90 e0       	ldi	r25, 0x00	; 0
    6b7c:	a9 01       	movw	r20, r18
    6b7e:	02 c0       	rjmp	.+4      	; 0x6b84 <DIO_READ_PIN+0xb2>
    6b80:	55 95       	asr	r21
    6b82:	47 95       	ror	r20
    6b84:	8a 95       	dec	r24
    6b86:	e2 f7       	brpl	.-8      	; 0x6b80 <DIO_READ_PIN+0xae>
    6b88:	ca 01       	movw	r24, r20
    6b8a:	81 70       	andi	r24, 0x01	; 1
    6b8c:	89 83       	std	Y+1, r24	; 0x01
    6b8e:	11 c0       	rjmp	.+34     	; 0x6bb2 <DIO_READ_PIN+0xe0>
		
		break;
		
		case DIO_PORTD:
		
		VALUE = GET_BIT(PIND,PIN);
    6b90:	e0 e3       	ldi	r30, 0x30	; 48
    6b92:	f0 e0       	ldi	r31, 0x00	; 0
    6b94:	80 81       	ld	r24, Z
    6b96:	28 2f       	mov	r18, r24
    6b98:	30 e0       	ldi	r19, 0x00	; 0
    6b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    6b9c:	88 2f       	mov	r24, r24
    6b9e:	90 e0       	ldi	r25, 0x00	; 0
    6ba0:	a9 01       	movw	r20, r18
    6ba2:	02 c0       	rjmp	.+4      	; 0x6ba8 <DIO_READ_PIN+0xd6>
    6ba4:	55 95       	asr	r21
    6ba6:	47 95       	ror	r20
    6ba8:	8a 95       	dec	r24
    6baa:	e2 f7       	brpl	.-8      	; 0x6ba4 <DIO_READ_PIN+0xd2>
    6bac:	ca 01       	movw	r24, r20
    6bae:	81 70       	andi	r24, 0x01	; 1
    6bb0:	89 83       	std	Y+1, r24	; 0x01
		
		default:
		break;
	}
	
	return VALUE;
    6bb2:	89 81       	ldd	r24, Y+1	; 0x01
}
    6bb4:	0f 90       	pop	r0
    6bb6:	0f 90       	pop	r0
    6bb8:	0f 90       	pop	r0
    6bba:	0f 90       	pop	r0
    6bbc:	0f 90       	pop	r0
    6bbe:	cf 91       	pop	r28
    6bc0:	df 91       	pop	r29
    6bc2:	08 95       	ret

00006bc4 <DIO_READ_PORT>:


uint8  DIO_READ_PORT   (DIO_PORT_ID PORT )

{
    6bc4:	df 93       	push	r29
    6bc6:	cf 93       	push	r28
    6bc8:	00 d0       	rcall	.+0      	; 0x6bca <DIO_READ_PORT+0x6>
    6bca:	00 d0       	rcall	.+0      	; 0x6bcc <DIO_READ_PORT+0x8>
    6bcc:	cd b7       	in	r28, 0x3d	; 61
    6bce:	de b7       	in	r29, 0x3e	; 62
    6bd0:	8a 83       	std	Y+2, r24	; 0x02
	uint8 VALUE;
	
	switch(PORT)
    6bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    6bd4:	28 2f       	mov	r18, r24
    6bd6:	30 e0       	ldi	r19, 0x00	; 0
    6bd8:	3c 83       	std	Y+4, r19	; 0x04
    6bda:	2b 83       	std	Y+3, r18	; 0x03
    6bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    6bde:	9c 81       	ldd	r25, Y+4	; 0x04
    6be0:	81 30       	cpi	r24, 0x01	; 1
    6be2:	91 05       	cpc	r25, r1
    6be4:	d1 f0       	breq	.+52     	; 0x6c1a <DIO_READ_PORT+0x56>
    6be6:	2b 81       	ldd	r18, Y+3	; 0x03
    6be8:	3c 81       	ldd	r19, Y+4	; 0x04
    6bea:	22 30       	cpi	r18, 0x02	; 2
    6bec:	31 05       	cpc	r19, r1
    6bee:	2c f4       	brge	.+10     	; 0x6bfa <DIO_READ_PORT+0x36>
    6bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    6bf2:	9c 81       	ldd	r25, Y+4	; 0x04
    6bf4:	00 97       	sbiw	r24, 0x00	; 0
    6bf6:	61 f0       	breq	.+24     	; 0x6c10 <DIO_READ_PORT+0x4c>
    6bf8:	1e c0       	rjmp	.+60     	; 0x6c36 <DIO_READ_PORT+0x72>
    6bfa:	2b 81       	ldd	r18, Y+3	; 0x03
    6bfc:	3c 81       	ldd	r19, Y+4	; 0x04
    6bfe:	22 30       	cpi	r18, 0x02	; 2
    6c00:	31 05       	cpc	r19, r1
    6c02:	81 f0       	breq	.+32     	; 0x6c24 <DIO_READ_PORT+0x60>
    6c04:	8b 81       	ldd	r24, Y+3	; 0x03
    6c06:	9c 81       	ldd	r25, Y+4	; 0x04
    6c08:	83 30       	cpi	r24, 0x03	; 3
    6c0a:	91 05       	cpc	r25, r1
    6c0c:	81 f0       	breq	.+32     	; 0x6c2e <DIO_READ_PORT+0x6a>
    6c0e:	13 c0       	rjmp	.+38     	; 0x6c36 <DIO_READ_PORT+0x72>
	{
		case DIO_PORTA:
		
		VALUE = PINA;
    6c10:	e9 e3       	ldi	r30, 0x39	; 57
    6c12:	f0 e0       	ldi	r31, 0x00	; 0
    6c14:	80 81       	ld	r24, Z
    6c16:	89 83       	std	Y+1, r24	; 0x01
    6c18:	0e c0       	rjmp	.+28     	; 0x6c36 <DIO_READ_PORT+0x72>
		
		break;
		
		case DIO_PORTB:
		
		VALUE = PINB;
    6c1a:	e6 e3       	ldi	r30, 0x36	; 54
    6c1c:	f0 e0       	ldi	r31, 0x00	; 0
    6c1e:	80 81       	ld	r24, Z
    6c20:	89 83       	std	Y+1, r24	; 0x01
    6c22:	09 c0       	rjmp	.+18     	; 0x6c36 <DIO_READ_PORT+0x72>
		
		break;
		
		case DIO_PORTC:
		
		VALUE = PINC;
    6c24:	e3 e3       	ldi	r30, 0x33	; 51
    6c26:	f0 e0       	ldi	r31, 0x00	; 0
    6c28:	80 81       	ld	r24, Z
    6c2a:	89 83       	std	Y+1, r24	; 0x01
    6c2c:	04 c0       	rjmp	.+8      	; 0x6c36 <DIO_READ_PORT+0x72>
		
		break;
		
		case DIO_PORTD:
		
		VALUE = PIND;
    6c2e:	e0 e3       	ldi	r30, 0x30	; 48
    6c30:	f0 e0       	ldi	r31, 0x00	; 0
    6c32:	80 81       	ld	r24, Z
    6c34:	89 83       	std	Y+1, r24	; 0x01
		
		default:
		break;
	}
	
	return VALUE;
    6c36:	89 81       	ldd	r24, Y+1	; 0x01
}
    6c38:	0f 90       	pop	r0
    6c3a:	0f 90       	pop	r0
    6c3c:	0f 90       	pop	r0
    6c3e:	0f 90       	pop	r0
    6c40:	cf 91       	pop	r28
    6c42:	df 91       	pop	r29
    6c44:	08 95       	ret

00006c46 <DIO_SET_PULL_UP_RES>:


void DIO_SET_PULL_UP_RES (DIO_PORT_ID PORT, DIO_PIN_ID PIN)

{
    6c46:	df 93       	push	r29
    6c48:	cf 93       	push	r28
    6c4a:	00 d0       	rcall	.+0      	; 0x6c4c <DIO_SET_PULL_UP_RES+0x6>
    6c4c:	00 d0       	rcall	.+0      	; 0x6c4e <DIO_SET_PULL_UP_RES+0x8>
    6c4e:	cd b7       	in	r28, 0x3d	; 61
    6c50:	de b7       	in	r29, 0x3e	; 62
    6c52:	89 83       	std	Y+1, r24	; 0x01
    6c54:	6a 83       	std	Y+2, r22	; 0x02
	switch (PORT)
    6c56:	89 81       	ldd	r24, Y+1	; 0x01
    6c58:	28 2f       	mov	r18, r24
    6c5a:	30 e0       	ldi	r19, 0x00	; 0
    6c5c:	3c 83       	std	Y+4, r19	; 0x04
    6c5e:	2b 83       	std	Y+3, r18	; 0x03
    6c60:	8b 81       	ldd	r24, Y+3	; 0x03
    6c62:	9c 81       	ldd	r25, Y+4	; 0x04
    6c64:	81 30       	cpi	r24, 0x01	; 1
    6c66:	91 05       	cpc	r25, r1
    6c68:	49 f1       	breq	.+82     	; 0x6cbc <DIO_SET_PULL_UP_RES+0x76>
    6c6a:	2b 81       	ldd	r18, Y+3	; 0x03
    6c6c:	3c 81       	ldd	r19, Y+4	; 0x04
    6c6e:	22 30       	cpi	r18, 0x02	; 2
    6c70:	31 05       	cpc	r19, r1
    6c72:	2c f4       	brge	.+10     	; 0x6c7e <DIO_SET_PULL_UP_RES+0x38>
    6c74:	8b 81       	ldd	r24, Y+3	; 0x03
    6c76:	9c 81       	ldd	r25, Y+4	; 0x04
    6c78:	00 97       	sbiw	r24, 0x00	; 0
    6c7a:	61 f0       	breq	.+24     	; 0x6c94 <DIO_SET_PULL_UP_RES+0x4e>
    6c7c:	5a c0       	rjmp	.+180    	; 0x6d32 <DIO_SET_PULL_UP_RES+0xec>
    6c7e:	2b 81       	ldd	r18, Y+3	; 0x03
    6c80:	3c 81       	ldd	r19, Y+4	; 0x04
    6c82:	22 30       	cpi	r18, 0x02	; 2
    6c84:	31 05       	cpc	r19, r1
    6c86:	71 f1       	breq	.+92     	; 0x6ce4 <DIO_SET_PULL_UP_RES+0x9e>
    6c88:	8b 81       	ldd	r24, Y+3	; 0x03
    6c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    6c8c:	83 30       	cpi	r24, 0x03	; 3
    6c8e:	91 05       	cpc	r25, r1
    6c90:	e9 f1       	breq	.+122    	; 0x6d0c <DIO_SET_PULL_UP_RES+0xc6>
    6c92:	4f c0       	rjmp	.+158    	; 0x6d32 <DIO_SET_PULL_UP_RES+0xec>
	{
		
		case DIO_PORTA:
		
		SET_BIT (PORTA , PIN);
    6c94:	ab e3       	ldi	r26, 0x3B	; 59
    6c96:	b0 e0       	ldi	r27, 0x00	; 0
    6c98:	eb e3       	ldi	r30, 0x3B	; 59
    6c9a:	f0 e0       	ldi	r31, 0x00	; 0
    6c9c:	80 81       	ld	r24, Z
    6c9e:	48 2f       	mov	r20, r24
    6ca0:	8a 81       	ldd	r24, Y+2	; 0x02
    6ca2:	28 2f       	mov	r18, r24
    6ca4:	30 e0       	ldi	r19, 0x00	; 0
    6ca6:	81 e0       	ldi	r24, 0x01	; 1
    6ca8:	90 e0       	ldi	r25, 0x00	; 0
    6caa:	02 2e       	mov	r0, r18
    6cac:	02 c0       	rjmp	.+4      	; 0x6cb2 <DIO_SET_PULL_UP_RES+0x6c>
    6cae:	88 0f       	add	r24, r24
    6cb0:	99 1f       	adc	r25, r25
    6cb2:	0a 94       	dec	r0
    6cb4:	e2 f7       	brpl	.-8      	; 0x6cae <DIO_SET_PULL_UP_RES+0x68>
    6cb6:	84 2b       	or	r24, r20
    6cb8:	8c 93       	st	X, r24
    6cba:	3b c0       	rjmp	.+118    	; 0x6d32 <DIO_SET_PULL_UP_RES+0xec>
		
		break;
		
		case DIO_PORTB:
		
		SET_BIT (PORTB , PIN);
    6cbc:	a8 e3       	ldi	r26, 0x38	; 56
    6cbe:	b0 e0       	ldi	r27, 0x00	; 0
    6cc0:	e8 e3       	ldi	r30, 0x38	; 56
    6cc2:	f0 e0       	ldi	r31, 0x00	; 0
    6cc4:	80 81       	ld	r24, Z
    6cc6:	48 2f       	mov	r20, r24
    6cc8:	8a 81       	ldd	r24, Y+2	; 0x02
    6cca:	28 2f       	mov	r18, r24
    6ccc:	30 e0       	ldi	r19, 0x00	; 0
    6cce:	81 e0       	ldi	r24, 0x01	; 1
    6cd0:	90 e0       	ldi	r25, 0x00	; 0
    6cd2:	02 2e       	mov	r0, r18
    6cd4:	02 c0       	rjmp	.+4      	; 0x6cda <DIO_SET_PULL_UP_RES+0x94>
    6cd6:	88 0f       	add	r24, r24
    6cd8:	99 1f       	adc	r25, r25
    6cda:	0a 94       	dec	r0
    6cdc:	e2 f7       	brpl	.-8      	; 0x6cd6 <DIO_SET_PULL_UP_RES+0x90>
    6cde:	84 2b       	or	r24, r20
    6ce0:	8c 93       	st	X, r24
    6ce2:	27 c0       	rjmp	.+78     	; 0x6d32 <DIO_SET_PULL_UP_RES+0xec>
		
		break;
		
		case DIO_PORTC:
		
		SET_BIT (PORTC ,PIN);
    6ce4:	a5 e3       	ldi	r26, 0x35	; 53
    6ce6:	b0 e0       	ldi	r27, 0x00	; 0
    6ce8:	e5 e3       	ldi	r30, 0x35	; 53
    6cea:	f0 e0       	ldi	r31, 0x00	; 0
    6cec:	80 81       	ld	r24, Z
    6cee:	48 2f       	mov	r20, r24
    6cf0:	8a 81       	ldd	r24, Y+2	; 0x02
    6cf2:	28 2f       	mov	r18, r24
    6cf4:	30 e0       	ldi	r19, 0x00	; 0
    6cf6:	81 e0       	ldi	r24, 0x01	; 1
    6cf8:	90 e0       	ldi	r25, 0x00	; 0
    6cfa:	02 2e       	mov	r0, r18
    6cfc:	02 c0       	rjmp	.+4      	; 0x6d02 <DIO_SET_PULL_UP_RES+0xbc>
    6cfe:	88 0f       	add	r24, r24
    6d00:	99 1f       	adc	r25, r25
    6d02:	0a 94       	dec	r0
    6d04:	e2 f7       	brpl	.-8      	; 0x6cfe <DIO_SET_PULL_UP_RES+0xb8>
    6d06:	84 2b       	or	r24, r20
    6d08:	8c 93       	st	X, r24
    6d0a:	13 c0       	rjmp	.+38     	; 0x6d32 <DIO_SET_PULL_UP_RES+0xec>
		
		break;
		
		case DIO_PORTD:
		
		SET_BIT (PORTD , PIN);
    6d0c:	a2 e3       	ldi	r26, 0x32	; 50
    6d0e:	b0 e0       	ldi	r27, 0x00	; 0
    6d10:	e2 e3       	ldi	r30, 0x32	; 50
    6d12:	f0 e0       	ldi	r31, 0x00	; 0
    6d14:	80 81       	ld	r24, Z
    6d16:	48 2f       	mov	r20, r24
    6d18:	8a 81       	ldd	r24, Y+2	; 0x02
    6d1a:	28 2f       	mov	r18, r24
    6d1c:	30 e0       	ldi	r19, 0x00	; 0
    6d1e:	81 e0       	ldi	r24, 0x01	; 1
    6d20:	90 e0       	ldi	r25, 0x00	; 0
    6d22:	02 2e       	mov	r0, r18
    6d24:	02 c0       	rjmp	.+4      	; 0x6d2a <DIO_SET_PULL_UP_RES+0xe4>
    6d26:	88 0f       	add	r24, r24
    6d28:	99 1f       	adc	r25, r25
    6d2a:	0a 94       	dec	r0
    6d2c:	e2 f7       	brpl	.-8      	; 0x6d26 <DIO_SET_PULL_UP_RES+0xe0>
    6d2e:	84 2b       	or	r24, r20
    6d30:	8c 93       	st	X, r24
		break;
		
		default:
		break;
	}
}
    6d32:	0f 90       	pop	r0
    6d34:	0f 90       	pop	r0
    6d36:	0f 90       	pop	r0
    6d38:	0f 90       	pop	r0
    6d3a:	cf 91       	pop	r28
    6d3c:	df 91       	pop	r29
    6d3e:	08 95       	ret

00006d40 <Ultrasonic_init>:
 * 	2. Setup the ICU call back function.
 * 	3. Setup the direction for the trigger pin as output pin through
 * 	the GPIO driver.
 */
void Ultrasonic_init(void)
{
    6d40:	df 93       	push	r29
    6d42:	cf 93       	push	r28
    6d44:	00 d0       	rcall	.+0      	; 0x6d46 <Ultrasonic_init+0x6>
    6d46:	cd b7       	in	r28, 0x3d	; 61
    6d48:	de b7       	in	r29, 0x3e	; 62
	/*Configuration structure for ICU driver with initial conditions*/
	Icu_ConfigType Icu_Config = {F_CPU_8, RISING};
    6d4a:	82 e0       	ldi	r24, 0x02	; 2
    6d4c:	89 83       	std	Y+1, r24	; 0x01
    6d4e:	81 e0       	ldi	r24, 0x01	; 1
    6d50:	8a 83       	std	Y+2, r24	; 0x02

	/*Initialize the ICU driver*/
	Icu_init(&Icu_Config);
    6d52:	ce 01       	movw	r24, r28
    6d54:	01 96       	adiw	r24, 0x01	; 1
    6d56:	0e 94 f8 31 	call	0x63f0	; 0x63f0 <Icu_init>

	/*Setup the ICU call back function pointer to the ICU Driver*/
	Icu_setCallBack(Ultrasonic_edgeProcessing);
    6d5a:	87 eb       	ldi	r24, 0xB7	; 183
    6d5c:	97 e3       	ldi	r25, 0x37	; 55
    6d5e:	0e 94 41 32 	call	0x6482	; 0x6482 <Icu_setCallBack>

	/*Setup the direction for the trigger pin as output*/
	DIO_SET_PIN_DIREC(Trigger_PORT_ID, Trigger_PIN_ID, OUTPUT);
    6d62:	81 e0       	ldi	r24, 0x01	; 1
    6d64:	65 e0       	ldi	r22, 0x05	; 5
    6d66:	41 e0       	ldi	r20, 0x01	; 1
    6d68:	0e 94 e5 32 	call	0x65ca	; 0x65ca <DIO_SET_PIN_DIREC>
}
    6d6c:	0f 90       	pop	r0
    6d6e:	0f 90       	pop	r0
    6d70:	cf 91       	pop	r28
    6d72:	df 91       	pop	r29
    6d74:	08 95       	ret

00006d76 <Ultrasonic_Trigger>:
/*
 * Description:
 * Send the Trigger Pulse to the Ultrasonic using the GPIO Driver.
 */
void Ultrasonic_Trigger(void)
{
    6d76:	df 93       	push	r29
    6d78:	cf 93       	push	r28
    6d7a:	cd b7       	in	r28, 0x3d	; 61
    6d7c:	de b7       	in	r29, 0x3e	; 62
    6d7e:	68 97       	sbiw	r28, 0x18	; 24
    6d80:	0f b6       	in	r0, 0x3f	; 63
    6d82:	f8 94       	cli
    6d84:	de bf       	out	0x3e, r29	; 62
    6d86:	0f be       	out	0x3f, r0	; 63
    6d88:	cd bf       	out	0x3d, r28	; 61
	/*Send the pulse by writing '1' to the trigger's pin*/
	DIO_SET_PIN_VALUE(Trigger_PORT_ID, Trigger_PIN_ID, STD_HIGH);
    6d8a:	81 e0       	ldi	r24, 0x01	; 1
    6d8c:	65 e0       	ldi	r22, 0x05	; 5
    6d8e:	41 e0       	ldi	r20, 0x01	; 1
    6d90:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
    6d94:	80 e0       	ldi	r24, 0x00	; 0
    6d96:	90 e0       	ldi	r25, 0x00	; 0
    6d98:	a0 e2       	ldi	r26, 0x20	; 32
    6d9a:	b1 e4       	ldi	r27, 0x41	; 65
    6d9c:	8d 8b       	std	Y+21, r24	; 0x15
    6d9e:	9e 8b       	std	Y+22, r25	; 0x16
    6da0:	af 8b       	std	Y+23, r26	; 0x17
    6da2:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6da4:	6d 89       	ldd	r22, Y+21	; 0x15
    6da6:	7e 89       	ldd	r23, Y+22	; 0x16
    6da8:	8f 89       	ldd	r24, Y+23	; 0x17
    6daa:	98 8d       	ldd	r25, Y+24	; 0x18
    6dac:	2b ea       	ldi	r18, 0xAB	; 171
    6dae:	3a ea       	ldi	r19, 0xAA	; 170
    6db0:	4a e2       	ldi	r20, 0x2A	; 42
    6db2:	50 e4       	ldi	r21, 0x40	; 64
    6db4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6db8:	dc 01       	movw	r26, r24
    6dba:	cb 01       	movw	r24, r22
    6dbc:	89 8b       	std	Y+17, r24	; 0x11
    6dbe:	9a 8b       	std	Y+18, r25	; 0x12
    6dc0:	ab 8b       	std	Y+19, r26	; 0x13
    6dc2:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    6dc4:	69 89       	ldd	r22, Y+17	; 0x11
    6dc6:	7a 89       	ldd	r23, Y+18	; 0x12
    6dc8:	8b 89       	ldd	r24, Y+19	; 0x13
    6dca:	9c 89       	ldd	r25, Y+20	; 0x14
    6dcc:	20 e0       	ldi	r18, 0x00	; 0
    6dce:	30 e0       	ldi	r19, 0x00	; 0
    6dd0:	40 e8       	ldi	r20, 0x80	; 128
    6dd2:	5f e3       	ldi	r21, 0x3F	; 63
    6dd4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6dd8:	88 23       	and	r24, r24
    6dda:	1c f4       	brge	.+6      	; 0x6de2 <Ultrasonic_Trigger+0x6c>
		__ticks = 1;
    6ddc:	81 e0       	ldi	r24, 0x01	; 1
    6dde:	88 8b       	std	Y+16, r24	; 0x10
    6de0:	91 c0       	rjmp	.+290    	; 0x6f04 <Ultrasonic_Trigger+0x18e>
	else if (__tmp > 255)
    6de2:	69 89       	ldd	r22, Y+17	; 0x11
    6de4:	7a 89       	ldd	r23, Y+18	; 0x12
    6de6:	8b 89       	ldd	r24, Y+19	; 0x13
    6de8:	9c 89       	ldd	r25, Y+20	; 0x14
    6dea:	20 e0       	ldi	r18, 0x00	; 0
    6dec:	30 e0       	ldi	r19, 0x00	; 0
    6dee:	4f e7       	ldi	r20, 0x7F	; 127
    6df0:	53 e4       	ldi	r21, 0x43	; 67
    6df2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6df6:	18 16       	cp	r1, r24
    6df8:	0c f0       	brlt	.+2      	; 0x6dfc <Ultrasonic_Trigger+0x86>
    6dfa:	7b c0       	rjmp	.+246    	; 0x6ef2 <Ultrasonic_Trigger+0x17c>
	{
		_delay_ms(__us / 1000.0);
    6dfc:	6d 89       	ldd	r22, Y+21	; 0x15
    6dfe:	7e 89       	ldd	r23, Y+22	; 0x16
    6e00:	8f 89       	ldd	r24, Y+23	; 0x17
    6e02:	98 8d       	ldd	r25, Y+24	; 0x18
    6e04:	20 e0       	ldi	r18, 0x00	; 0
    6e06:	30 e0       	ldi	r19, 0x00	; 0
    6e08:	4a e7       	ldi	r20, 0x7A	; 122
    6e0a:	54 e4       	ldi	r21, 0x44	; 68
    6e0c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    6e10:	dc 01       	movw	r26, r24
    6e12:	cb 01       	movw	r24, r22
    6e14:	8c 87       	std	Y+12, r24	; 0x0c
    6e16:	9d 87       	std	Y+13, r25	; 0x0d
    6e18:	ae 87       	std	Y+14, r26	; 0x0e
    6e1a:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6e1c:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e1e:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e20:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e22:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e24:	20 e0       	ldi	r18, 0x00	; 0
    6e26:	30 e0       	ldi	r19, 0x00	; 0
    6e28:	4a ef       	ldi	r20, 0xFA	; 250
    6e2a:	54 e4       	ldi	r21, 0x44	; 68
    6e2c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6e30:	dc 01       	movw	r26, r24
    6e32:	cb 01       	movw	r24, r22
    6e34:	88 87       	std	Y+8, r24	; 0x08
    6e36:	99 87       	std	Y+9, r25	; 0x09
    6e38:	aa 87       	std	Y+10, r26	; 0x0a
    6e3a:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    6e3c:	68 85       	ldd	r22, Y+8	; 0x08
    6e3e:	79 85       	ldd	r23, Y+9	; 0x09
    6e40:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e42:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e44:	20 e0       	ldi	r18, 0x00	; 0
    6e46:	30 e0       	ldi	r19, 0x00	; 0
    6e48:	40 e8       	ldi	r20, 0x80	; 128
    6e4a:	5f e3       	ldi	r21, 0x3F	; 63
    6e4c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6e50:	88 23       	and	r24, r24
    6e52:	2c f4       	brge	.+10     	; 0x6e5e <Ultrasonic_Trigger+0xe8>
		__ticks = 1;
    6e54:	81 e0       	ldi	r24, 0x01	; 1
    6e56:	90 e0       	ldi	r25, 0x00	; 0
    6e58:	9f 83       	std	Y+7, r25	; 0x07
    6e5a:	8e 83       	std	Y+6, r24	; 0x06
    6e5c:	3f c0       	rjmp	.+126    	; 0x6edc <Ultrasonic_Trigger+0x166>
	else if (__tmp > 65535)
    6e5e:	68 85       	ldd	r22, Y+8	; 0x08
    6e60:	79 85       	ldd	r23, Y+9	; 0x09
    6e62:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e64:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e66:	20 e0       	ldi	r18, 0x00	; 0
    6e68:	3f ef       	ldi	r19, 0xFF	; 255
    6e6a:	4f e7       	ldi	r20, 0x7F	; 127
    6e6c:	57 e4       	ldi	r21, 0x47	; 71
    6e6e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6e72:	18 16       	cp	r1, r24
    6e74:	4c f5       	brge	.+82     	; 0x6ec8 <Ultrasonic_Trigger+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e76:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e78:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e7a:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e7c:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e7e:	20 e0       	ldi	r18, 0x00	; 0
    6e80:	30 e0       	ldi	r19, 0x00	; 0
    6e82:	40 e2       	ldi	r20, 0x20	; 32
    6e84:	51 e4       	ldi	r21, 0x41	; 65
    6e86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6e8a:	dc 01       	movw	r26, r24
    6e8c:	cb 01       	movw	r24, r22
    6e8e:	bc 01       	movw	r22, r24
    6e90:	cd 01       	movw	r24, r26
    6e92:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6e96:	dc 01       	movw	r26, r24
    6e98:	cb 01       	movw	r24, r22
    6e9a:	9f 83       	std	Y+7, r25	; 0x07
    6e9c:	8e 83       	std	Y+6, r24	; 0x06
    6e9e:	0f c0       	rjmp	.+30     	; 0x6ebe <Ultrasonic_Trigger+0x148>
    6ea0:	88 ec       	ldi	r24, 0xC8	; 200
    6ea2:	90 e0       	ldi	r25, 0x00	; 0
    6ea4:	9d 83       	std	Y+5, r25	; 0x05
    6ea6:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6ea8:	8c 81       	ldd	r24, Y+4	; 0x04
    6eaa:	9d 81       	ldd	r25, Y+5	; 0x05
    6eac:	01 97       	sbiw	r24, 0x01	; 1
    6eae:	f1 f7       	brne	.-4      	; 0x6eac <Ultrasonic_Trigger+0x136>
    6eb0:	9d 83       	std	Y+5, r25	; 0x05
    6eb2:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6eb4:	8e 81       	ldd	r24, Y+6	; 0x06
    6eb6:	9f 81       	ldd	r25, Y+7	; 0x07
    6eb8:	01 97       	sbiw	r24, 0x01	; 1
    6eba:	9f 83       	std	Y+7, r25	; 0x07
    6ebc:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6ebe:	8e 81       	ldd	r24, Y+6	; 0x06
    6ec0:	9f 81       	ldd	r25, Y+7	; 0x07
    6ec2:	00 97       	sbiw	r24, 0x00	; 0
    6ec4:	69 f7       	brne	.-38     	; 0x6ea0 <Ultrasonic_Trigger+0x12a>
    6ec6:	24 c0       	rjmp	.+72     	; 0x6f10 <Ultrasonic_Trigger+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6ec8:	68 85       	ldd	r22, Y+8	; 0x08
    6eca:	79 85       	ldd	r23, Y+9	; 0x09
    6ecc:	8a 85       	ldd	r24, Y+10	; 0x0a
    6ece:	9b 85       	ldd	r25, Y+11	; 0x0b
    6ed0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6ed4:	dc 01       	movw	r26, r24
    6ed6:	cb 01       	movw	r24, r22
    6ed8:	9f 83       	std	Y+7, r25	; 0x07
    6eda:	8e 83       	std	Y+6, r24	; 0x06
    6edc:	8e 81       	ldd	r24, Y+6	; 0x06
    6ede:	9f 81       	ldd	r25, Y+7	; 0x07
    6ee0:	9b 83       	std	Y+3, r25	; 0x03
    6ee2:	8a 83       	std	Y+2, r24	; 0x02
    6ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    6ee6:	9b 81       	ldd	r25, Y+3	; 0x03
    6ee8:	01 97       	sbiw	r24, 0x01	; 1
    6eea:	f1 f7       	brne	.-4      	; 0x6ee8 <Ultrasonic_Trigger+0x172>
    6eec:	9b 83       	std	Y+3, r25	; 0x03
    6eee:	8a 83       	std	Y+2, r24	; 0x02
    6ef0:	0f c0       	rjmp	.+30     	; 0x6f10 <Ultrasonic_Trigger+0x19a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6ef2:	69 89       	ldd	r22, Y+17	; 0x11
    6ef4:	7a 89       	ldd	r23, Y+18	; 0x12
    6ef6:	8b 89       	ldd	r24, Y+19	; 0x13
    6ef8:	9c 89       	ldd	r25, Y+20	; 0x14
    6efa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6efe:	dc 01       	movw	r26, r24
    6f00:	cb 01       	movw	r24, r22
    6f02:	88 8b       	std	Y+16, r24	; 0x10
    6f04:	88 89       	ldd	r24, Y+16	; 0x10
    6f06:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6f08:	89 81       	ldd	r24, Y+1	; 0x01
    6f0a:	8a 95       	dec	r24
    6f0c:	f1 f7       	brne	.-4      	; 0x6f0a <Ultrasonic_Trigger+0x194>
    6f0e:	89 83       	std	Y+1, r24	; 0x01

	/*Small delay between writing and clearing the trigger's pin*/
	_delay_us(10);

	/*Clear the trigger's pin by writing '0' after sending the pulse*/
	DIO_SET_PIN_VALUE(Trigger_PORT_ID, Trigger_PIN_ID, STD_LOW);
    6f10:	81 e0       	ldi	r24, 0x01	; 1
    6f12:	65 e0       	ldi	r22, 0x05	; 5
    6f14:	40 e0       	ldi	r20, 0x00	; 0
    6f16:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
}
    6f1a:	68 96       	adiw	r28, 0x18	; 24
    6f1c:	0f b6       	in	r0, 0x3f	; 63
    6f1e:	f8 94       	cli
    6f20:	de bf       	out	0x3e, r29	; 62
    6f22:	0f be       	out	0x3f, r0	; 63
    6f24:	cd bf       	out	0x3d, r28	; 61
    6f26:	cf 91       	pop	r28
    6f28:	df 91       	pop	r29
    6f2a:	08 95       	ret

00006f2c <Ultrasonic_readDistance>:
 * Description:
 * 1. Send the Trigger Pulse by using Ultrasonic_Trigger function.
 * 2. Start the measurements by the ICU from this moment.
 */
uint16 Ultrasonic_readDistance(void)
{
    6f2c:	df 93       	push	r29
    6f2e:	cf 93       	push	r28
    6f30:	00 d0       	rcall	.+0      	; 0x6f32 <Ultrasonic_readDistance+0x6>
    6f32:	cd b7       	in	r28, 0x3d	; 61
    6f34:	de b7       	in	r29, 0x3e	; 62
	uint16 distance_cm;

	/*Send the Trigger Pulse*/
	Ultrasonic_Trigger();
    6f36:	0e 94 bb 36 	call	0x6d76	; 0x6d76 <Ultrasonic_Trigger>

	/*Start the measurements by the ICU*/

	/*Calculate the distance in cm*/
	distance_cm = ((g_timeHigh / 58)+1);
    6f3a:	80 91 af 06 	lds	r24, 0x06AF
    6f3e:	90 91 b0 06 	lds	r25, 0x06B0
    6f42:	2a e3       	ldi	r18, 0x3A	; 58
    6f44:	30 e0       	ldi	r19, 0x00	; 0
    6f46:	b9 01       	movw	r22, r18
    6f48:	0e 94 73 3d 	call	0x7ae6	; 0x7ae6 <__udivmodhi4>
    6f4c:	cb 01       	movw	r24, r22
    6f4e:	01 96       	adiw	r24, 0x01	; 1
    6f50:	9a 83       	std	Y+2, r25	; 0x02
    6f52:	89 83       	std	Y+1, r24	; 0x01

	if (2 == g_edgeCount)
    6f54:	80 91 ae 06 	lds	r24, 0x06AE
    6f58:	82 30       	cpi	r24, 0x02	; 2
    6f5a:	11 f4       	brne	.+4      	; 0x6f60 <Ultrasonic_readDistance+0x34>
	{
		/*Clear the edges counter to repeat the process*/
		g_edgeCount = 0;
    6f5c:	10 92 ae 06 	sts	0x06AE, r1
	}

	return distance_cm;
    6f60:	89 81       	ldd	r24, Y+1	; 0x01
    6f62:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6f64:	0f 90       	pop	r0
    6f66:	0f 90       	pop	r0
    6f68:	cf 91       	pop	r28
    6f6a:	df 91       	pop	r29
    6f6c:	08 95       	ret

00006f6e <Ultrasonic_edgeProcessing>:
 *    is sent to the Icu_setCallBack function using Ultrasonic_init function.
 * 2. This function is used to calculate the high time (pulse time)
 *    generated by the Ultrasonic sensor.
 */
void Ultrasonic_edgeProcessing(void)
{
    6f6e:	df 93       	push	r29
    6f70:	cf 93       	push	r28
    6f72:	cd b7       	in	r28, 0x3d	; 61
    6f74:	de b7       	in	r29, 0x3e	; 62
	g_edgeCount++;
    6f76:	80 91 ae 06 	lds	r24, 0x06AE
    6f7a:	8f 5f       	subi	r24, 0xFF	; 255
    6f7c:	80 93 ae 06 	sts	0x06AE, r24
	if (1 == g_edgeCount)
    6f80:	80 91 ae 06 	lds	r24, 0x06AE
    6f84:	81 30       	cpi	r24, 0x01	; 1
    6f86:	31 f4       	brne	.+12     	; 0x6f94 <Ultrasonic_edgeProcessing+0x26>
	{
		/*Clear the timer counter register to start measurements from the first
		 * detected rising edge.
		 */
		Icu_clearTimerValue();
    6f88:	0e 94 7d 32 	call	0x64fa	; 0x64fa <Icu_clearTimerValue>

		/*Set the ICU to detect the falling edge*/
		Icu_setEdgeDetectionType(FALLING);
    6f8c:	80 e0       	ldi	r24, 0x00	; 0
    6f8e:	0e 94 53 32 	call	0x64a6	; 0x64a6 <Icu_setEdgeDetectionType>
    6f92:	0f c0       	rjmp	.+30     	; 0x6fb2 <Ultrasonic_edgeProcessing+0x44>
	}
	else if (2 == g_edgeCount)
    6f94:	80 91 ae 06 	lds	r24, 0x06AE
    6f98:	82 30       	cpi	r24, 0x02	; 2
    6f9a:	59 f4       	brne	.+22     	; 0x6fb2 <Ultrasonic_edgeProcessing+0x44>
	{
		/*Store the high time value*/
		g_timeHigh = Icu_getInputCaptureValue();
    6f9c:	0e 94 72 32 	call	0x64e4	; 0x64e4 <Icu_getInputCaptureValue>
    6fa0:	90 93 b0 06 	sts	0x06B0, r25
    6fa4:	80 93 af 06 	sts	0x06AF, r24

		/*Detect the rising edge*/
		Icu_setEdgeDetectionType(RISING);
    6fa8:	81 e0       	ldi	r24, 0x01	; 1
    6faa:	0e 94 53 32 	call	0x64a6	; 0x64a6 <Icu_setEdgeDetectionType>

		/*Clear the timer counter register to start measurements again*/
		Icu_clearTimerValue();
    6fae:	0e 94 7d 32 	call	0x64fa	; 0x64fa <Icu_clearTimerValue>
	}
}
    6fb2:	cf 91       	pop	r28
    6fb4:	df 91       	pop	r29
    6fb6:	08 95       	ret

00006fb8 <SERVO_u8Rotate>:
#include "../HEADER/SERVO_PROTO_TYPES.h"



uint8 SERVO_u8Rotate(uint8 Copy_u8Channel , uint8 Copy_u8Angle)
{
    6fb8:	df 93       	push	r29
    6fba:	cf 93       	push	r28
    6fbc:	cd b7       	in	r28, 0x3d	; 61
    6fbe:	de b7       	in	r29, 0x3e	; 62
    6fc0:	29 97       	sbiw	r28, 0x09	; 9
    6fc2:	0f b6       	in	r0, 0x3f	; 63
    6fc4:	f8 94       	cli
    6fc6:	de bf       	out	0x3e, r29	; 62
    6fc8:	0f be       	out	0x3f, r0	; 63
    6fca:	cd bf       	out	0x3d, r28	; 61
    6fcc:	8e 83       	std	Y+6, r24	; 0x06
    6fce:	6f 83       	std	Y+7, r22	; 0x07
	/*local variable for error checking*/
	uint8 Local_u8ErrorState = OK ;
    6fd0:	1d 82       	std	Y+5, r1	; 0x05

	/*local variable for value of OCR register to get target angle*/
	if (Copy_u8Angle > 180 )
    6fd2:	8f 81       	ldd	r24, Y+7	; 0x07
    6fd4:	85 3b       	cpi	r24, 0xB5	; 181
    6fd6:	10 f0       	brcs	.+4      	; 0x6fdc <SERVO_u8Rotate+0x24>
	{
		Copy_u8Angle=180;
    6fd8:	84 eb       	ldi	r24, 0xB4	; 180
    6fda:	8f 83       	std	Y+7, r24	; 0x07
	}
	uint32 Local_u16MappedAngle = (((uint32)Copy_u8Angle * 1000) /(uint32)180)  + 999 ;
    6fdc:	8f 81       	ldd	r24, Y+7	; 0x07
    6fde:	88 2f       	mov	r24, r24
    6fe0:	90 e0       	ldi	r25, 0x00	; 0
    6fe2:	a0 e0       	ldi	r26, 0x00	; 0
    6fe4:	b0 e0       	ldi	r27, 0x00	; 0
    6fe6:	28 ee       	ldi	r18, 0xE8	; 232
    6fe8:	33 e0       	ldi	r19, 0x03	; 3
    6fea:	40 e0       	ldi	r20, 0x00	; 0
    6fec:	50 e0       	ldi	r21, 0x00	; 0
    6fee:	bc 01       	movw	r22, r24
    6ff0:	cd 01       	movw	r24, r26
    6ff2:	0e 94 54 3d 	call	0x7aa8	; 0x7aa8 <__mulsi3>
    6ff6:	dc 01       	movw	r26, r24
    6ff8:	cb 01       	movw	r24, r22
    6ffa:	24 eb       	ldi	r18, 0xB4	; 180
    6ffc:	30 e0       	ldi	r19, 0x00	; 0
    6ffe:	40 e0       	ldi	r20, 0x00	; 0
    7000:	50 e0       	ldi	r21, 0x00	; 0
    7002:	bc 01       	movw	r22, r24
    7004:	cd 01       	movw	r24, r26
    7006:	0e 94 87 3d 	call	0x7b0e	; 0x7b0e <__udivmodsi4>
    700a:	da 01       	movw	r26, r20
    700c:	c9 01       	movw	r24, r18
    700e:	89 51       	subi	r24, 0x19	; 25
    7010:	9c 4f       	sbci	r25, 0xFC	; 252
    7012:	af 4f       	sbci	r26, 0xFF	; 255
    7014:	bf 4f       	sbci	r27, 0xFF	; 255
    7016:	89 83       	std	Y+1, r24	; 0x01
    7018:	9a 83       	std	Y+2, r25	; 0x02
    701a:	ab 83       	std	Y+3, r26	; 0x03
    701c:	bc 83       	std	Y+4, r27	; 0x04


	/*checking for valid range of rotation angle*/
	if(Copy_u8Angle>=0 && Copy_u8Angle<=180)
    701e:	8f 81       	ldd	r24, Y+7	; 0x07
    7020:	85 3b       	cpi	r24, 0xB5	; 181
    7022:	10 f5       	brcc	.+68     	; 0x7068 <SERVO_u8Rotate+0xb0>
	{
		switch(Copy_u8Channel)
    7024:	8e 81       	ldd	r24, Y+6	; 0x06
    7026:	28 2f       	mov	r18, r24
    7028:	30 e0       	ldi	r19, 0x00	; 0
    702a:	39 87       	std	Y+9, r19	; 0x09
    702c:	28 87       	std	Y+8, r18	; 0x08
    702e:	88 85       	ldd	r24, Y+8	; 0x08
    7030:	99 85       	ldd	r25, Y+9	; 0x09
    7032:	81 30       	cpi	r24, 0x01	; 1
    7034:	91 05       	cpc	r25, r1
    7036:	31 f0       	breq	.+12     	; 0x7044 <SERVO_u8Rotate+0x8c>
    7038:	28 85       	ldd	r18, Y+8	; 0x08
    703a:	39 85       	ldd	r19, Y+9	; 0x09
    703c:	22 30       	cpi	r18, 0x02	; 2
    703e:	31 05       	cpc	r19, r1
    7040:	51 f0       	breq	.+20     	; 0x7056 <SERVO_u8Rotate+0x9e>
    7042:	14 c0       	rjmp	.+40     	; 0x706c <SERVO_u8Rotate+0xb4>
		{
		case CHANNEL_A :
			PWM_u8Init(CHANNEL_A , FREQUENCY_50 , Local_u16MappedAngle);
    7044:	29 81       	ldd	r18, Y+1	; 0x01
    7046:	3a 81       	ldd	r19, Y+2	; 0x02
    7048:	81 e0       	ldi	r24, 0x01	; 1
    704a:	60 e2       	ldi	r22, 0x20	; 32
    704c:	7e e4       	ldi	r23, 0x4E	; 78
    704e:	a9 01       	movw	r20, r18
    7050:	0e 94 19 31 	call	0x6232	; 0x6232 <PWM_u8Init>
    7054:	0b c0       	rjmp	.+22     	; 0x706c <SERVO_u8Rotate+0xb4>
			break ;

		case CHANNEL_B :
			PWM_u8Init(CHANNEL_B , FREQUENCY_50 , Local_u16MappedAngle);
    7056:	29 81       	ldd	r18, Y+1	; 0x01
    7058:	3a 81       	ldd	r19, Y+2	; 0x02
    705a:	82 e0       	ldi	r24, 0x02	; 2
    705c:	60 e2       	ldi	r22, 0x20	; 32
    705e:	7e e4       	ldi	r23, 0x4E	; 78
    7060:	a9 01       	movw	r20, r18
    7062:	0e 94 19 31 	call	0x6232	; 0x6232 <PWM_u8Init>
    7066:	02 c0       	rjmp	.+4      	; 0x706c <SERVO_u8Rotate+0xb4>
	}

	/*in case of input angle out of possible range*/
	else
	{
		Local_u8ErrorState = OUT_OF_RANGE ;
    7068:	83 e0       	ldi	r24, 0x03	; 3
    706a:	8d 83       	std	Y+5, r24	; 0x05
	}

	/*return from this function*/
	return Local_u8ErrorState ;
    706c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    706e:	29 96       	adiw	r28, 0x09	; 9
    7070:	0f b6       	in	r0, 0x3f	; 63
    7072:	f8 94       	cli
    7074:	de bf       	out	0x3e, r29	; 62
    7076:	0f be       	out	0x3f, r0	; 63
    7078:	cd bf       	out	0x3d, r28	; 61
    707a:	cf 91       	pop	r28
    707c:	df 91       	pop	r29
    707e:	08 95       	ret

00007080 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    7080:	df 93       	push	r29
    7082:	cf 93       	push	r28
    7084:	cd b7       	in	r28, 0x3d	; 61
    7086:	de b7       	in	r29, 0x3e	; 62
	/* Configure the direction for RS, RW and E pins as output pins */
	DIO_SET_PIN_DIREC(LCD_RS_PORT_ID,LCD_RS_PIN_ID,OUTPUT);
    7088:	81 e0       	ldi	r24, 0x01	; 1
    708a:	60 e0       	ldi	r22, 0x00	; 0
    708c:	41 e0       	ldi	r20, 0x01	; 1
    708e:	0e 94 e5 32 	call	0x65ca	; 0x65ca <DIO_SET_PIN_DIREC>
	DIO_SET_PIN_DIREC(LCD_RW_PORT_ID,LCD_RW_PIN_ID,OUTPUT);
    7092:	81 e0       	ldi	r24, 0x01	; 1
    7094:	61 e0       	ldi	r22, 0x01	; 1
    7096:	41 e0       	ldi	r20, 0x01	; 1
    7098:	0e 94 e5 32 	call	0x65ca	; 0x65ca <DIO_SET_PIN_DIREC>
	DIO_SET_PIN_DIREC(LCD_E_PORT_ID,LCD_E_PIN_ID,OUTPUT);
    709c:	81 e0       	ldi	r24, 0x01	; 1
    709e:	62 e0       	ldi	r22, 0x02	; 2
    70a0:	41 e0       	ldi	r20, 0x01	; 1
    70a2:	0e 94 e5 32 	call	0x65ca	; 0x65ca <DIO_SET_PIN_DIREC>

	/* Configure the data port as output port */
	DIO_SET_PORT_DIREC(LCD_DATA_PORT_ID,OUTPUT);
    70a6:	80 e0       	ldi	r24, 0x00	; 0
    70a8:	61 e0       	ldi	r22, 0x01	; 1
    70aa:	0e 94 a4 32 	call	0x6548	; 0x6548 <DIO_SET_PORT_DIREC>

	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
    70ae:	88 e3       	ldi	r24, 0x38	; 56
    70b0:	0e 94 63 38 	call	0x70c6	; 0x70c6 <LCD_sendCommand>
	
	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    70b4:	8c e0       	ldi	r24, 0x0C	; 12
    70b6:	0e 94 63 38 	call	0x70c6	; 0x70c6 <LCD_sendCommand>
	
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	0e 94 63 38 	call	0x70c6	; 0x70c6 <LCD_sendCommand>
}
    70c0:	cf 91       	pop	r28
    70c2:	df 91       	pop	r29
    70c4:	08 95       	ret

000070c6 <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
    70c6:	df 93       	push	r29
    70c8:	cf 93       	push	r28
    70ca:	cd b7       	in	r28, 0x3d	; 61
    70cc:	de b7       	in	r29, 0x3e	; 62
    70ce:	e9 97       	sbiw	r28, 0x39	; 57
    70d0:	0f b6       	in	r0, 0x3f	; 63
    70d2:	f8 94       	cli
    70d4:	de bf       	out	0x3e, r29	; 62
    70d6:	0f be       	out	0x3f, r0	; 63
    70d8:	cd bf       	out	0x3d, r28	; 61
    70da:	89 af       	std	Y+57, r24	; 0x39
	DIO_SET_PIN_VALUE(LCD_RS_PORT_ID,LCD_RS_PIN_ID,STD_LOW); /* Instruction Mode RS=0 */
    70dc:	81 e0       	ldi	r24, 0x01	; 1
    70de:	60 e0       	ldi	r22, 0x00	; 0
    70e0:	40 e0       	ldi	r20, 0x00	; 0
    70e2:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
	DIO_SET_PIN_VALUE(LCD_RW_PORT_ID,LCD_RW_PIN_ID,STD_LOW); /* write data to LCD so RW=0 */
    70e6:	81 e0       	ldi	r24, 0x01	; 1
    70e8:	61 e0       	ldi	r22, 0x01	; 1
    70ea:	40 e0       	ldi	r20, 0x00	; 0
    70ec:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
    70f0:	80 e0       	ldi	r24, 0x00	; 0
    70f2:	90 e0       	ldi	r25, 0x00	; 0
    70f4:	a0 e8       	ldi	r26, 0x80	; 128
    70f6:	bf e3       	ldi	r27, 0x3F	; 63
    70f8:	8d ab       	std	Y+53, r24	; 0x35
    70fa:	9e ab       	std	Y+54, r25	; 0x36
    70fc:	af ab       	std	Y+55, r26	; 0x37
    70fe:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7100:	6d a9       	ldd	r22, Y+53	; 0x35
    7102:	7e a9       	ldd	r23, Y+54	; 0x36
    7104:	8f a9       	ldd	r24, Y+55	; 0x37
    7106:	98 ad       	ldd	r25, Y+56	; 0x38
    7108:	20 e0       	ldi	r18, 0x00	; 0
    710a:	30 e0       	ldi	r19, 0x00	; 0
    710c:	4a ef       	ldi	r20, 0xFA	; 250
    710e:	54 e4       	ldi	r21, 0x44	; 68
    7110:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7114:	dc 01       	movw	r26, r24
    7116:	cb 01       	movw	r24, r22
    7118:	89 ab       	std	Y+49, r24	; 0x31
    711a:	9a ab       	std	Y+50, r25	; 0x32
    711c:	ab ab       	std	Y+51, r26	; 0x33
    711e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    7120:	69 a9       	ldd	r22, Y+49	; 0x31
    7122:	7a a9       	ldd	r23, Y+50	; 0x32
    7124:	8b a9       	ldd	r24, Y+51	; 0x33
    7126:	9c a9       	ldd	r25, Y+52	; 0x34
    7128:	20 e0       	ldi	r18, 0x00	; 0
    712a:	30 e0       	ldi	r19, 0x00	; 0
    712c:	40 e8       	ldi	r20, 0x80	; 128
    712e:	5f e3       	ldi	r21, 0x3F	; 63
    7130:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7134:	88 23       	and	r24, r24
    7136:	2c f4       	brge	.+10     	; 0x7142 <LCD_sendCommand+0x7c>
		__ticks = 1;
    7138:	81 e0       	ldi	r24, 0x01	; 1
    713a:	90 e0       	ldi	r25, 0x00	; 0
    713c:	98 ab       	std	Y+48, r25	; 0x30
    713e:	8f a7       	std	Y+47, r24	; 0x2f
    7140:	3f c0       	rjmp	.+126    	; 0x71c0 <LCD_sendCommand+0xfa>
	else if (__tmp > 65535)
    7142:	69 a9       	ldd	r22, Y+49	; 0x31
    7144:	7a a9       	ldd	r23, Y+50	; 0x32
    7146:	8b a9       	ldd	r24, Y+51	; 0x33
    7148:	9c a9       	ldd	r25, Y+52	; 0x34
    714a:	20 e0       	ldi	r18, 0x00	; 0
    714c:	3f ef       	ldi	r19, 0xFF	; 255
    714e:	4f e7       	ldi	r20, 0x7F	; 127
    7150:	57 e4       	ldi	r21, 0x47	; 71
    7152:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7156:	18 16       	cp	r1, r24
    7158:	4c f5       	brge	.+82     	; 0x71ac <LCD_sendCommand+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    715a:	6d a9       	ldd	r22, Y+53	; 0x35
    715c:	7e a9       	ldd	r23, Y+54	; 0x36
    715e:	8f a9       	ldd	r24, Y+55	; 0x37
    7160:	98 ad       	ldd	r25, Y+56	; 0x38
    7162:	20 e0       	ldi	r18, 0x00	; 0
    7164:	30 e0       	ldi	r19, 0x00	; 0
    7166:	40 e2       	ldi	r20, 0x20	; 32
    7168:	51 e4       	ldi	r21, 0x41	; 65
    716a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    716e:	dc 01       	movw	r26, r24
    7170:	cb 01       	movw	r24, r22
    7172:	bc 01       	movw	r22, r24
    7174:	cd 01       	movw	r24, r26
    7176:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    717a:	dc 01       	movw	r26, r24
    717c:	cb 01       	movw	r24, r22
    717e:	98 ab       	std	Y+48, r25	; 0x30
    7180:	8f a7       	std	Y+47, r24	; 0x2f
    7182:	0f c0       	rjmp	.+30     	; 0x71a2 <LCD_sendCommand+0xdc>
    7184:	88 ec       	ldi	r24, 0xC8	; 200
    7186:	90 e0       	ldi	r25, 0x00	; 0
    7188:	9e a7       	std	Y+46, r25	; 0x2e
    718a:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    718c:	8d a5       	ldd	r24, Y+45	; 0x2d
    718e:	9e a5       	ldd	r25, Y+46	; 0x2e
    7190:	01 97       	sbiw	r24, 0x01	; 1
    7192:	f1 f7       	brne	.-4      	; 0x7190 <LCD_sendCommand+0xca>
    7194:	9e a7       	std	Y+46, r25	; 0x2e
    7196:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7198:	8f a5       	ldd	r24, Y+47	; 0x2f
    719a:	98 a9       	ldd	r25, Y+48	; 0x30
    719c:	01 97       	sbiw	r24, 0x01	; 1
    719e:	98 ab       	std	Y+48, r25	; 0x30
    71a0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    71a2:	8f a5       	ldd	r24, Y+47	; 0x2f
    71a4:	98 a9       	ldd	r25, Y+48	; 0x30
    71a6:	00 97       	sbiw	r24, 0x00	; 0
    71a8:	69 f7       	brne	.-38     	; 0x7184 <LCD_sendCommand+0xbe>
    71aa:	14 c0       	rjmp	.+40     	; 0x71d4 <LCD_sendCommand+0x10e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    71ac:	69 a9       	ldd	r22, Y+49	; 0x31
    71ae:	7a a9       	ldd	r23, Y+50	; 0x32
    71b0:	8b a9       	ldd	r24, Y+51	; 0x33
    71b2:	9c a9       	ldd	r25, Y+52	; 0x34
    71b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    71b8:	dc 01       	movw	r26, r24
    71ba:	cb 01       	movw	r24, r22
    71bc:	98 ab       	std	Y+48, r25	; 0x30
    71be:	8f a7       	std	Y+47, r24	; 0x2f
    71c0:	8f a5       	ldd	r24, Y+47	; 0x2f
    71c2:	98 a9       	ldd	r25, Y+48	; 0x30
    71c4:	9c a7       	std	Y+44, r25	; 0x2c
    71c6:	8b a7       	std	Y+43, r24	; 0x2b
    71c8:	8b a5       	ldd	r24, Y+43	; 0x2b
    71ca:	9c a5       	ldd	r25, Y+44	; 0x2c
    71cc:	01 97       	sbiw	r24, 0x01	; 1
    71ce:	f1 f7       	brne	.-4      	; 0x71cc <LCD_sendCommand+0x106>
    71d0:	9c a7       	std	Y+44, r25	; 0x2c
    71d2:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	DIO_SET_PIN_VALUE(LCD_E_PORT_ID,LCD_E_PIN_ID,STD_HIGH); /* Enable LCD E=1 */
    71d4:	81 e0       	ldi	r24, 0x01	; 1
    71d6:	62 e0       	ldi	r22, 0x02	; 2
    71d8:	41 e0       	ldi	r20, 0x01	; 1
    71da:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
    71de:	80 e0       	ldi	r24, 0x00	; 0
    71e0:	90 e0       	ldi	r25, 0x00	; 0
    71e2:	a0 e8       	ldi	r26, 0x80	; 128
    71e4:	bf e3       	ldi	r27, 0x3F	; 63
    71e6:	8f a3       	std	Y+39, r24	; 0x27
    71e8:	98 a7       	std	Y+40, r25	; 0x28
    71ea:	a9 a7       	std	Y+41, r26	; 0x29
    71ec:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    71ee:	6f a1       	ldd	r22, Y+39	; 0x27
    71f0:	78 a5       	ldd	r23, Y+40	; 0x28
    71f2:	89 a5       	ldd	r24, Y+41	; 0x29
    71f4:	9a a5       	ldd	r25, Y+42	; 0x2a
    71f6:	20 e0       	ldi	r18, 0x00	; 0
    71f8:	30 e0       	ldi	r19, 0x00	; 0
    71fa:	4a ef       	ldi	r20, 0xFA	; 250
    71fc:	54 e4       	ldi	r21, 0x44	; 68
    71fe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7202:	dc 01       	movw	r26, r24
    7204:	cb 01       	movw	r24, r22
    7206:	8b a3       	std	Y+35, r24	; 0x23
    7208:	9c a3       	std	Y+36, r25	; 0x24
    720a:	ad a3       	std	Y+37, r26	; 0x25
    720c:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    720e:	6b a1       	ldd	r22, Y+35	; 0x23
    7210:	7c a1       	ldd	r23, Y+36	; 0x24
    7212:	8d a1       	ldd	r24, Y+37	; 0x25
    7214:	9e a1       	ldd	r25, Y+38	; 0x26
    7216:	20 e0       	ldi	r18, 0x00	; 0
    7218:	30 e0       	ldi	r19, 0x00	; 0
    721a:	40 e8       	ldi	r20, 0x80	; 128
    721c:	5f e3       	ldi	r21, 0x3F	; 63
    721e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7222:	88 23       	and	r24, r24
    7224:	2c f4       	brge	.+10     	; 0x7230 <LCD_sendCommand+0x16a>
		__ticks = 1;
    7226:	81 e0       	ldi	r24, 0x01	; 1
    7228:	90 e0       	ldi	r25, 0x00	; 0
    722a:	9a a3       	std	Y+34, r25	; 0x22
    722c:	89 a3       	std	Y+33, r24	; 0x21
    722e:	3f c0       	rjmp	.+126    	; 0x72ae <LCD_sendCommand+0x1e8>
	else if (__tmp > 65535)
    7230:	6b a1       	ldd	r22, Y+35	; 0x23
    7232:	7c a1       	ldd	r23, Y+36	; 0x24
    7234:	8d a1       	ldd	r24, Y+37	; 0x25
    7236:	9e a1       	ldd	r25, Y+38	; 0x26
    7238:	20 e0       	ldi	r18, 0x00	; 0
    723a:	3f ef       	ldi	r19, 0xFF	; 255
    723c:	4f e7       	ldi	r20, 0x7F	; 127
    723e:	57 e4       	ldi	r21, 0x47	; 71
    7240:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7244:	18 16       	cp	r1, r24
    7246:	4c f5       	brge	.+82     	; 0x729a <LCD_sendCommand+0x1d4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7248:	6f a1       	ldd	r22, Y+39	; 0x27
    724a:	78 a5       	ldd	r23, Y+40	; 0x28
    724c:	89 a5       	ldd	r24, Y+41	; 0x29
    724e:	9a a5       	ldd	r25, Y+42	; 0x2a
    7250:	20 e0       	ldi	r18, 0x00	; 0
    7252:	30 e0       	ldi	r19, 0x00	; 0
    7254:	40 e2       	ldi	r20, 0x20	; 32
    7256:	51 e4       	ldi	r21, 0x41	; 65
    7258:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    725c:	dc 01       	movw	r26, r24
    725e:	cb 01       	movw	r24, r22
    7260:	bc 01       	movw	r22, r24
    7262:	cd 01       	movw	r24, r26
    7264:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7268:	dc 01       	movw	r26, r24
    726a:	cb 01       	movw	r24, r22
    726c:	9a a3       	std	Y+34, r25	; 0x22
    726e:	89 a3       	std	Y+33, r24	; 0x21
    7270:	0f c0       	rjmp	.+30     	; 0x7290 <LCD_sendCommand+0x1ca>
    7272:	88 ec       	ldi	r24, 0xC8	; 200
    7274:	90 e0       	ldi	r25, 0x00	; 0
    7276:	98 a3       	std	Y+32, r25	; 0x20
    7278:	8f 8f       	std	Y+31, r24	; 0x1f
    727a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    727c:	98 a1       	ldd	r25, Y+32	; 0x20
    727e:	01 97       	sbiw	r24, 0x01	; 1
    7280:	f1 f7       	brne	.-4      	; 0x727e <LCD_sendCommand+0x1b8>
    7282:	98 a3       	std	Y+32, r25	; 0x20
    7284:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7286:	89 a1       	ldd	r24, Y+33	; 0x21
    7288:	9a a1       	ldd	r25, Y+34	; 0x22
    728a:	01 97       	sbiw	r24, 0x01	; 1
    728c:	9a a3       	std	Y+34, r25	; 0x22
    728e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7290:	89 a1       	ldd	r24, Y+33	; 0x21
    7292:	9a a1       	ldd	r25, Y+34	; 0x22
    7294:	00 97       	sbiw	r24, 0x00	; 0
    7296:	69 f7       	brne	.-38     	; 0x7272 <LCD_sendCommand+0x1ac>
    7298:	14 c0       	rjmp	.+40     	; 0x72c2 <LCD_sendCommand+0x1fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    729a:	6b a1       	ldd	r22, Y+35	; 0x23
    729c:	7c a1       	ldd	r23, Y+36	; 0x24
    729e:	8d a1       	ldd	r24, Y+37	; 0x25
    72a0:	9e a1       	ldd	r25, Y+38	; 0x26
    72a2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    72a6:	dc 01       	movw	r26, r24
    72a8:	cb 01       	movw	r24, r22
    72aa:	9a a3       	std	Y+34, r25	; 0x22
    72ac:	89 a3       	std	Y+33, r24	; 0x21
    72ae:	89 a1       	ldd	r24, Y+33	; 0x21
    72b0:	9a a1       	ldd	r25, Y+34	; 0x22
    72b2:	9e 8f       	std	Y+30, r25	; 0x1e
    72b4:	8d 8f       	std	Y+29, r24	; 0x1d
    72b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    72b8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    72ba:	01 97       	sbiw	r24, 0x01	; 1
    72bc:	f1 f7       	brne	.-4      	; 0x72ba <LCD_sendCommand+0x1f4>
    72be:	9e 8f       	std	Y+30, r25	; 0x1e
    72c0:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */
	DIO_SET_PORT_VALUE(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
    72c2:	80 e0       	ldi	r24, 0x00	; 0
    72c4:	69 ad       	ldd	r22, Y+57	; 0x39
    72c6:	0e 94 ab 34 	call	0x6956	; 0x6956 <DIO_SET_PORT_VALUE>
    72ca:	80 e0       	ldi	r24, 0x00	; 0
    72cc:	90 e0       	ldi	r25, 0x00	; 0
    72ce:	a0 e8       	ldi	r26, 0x80	; 128
    72d0:	bf e3       	ldi	r27, 0x3F	; 63
    72d2:	89 8f       	std	Y+25, r24	; 0x19
    72d4:	9a 8f       	std	Y+26, r25	; 0x1a
    72d6:	ab 8f       	std	Y+27, r26	; 0x1b
    72d8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    72da:	69 8d       	ldd	r22, Y+25	; 0x19
    72dc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    72de:	8b 8d       	ldd	r24, Y+27	; 0x1b
    72e0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    72e2:	20 e0       	ldi	r18, 0x00	; 0
    72e4:	30 e0       	ldi	r19, 0x00	; 0
    72e6:	4a ef       	ldi	r20, 0xFA	; 250
    72e8:	54 e4       	ldi	r21, 0x44	; 68
    72ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    72ee:	dc 01       	movw	r26, r24
    72f0:	cb 01       	movw	r24, r22
    72f2:	8d 8b       	std	Y+21, r24	; 0x15
    72f4:	9e 8b       	std	Y+22, r25	; 0x16
    72f6:	af 8b       	std	Y+23, r26	; 0x17
    72f8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    72fa:	6d 89       	ldd	r22, Y+21	; 0x15
    72fc:	7e 89       	ldd	r23, Y+22	; 0x16
    72fe:	8f 89       	ldd	r24, Y+23	; 0x17
    7300:	98 8d       	ldd	r25, Y+24	; 0x18
    7302:	20 e0       	ldi	r18, 0x00	; 0
    7304:	30 e0       	ldi	r19, 0x00	; 0
    7306:	40 e8       	ldi	r20, 0x80	; 128
    7308:	5f e3       	ldi	r21, 0x3F	; 63
    730a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    730e:	88 23       	and	r24, r24
    7310:	2c f4       	brge	.+10     	; 0x731c <LCD_sendCommand+0x256>
		__ticks = 1;
    7312:	81 e0       	ldi	r24, 0x01	; 1
    7314:	90 e0       	ldi	r25, 0x00	; 0
    7316:	9c 8b       	std	Y+20, r25	; 0x14
    7318:	8b 8b       	std	Y+19, r24	; 0x13
    731a:	3f c0       	rjmp	.+126    	; 0x739a <LCD_sendCommand+0x2d4>
	else if (__tmp > 65535)
    731c:	6d 89       	ldd	r22, Y+21	; 0x15
    731e:	7e 89       	ldd	r23, Y+22	; 0x16
    7320:	8f 89       	ldd	r24, Y+23	; 0x17
    7322:	98 8d       	ldd	r25, Y+24	; 0x18
    7324:	20 e0       	ldi	r18, 0x00	; 0
    7326:	3f ef       	ldi	r19, 0xFF	; 255
    7328:	4f e7       	ldi	r20, 0x7F	; 127
    732a:	57 e4       	ldi	r21, 0x47	; 71
    732c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7330:	18 16       	cp	r1, r24
    7332:	4c f5       	brge	.+82     	; 0x7386 <LCD_sendCommand+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7334:	69 8d       	ldd	r22, Y+25	; 0x19
    7336:	7a 8d       	ldd	r23, Y+26	; 0x1a
    7338:	8b 8d       	ldd	r24, Y+27	; 0x1b
    733a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    733c:	20 e0       	ldi	r18, 0x00	; 0
    733e:	30 e0       	ldi	r19, 0x00	; 0
    7340:	40 e2       	ldi	r20, 0x20	; 32
    7342:	51 e4       	ldi	r21, 0x41	; 65
    7344:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7348:	dc 01       	movw	r26, r24
    734a:	cb 01       	movw	r24, r22
    734c:	bc 01       	movw	r22, r24
    734e:	cd 01       	movw	r24, r26
    7350:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7354:	dc 01       	movw	r26, r24
    7356:	cb 01       	movw	r24, r22
    7358:	9c 8b       	std	Y+20, r25	; 0x14
    735a:	8b 8b       	std	Y+19, r24	; 0x13
    735c:	0f c0       	rjmp	.+30     	; 0x737c <LCD_sendCommand+0x2b6>
    735e:	88 ec       	ldi	r24, 0xC8	; 200
    7360:	90 e0       	ldi	r25, 0x00	; 0
    7362:	9a 8b       	std	Y+18, r25	; 0x12
    7364:	89 8b       	std	Y+17, r24	; 0x11
    7366:	89 89       	ldd	r24, Y+17	; 0x11
    7368:	9a 89       	ldd	r25, Y+18	; 0x12
    736a:	01 97       	sbiw	r24, 0x01	; 1
    736c:	f1 f7       	brne	.-4      	; 0x736a <LCD_sendCommand+0x2a4>
    736e:	9a 8b       	std	Y+18, r25	; 0x12
    7370:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7372:	8b 89       	ldd	r24, Y+19	; 0x13
    7374:	9c 89       	ldd	r25, Y+20	; 0x14
    7376:	01 97       	sbiw	r24, 0x01	; 1
    7378:	9c 8b       	std	Y+20, r25	; 0x14
    737a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    737c:	8b 89       	ldd	r24, Y+19	; 0x13
    737e:	9c 89       	ldd	r25, Y+20	; 0x14
    7380:	00 97       	sbiw	r24, 0x00	; 0
    7382:	69 f7       	brne	.-38     	; 0x735e <LCD_sendCommand+0x298>
    7384:	14 c0       	rjmp	.+40     	; 0x73ae <LCD_sendCommand+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7386:	6d 89       	ldd	r22, Y+21	; 0x15
    7388:	7e 89       	ldd	r23, Y+22	; 0x16
    738a:	8f 89       	ldd	r24, Y+23	; 0x17
    738c:	98 8d       	ldd	r25, Y+24	; 0x18
    738e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7392:	dc 01       	movw	r26, r24
    7394:	cb 01       	movw	r24, r22
    7396:	9c 8b       	std	Y+20, r25	; 0x14
    7398:	8b 8b       	std	Y+19, r24	; 0x13
    739a:	8b 89       	ldd	r24, Y+19	; 0x13
    739c:	9c 89       	ldd	r25, Y+20	; 0x14
    739e:	98 8b       	std	Y+16, r25	; 0x10
    73a0:	8f 87       	std	Y+15, r24	; 0x0f
    73a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    73a4:	98 89       	ldd	r25, Y+16	; 0x10
    73a6:	01 97       	sbiw	r24, 0x01	; 1
    73a8:	f1 f7       	brne	.-4      	; 0x73a6 <LCD_sendCommand+0x2e0>
    73aa:	98 8b       	std	Y+16, r25	; 0x10
    73ac:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	DIO_SET_PIN_VALUE(LCD_E_PORT_ID,LCD_E_PIN_ID,STD_LOW); /* Disable LCD E=0 */
    73ae:	81 e0       	ldi	r24, 0x01	; 1
    73b0:	62 e0       	ldi	r22, 0x02	; 2
    73b2:	40 e0       	ldi	r20, 0x00	; 0
    73b4:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
    73b8:	80 e0       	ldi	r24, 0x00	; 0
    73ba:	90 e0       	ldi	r25, 0x00	; 0
    73bc:	a0 e8       	ldi	r26, 0x80	; 128
    73be:	bf e3       	ldi	r27, 0x3F	; 63
    73c0:	8b 87       	std	Y+11, r24	; 0x0b
    73c2:	9c 87       	std	Y+12, r25	; 0x0c
    73c4:	ad 87       	std	Y+13, r26	; 0x0d
    73c6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    73c8:	6b 85       	ldd	r22, Y+11	; 0x0b
    73ca:	7c 85       	ldd	r23, Y+12	; 0x0c
    73cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    73ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    73d0:	20 e0       	ldi	r18, 0x00	; 0
    73d2:	30 e0       	ldi	r19, 0x00	; 0
    73d4:	4a ef       	ldi	r20, 0xFA	; 250
    73d6:	54 e4       	ldi	r21, 0x44	; 68
    73d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    73dc:	dc 01       	movw	r26, r24
    73de:	cb 01       	movw	r24, r22
    73e0:	8f 83       	std	Y+7, r24	; 0x07
    73e2:	98 87       	std	Y+8, r25	; 0x08
    73e4:	a9 87       	std	Y+9, r26	; 0x09
    73e6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    73e8:	6f 81       	ldd	r22, Y+7	; 0x07
    73ea:	78 85       	ldd	r23, Y+8	; 0x08
    73ec:	89 85       	ldd	r24, Y+9	; 0x09
    73ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    73f0:	20 e0       	ldi	r18, 0x00	; 0
    73f2:	30 e0       	ldi	r19, 0x00	; 0
    73f4:	40 e8       	ldi	r20, 0x80	; 128
    73f6:	5f e3       	ldi	r21, 0x3F	; 63
    73f8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    73fc:	88 23       	and	r24, r24
    73fe:	2c f4       	brge	.+10     	; 0x740a <LCD_sendCommand+0x344>
		__ticks = 1;
    7400:	81 e0       	ldi	r24, 0x01	; 1
    7402:	90 e0       	ldi	r25, 0x00	; 0
    7404:	9e 83       	std	Y+6, r25	; 0x06
    7406:	8d 83       	std	Y+5, r24	; 0x05
    7408:	3f c0       	rjmp	.+126    	; 0x7488 <LCD_sendCommand+0x3c2>
	else if (__tmp > 65535)
    740a:	6f 81       	ldd	r22, Y+7	; 0x07
    740c:	78 85       	ldd	r23, Y+8	; 0x08
    740e:	89 85       	ldd	r24, Y+9	; 0x09
    7410:	9a 85       	ldd	r25, Y+10	; 0x0a
    7412:	20 e0       	ldi	r18, 0x00	; 0
    7414:	3f ef       	ldi	r19, 0xFF	; 255
    7416:	4f e7       	ldi	r20, 0x7F	; 127
    7418:	57 e4       	ldi	r21, 0x47	; 71
    741a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    741e:	18 16       	cp	r1, r24
    7420:	4c f5       	brge	.+82     	; 0x7474 <LCD_sendCommand+0x3ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7422:	6b 85       	ldd	r22, Y+11	; 0x0b
    7424:	7c 85       	ldd	r23, Y+12	; 0x0c
    7426:	8d 85       	ldd	r24, Y+13	; 0x0d
    7428:	9e 85       	ldd	r25, Y+14	; 0x0e
    742a:	20 e0       	ldi	r18, 0x00	; 0
    742c:	30 e0       	ldi	r19, 0x00	; 0
    742e:	40 e2       	ldi	r20, 0x20	; 32
    7430:	51 e4       	ldi	r21, 0x41	; 65
    7432:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7436:	dc 01       	movw	r26, r24
    7438:	cb 01       	movw	r24, r22
    743a:	bc 01       	movw	r22, r24
    743c:	cd 01       	movw	r24, r26
    743e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7442:	dc 01       	movw	r26, r24
    7444:	cb 01       	movw	r24, r22
    7446:	9e 83       	std	Y+6, r25	; 0x06
    7448:	8d 83       	std	Y+5, r24	; 0x05
    744a:	0f c0       	rjmp	.+30     	; 0x746a <LCD_sendCommand+0x3a4>
    744c:	88 ec       	ldi	r24, 0xC8	; 200
    744e:	90 e0       	ldi	r25, 0x00	; 0
    7450:	9c 83       	std	Y+4, r25	; 0x04
    7452:	8b 83       	std	Y+3, r24	; 0x03
    7454:	8b 81       	ldd	r24, Y+3	; 0x03
    7456:	9c 81       	ldd	r25, Y+4	; 0x04
    7458:	01 97       	sbiw	r24, 0x01	; 1
    745a:	f1 f7       	brne	.-4      	; 0x7458 <LCD_sendCommand+0x392>
    745c:	9c 83       	std	Y+4, r25	; 0x04
    745e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7460:	8d 81       	ldd	r24, Y+5	; 0x05
    7462:	9e 81       	ldd	r25, Y+6	; 0x06
    7464:	01 97       	sbiw	r24, 0x01	; 1
    7466:	9e 83       	std	Y+6, r25	; 0x06
    7468:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    746a:	8d 81       	ldd	r24, Y+5	; 0x05
    746c:	9e 81       	ldd	r25, Y+6	; 0x06
    746e:	00 97       	sbiw	r24, 0x00	; 0
    7470:	69 f7       	brne	.-38     	; 0x744c <LCD_sendCommand+0x386>
    7472:	14 c0       	rjmp	.+40     	; 0x749c <LCD_sendCommand+0x3d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7474:	6f 81       	ldd	r22, Y+7	; 0x07
    7476:	78 85       	ldd	r23, Y+8	; 0x08
    7478:	89 85       	ldd	r24, Y+9	; 0x09
    747a:	9a 85       	ldd	r25, Y+10	; 0x0a
    747c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7480:	dc 01       	movw	r26, r24
    7482:	cb 01       	movw	r24, r22
    7484:	9e 83       	std	Y+6, r25	; 0x06
    7486:	8d 83       	std	Y+5, r24	; 0x05
    7488:	8d 81       	ldd	r24, Y+5	; 0x05
    748a:	9e 81       	ldd	r25, Y+6	; 0x06
    748c:	9a 83       	std	Y+2, r25	; 0x02
    748e:	89 83       	std	Y+1, r24	; 0x01
    7490:	89 81       	ldd	r24, Y+1	; 0x01
    7492:	9a 81       	ldd	r25, Y+2	; 0x02
    7494:	01 97       	sbiw	r24, 0x01	; 1
    7496:	f1 f7       	brne	.-4      	; 0x7494 <LCD_sendCommand+0x3ce>
    7498:	9a 83       	std	Y+2, r25	; 0x02
    749a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
}
    749c:	e9 96       	adiw	r28, 0x39	; 57
    749e:	0f b6       	in	r0, 0x3f	; 63
    74a0:	f8 94       	cli
    74a2:	de bf       	out	0x3e, r29	; 62
    74a4:	0f be       	out	0x3f, r0	; 63
    74a6:	cd bf       	out	0x3d, r28	; 61
    74a8:	cf 91       	pop	r28
    74aa:	df 91       	pop	r29
    74ac:	08 95       	ret

000074ae <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    74ae:	df 93       	push	r29
    74b0:	cf 93       	push	r28
    74b2:	cd b7       	in	r28, 0x3d	; 61
    74b4:	de b7       	in	r29, 0x3e	; 62
    74b6:	e9 97       	sbiw	r28, 0x39	; 57
    74b8:	0f b6       	in	r0, 0x3f	; 63
    74ba:	f8 94       	cli
    74bc:	de bf       	out	0x3e, r29	; 62
    74be:	0f be       	out	0x3f, r0	; 63
    74c0:	cd bf       	out	0x3d, r28	; 61
    74c2:	89 af       	std	Y+57, r24	; 0x39
	DIO_SET_PIN_VALUE(LCD_RS_PORT_ID,LCD_RS_PIN_ID,STD_HIGH); /* Data Mode RS=1 */
    74c4:	81 e0       	ldi	r24, 0x01	; 1
    74c6:	60 e0       	ldi	r22, 0x00	; 0
    74c8:	41 e0       	ldi	r20, 0x01	; 1
    74ca:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
	DIO_SET_PIN_VALUE(LCD_RW_PORT_ID,LCD_RW_PIN_ID,STD_LOW); /* write data to LCD so RW=0 */
    74ce:	81 e0       	ldi	r24, 0x01	; 1
    74d0:	61 e0       	ldi	r22, 0x01	; 1
    74d2:	40 e0       	ldi	r20, 0x00	; 0
    74d4:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
    74d8:	80 e0       	ldi	r24, 0x00	; 0
    74da:	90 e0       	ldi	r25, 0x00	; 0
    74dc:	a0 e8       	ldi	r26, 0x80	; 128
    74de:	bf e3       	ldi	r27, 0x3F	; 63
    74e0:	8d ab       	std	Y+53, r24	; 0x35
    74e2:	9e ab       	std	Y+54, r25	; 0x36
    74e4:	af ab       	std	Y+55, r26	; 0x37
    74e6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    74e8:	6d a9       	ldd	r22, Y+53	; 0x35
    74ea:	7e a9       	ldd	r23, Y+54	; 0x36
    74ec:	8f a9       	ldd	r24, Y+55	; 0x37
    74ee:	98 ad       	ldd	r25, Y+56	; 0x38
    74f0:	20 e0       	ldi	r18, 0x00	; 0
    74f2:	30 e0       	ldi	r19, 0x00	; 0
    74f4:	4a ef       	ldi	r20, 0xFA	; 250
    74f6:	54 e4       	ldi	r21, 0x44	; 68
    74f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    74fc:	dc 01       	movw	r26, r24
    74fe:	cb 01       	movw	r24, r22
    7500:	89 ab       	std	Y+49, r24	; 0x31
    7502:	9a ab       	std	Y+50, r25	; 0x32
    7504:	ab ab       	std	Y+51, r26	; 0x33
    7506:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    7508:	69 a9       	ldd	r22, Y+49	; 0x31
    750a:	7a a9       	ldd	r23, Y+50	; 0x32
    750c:	8b a9       	ldd	r24, Y+51	; 0x33
    750e:	9c a9       	ldd	r25, Y+52	; 0x34
    7510:	20 e0       	ldi	r18, 0x00	; 0
    7512:	30 e0       	ldi	r19, 0x00	; 0
    7514:	40 e8       	ldi	r20, 0x80	; 128
    7516:	5f e3       	ldi	r21, 0x3F	; 63
    7518:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    751c:	88 23       	and	r24, r24
    751e:	2c f4       	brge	.+10     	; 0x752a <LCD_displayCharacter+0x7c>
		__ticks = 1;
    7520:	81 e0       	ldi	r24, 0x01	; 1
    7522:	90 e0       	ldi	r25, 0x00	; 0
    7524:	98 ab       	std	Y+48, r25	; 0x30
    7526:	8f a7       	std	Y+47, r24	; 0x2f
    7528:	3f c0       	rjmp	.+126    	; 0x75a8 <LCD_displayCharacter+0xfa>
	else if (__tmp > 65535)
    752a:	69 a9       	ldd	r22, Y+49	; 0x31
    752c:	7a a9       	ldd	r23, Y+50	; 0x32
    752e:	8b a9       	ldd	r24, Y+51	; 0x33
    7530:	9c a9       	ldd	r25, Y+52	; 0x34
    7532:	20 e0       	ldi	r18, 0x00	; 0
    7534:	3f ef       	ldi	r19, 0xFF	; 255
    7536:	4f e7       	ldi	r20, 0x7F	; 127
    7538:	57 e4       	ldi	r21, 0x47	; 71
    753a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    753e:	18 16       	cp	r1, r24
    7540:	4c f5       	brge	.+82     	; 0x7594 <LCD_displayCharacter+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7542:	6d a9       	ldd	r22, Y+53	; 0x35
    7544:	7e a9       	ldd	r23, Y+54	; 0x36
    7546:	8f a9       	ldd	r24, Y+55	; 0x37
    7548:	98 ad       	ldd	r25, Y+56	; 0x38
    754a:	20 e0       	ldi	r18, 0x00	; 0
    754c:	30 e0       	ldi	r19, 0x00	; 0
    754e:	40 e2       	ldi	r20, 0x20	; 32
    7550:	51 e4       	ldi	r21, 0x41	; 65
    7552:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7556:	dc 01       	movw	r26, r24
    7558:	cb 01       	movw	r24, r22
    755a:	bc 01       	movw	r22, r24
    755c:	cd 01       	movw	r24, r26
    755e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7562:	dc 01       	movw	r26, r24
    7564:	cb 01       	movw	r24, r22
    7566:	98 ab       	std	Y+48, r25	; 0x30
    7568:	8f a7       	std	Y+47, r24	; 0x2f
    756a:	0f c0       	rjmp	.+30     	; 0x758a <LCD_displayCharacter+0xdc>
    756c:	88 ec       	ldi	r24, 0xC8	; 200
    756e:	90 e0       	ldi	r25, 0x00	; 0
    7570:	9e a7       	std	Y+46, r25	; 0x2e
    7572:	8d a7       	std	Y+45, r24	; 0x2d
    7574:	8d a5       	ldd	r24, Y+45	; 0x2d
    7576:	9e a5       	ldd	r25, Y+46	; 0x2e
    7578:	01 97       	sbiw	r24, 0x01	; 1
    757a:	f1 f7       	brne	.-4      	; 0x7578 <LCD_displayCharacter+0xca>
    757c:	9e a7       	std	Y+46, r25	; 0x2e
    757e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7580:	8f a5       	ldd	r24, Y+47	; 0x2f
    7582:	98 a9       	ldd	r25, Y+48	; 0x30
    7584:	01 97       	sbiw	r24, 0x01	; 1
    7586:	98 ab       	std	Y+48, r25	; 0x30
    7588:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    758a:	8f a5       	ldd	r24, Y+47	; 0x2f
    758c:	98 a9       	ldd	r25, Y+48	; 0x30
    758e:	00 97       	sbiw	r24, 0x00	; 0
    7590:	69 f7       	brne	.-38     	; 0x756c <LCD_displayCharacter+0xbe>
    7592:	14 c0       	rjmp	.+40     	; 0x75bc <LCD_displayCharacter+0x10e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7594:	69 a9       	ldd	r22, Y+49	; 0x31
    7596:	7a a9       	ldd	r23, Y+50	; 0x32
    7598:	8b a9       	ldd	r24, Y+51	; 0x33
    759a:	9c a9       	ldd	r25, Y+52	; 0x34
    759c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    75a0:	dc 01       	movw	r26, r24
    75a2:	cb 01       	movw	r24, r22
    75a4:	98 ab       	std	Y+48, r25	; 0x30
    75a6:	8f a7       	std	Y+47, r24	; 0x2f
    75a8:	8f a5       	ldd	r24, Y+47	; 0x2f
    75aa:	98 a9       	ldd	r25, Y+48	; 0x30
    75ac:	9c a7       	std	Y+44, r25	; 0x2c
    75ae:	8b a7       	std	Y+43, r24	; 0x2b
    75b0:	8b a5       	ldd	r24, Y+43	; 0x2b
    75b2:	9c a5       	ldd	r25, Y+44	; 0x2c
    75b4:	01 97       	sbiw	r24, 0x01	; 1
    75b6:	f1 f7       	brne	.-4      	; 0x75b4 <LCD_displayCharacter+0x106>
    75b8:	9c a7       	std	Y+44, r25	; 0x2c
    75ba:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	DIO_SET_PIN_VALUE(LCD_E_PORT_ID,LCD_E_PIN_ID,STD_HIGH); /* Enable LCD E=1 */
    75bc:	81 e0       	ldi	r24, 0x01	; 1
    75be:	62 e0       	ldi	r22, 0x02	; 2
    75c0:	41 e0       	ldi	r20, 0x01	; 1
    75c2:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
    75c6:	80 e0       	ldi	r24, 0x00	; 0
    75c8:	90 e0       	ldi	r25, 0x00	; 0
    75ca:	a0 e8       	ldi	r26, 0x80	; 128
    75cc:	bf e3       	ldi	r27, 0x3F	; 63
    75ce:	8f a3       	std	Y+39, r24	; 0x27
    75d0:	98 a7       	std	Y+40, r25	; 0x28
    75d2:	a9 a7       	std	Y+41, r26	; 0x29
    75d4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    75d6:	6f a1       	ldd	r22, Y+39	; 0x27
    75d8:	78 a5       	ldd	r23, Y+40	; 0x28
    75da:	89 a5       	ldd	r24, Y+41	; 0x29
    75dc:	9a a5       	ldd	r25, Y+42	; 0x2a
    75de:	20 e0       	ldi	r18, 0x00	; 0
    75e0:	30 e0       	ldi	r19, 0x00	; 0
    75e2:	4a ef       	ldi	r20, 0xFA	; 250
    75e4:	54 e4       	ldi	r21, 0x44	; 68
    75e6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    75ea:	dc 01       	movw	r26, r24
    75ec:	cb 01       	movw	r24, r22
    75ee:	8b a3       	std	Y+35, r24	; 0x23
    75f0:	9c a3       	std	Y+36, r25	; 0x24
    75f2:	ad a3       	std	Y+37, r26	; 0x25
    75f4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    75f6:	6b a1       	ldd	r22, Y+35	; 0x23
    75f8:	7c a1       	ldd	r23, Y+36	; 0x24
    75fa:	8d a1       	ldd	r24, Y+37	; 0x25
    75fc:	9e a1       	ldd	r25, Y+38	; 0x26
    75fe:	20 e0       	ldi	r18, 0x00	; 0
    7600:	30 e0       	ldi	r19, 0x00	; 0
    7602:	40 e8       	ldi	r20, 0x80	; 128
    7604:	5f e3       	ldi	r21, 0x3F	; 63
    7606:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    760a:	88 23       	and	r24, r24
    760c:	2c f4       	brge	.+10     	; 0x7618 <LCD_displayCharacter+0x16a>
		__ticks = 1;
    760e:	81 e0       	ldi	r24, 0x01	; 1
    7610:	90 e0       	ldi	r25, 0x00	; 0
    7612:	9a a3       	std	Y+34, r25	; 0x22
    7614:	89 a3       	std	Y+33, r24	; 0x21
    7616:	3f c0       	rjmp	.+126    	; 0x7696 <LCD_displayCharacter+0x1e8>
	else if (__tmp > 65535)
    7618:	6b a1       	ldd	r22, Y+35	; 0x23
    761a:	7c a1       	ldd	r23, Y+36	; 0x24
    761c:	8d a1       	ldd	r24, Y+37	; 0x25
    761e:	9e a1       	ldd	r25, Y+38	; 0x26
    7620:	20 e0       	ldi	r18, 0x00	; 0
    7622:	3f ef       	ldi	r19, 0xFF	; 255
    7624:	4f e7       	ldi	r20, 0x7F	; 127
    7626:	57 e4       	ldi	r21, 0x47	; 71
    7628:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    762c:	18 16       	cp	r1, r24
    762e:	4c f5       	brge	.+82     	; 0x7682 <LCD_displayCharacter+0x1d4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7630:	6f a1       	ldd	r22, Y+39	; 0x27
    7632:	78 a5       	ldd	r23, Y+40	; 0x28
    7634:	89 a5       	ldd	r24, Y+41	; 0x29
    7636:	9a a5       	ldd	r25, Y+42	; 0x2a
    7638:	20 e0       	ldi	r18, 0x00	; 0
    763a:	30 e0       	ldi	r19, 0x00	; 0
    763c:	40 e2       	ldi	r20, 0x20	; 32
    763e:	51 e4       	ldi	r21, 0x41	; 65
    7640:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7644:	dc 01       	movw	r26, r24
    7646:	cb 01       	movw	r24, r22
    7648:	bc 01       	movw	r22, r24
    764a:	cd 01       	movw	r24, r26
    764c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7650:	dc 01       	movw	r26, r24
    7652:	cb 01       	movw	r24, r22
    7654:	9a a3       	std	Y+34, r25	; 0x22
    7656:	89 a3       	std	Y+33, r24	; 0x21
    7658:	0f c0       	rjmp	.+30     	; 0x7678 <LCD_displayCharacter+0x1ca>
    765a:	88 ec       	ldi	r24, 0xC8	; 200
    765c:	90 e0       	ldi	r25, 0x00	; 0
    765e:	98 a3       	std	Y+32, r25	; 0x20
    7660:	8f 8f       	std	Y+31, r24	; 0x1f
    7662:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7664:	98 a1       	ldd	r25, Y+32	; 0x20
    7666:	01 97       	sbiw	r24, 0x01	; 1
    7668:	f1 f7       	brne	.-4      	; 0x7666 <LCD_displayCharacter+0x1b8>
    766a:	98 a3       	std	Y+32, r25	; 0x20
    766c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    766e:	89 a1       	ldd	r24, Y+33	; 0x21
    7670:	9a a1       	ldd	r25, Y+34	; 0x22
    7672:	01 97       	sbiw	r24, 0x01	; 1
    7674:	9a a3       	std	Y+34, r25	; 0x22
    7676:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7678:	89 a1       	ldd	r24, Y+33	; 0x21
    767a:	9a a1       	ldd	r25, Y+34	; 0x22
    767c:	00 97       	sbiw	r24, 0x00	; 0
    767e:	69 f7       	brne	.-38     	; 0x765a <LCD_displayCharacter+0x1ac>
    7680:	14 c0       	rjmp	.+40     	; 0x76aa <LCD_displayCharacter+0x1fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7682:	6b a1       	ldd	r22, Y+35	; 0x23
    7684:	7c a1       	ldd	r23, Y+36	; 0x24
    7686:	8d a1       	ldd	r24, Y+37	; 0x25
    7688:	9e a1       	ldd	r25, Y+38	; 0x26
    768a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    768e:	dc 01       	movw	r26, r24
    7690:	cb 01       	movw	r24, r22
    7692:	9a a3       	std	Y+34, r25	; 0x22
    7694:	89 a3       	std	Y+33, r24	; 0x21
    7696:	89 a1       	ldd	r24, Y+33	; 0x21
    7698:	9a a1       	ldd	r25, Y+34	; 0x22
    769a:	9e 8f       	std	Y+30, r25	; 0x1e
    769c:	8d 8f       	std	Y+29, r24	; 0x1d
    769e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    76a0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    76a2:	01 97       	sbiw	r24, 0x01	; 1
    76a4:	f1 f7       	brne	.-4      	; 0x76a2 <LCD_displayCharacter+0x1f4>
    76a6:	9e 8f       	std	Y+30, r25	; 0x1e
    76a8:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */
	DIO_SET_PORT_VALUE(LCD_DATA_PORT_ID,data); /* out the required command to the data bus D0 --> D7 */
    76aa:	80 e0       	ldi	r24, 0x00	; 0
    76ac:	69 ad       	ldd	r22, Y+57	; 0x39
    76ae:	0e 94 ab 34 	call	0x6956	; 0x6956 <DIO_SET_PORT_VALUE>
    76b2:	80 e0       	ldi	r24, 0x00	; 0
    76b4:	90 e0       	ldi	r25, 0x00	; 0
    76b6:	a0 e8       	ldi	r26, 0x80	; 128
    76b8:	bf e3       	ldi	r27, 0x3F	; 63
    76ba:	89 8f       	std	Y+25, r24	; 0x19
    76bc:	9a 8f       	std	Y+26, r25	; 0x1a
    76be:	ab 8f       	std	Y+27, r26	; 0x1b
    76c0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    76c2:	69 8d       	ldd	r22, Y+25	; 0x19
    76c4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    76c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    76c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    76ca:	20 e0       	ldi	r18, 0x00	; 0
    76cc:	30 e0       	ldi	r19, 0x00	; 0
    76ce:	4a ef       	ldi	r20, 0xFA	; 250
    76d0:	54 e4       	ldi	r21, 0x44	; 68
    76d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    76d6:	dc 01       	movw	r26, r24
    76d8:	cb 01       	movw	r24, r22
    76da:	8d 8b       	std	Y+21, r24	; 0x15
    76dc:	9e 8b       	std	Y+22, r25	; 0x16
    76de:	af 8b       	std	Y+23, r26	; 0x17
    76e0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    76e2:	6d 89       	ldd	r22, Y+21	; 0x15
    76e4:	7e 89       	ldd	r23, Y+22	; 0x16
    76e6:	8f 89       	ldd	r24, Y+23	; 0x17
    76e8:	98 8d       	ldd	r25, Y+24	; 0x18
    76ea:	20 e0       	ldi	r18, 0x00	; 0
    76ec:	30 e0       	ldi	r19, 0x00	; 0
    76ee:	40 e8       	ldi	r20, 0x80	; 128
    76f0:	5f e3       	ldi	r21, 0x3F	; 63
    76f2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    76f6:	88 23       	and	r24, r24
    76f8:	2c f4       	brge	.+10     	; 0x7704 <LCD_displayCharacter+0x256>
		__ticks = 1;
    76fa:	81 e0       	ldi	r24, 0x01	; 1
    76fc:	90 e0       	ldi	r25, 0x00	; 0
    76fe:	9c 8b       	std	Y+20, r25	; 0x14
    7700:	8b 8b       	std	Y+19, r24	; 0x13
    7702:	3f c0       	rjmp	.+126    	; 0x7782 <LCD_displayCharacter+0x2d4>
	else if (__tmp > 65535)
    7704:	6d 89       	ldd	r22, Y+21	; 0x15
    7706:	7e 89       	ldd	r23, Y+22	; 0x16
    7708:	8f 89       	ldd	r24, Y+23	; 0x17
    770a:	98 8d       	ldd	r25, Y+24	; 0x18
    770c:	20 e0       	ldi	r18, 0x00	; 0
    770e:	3f ef       	ldi	r19, 0xFF	; 255
    7710:	4f e7       	ldi	r20, 0x7F	; 127
    7712:	57 e4       	ldi	r21, 0x47	; 71
    7714:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7718:	18 16       	cp	r1, r24
    771a:	4c f5       	brge	.+82     	; 0x776e <LCD_displayCharacter+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    771c:	69 8d       	ldd	r22, Y+25	; 0x19
    771e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    7720:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7722:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7724:	20 e0       	ldi	r18, 0x00	; 0
    7726:	30 e0       	ldi	r19, 0x00	; 0
    7728:	40 e2       	ldi	r20, 0x20	; 32
    772a:	51 e4       	ldi	r21, 0x41	; 65
    772c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7730:	dc 01       	movw	r26, r24
    7732:	cb 01       	movw	r24, r22
    7734:	bc 01       	movw	r22, r24
    7736:	cd 01       	movw	r24, r26
    7738:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    773c:	dc 01       	movw	r26, r24
    773e:	cb 01       	movw	r24, r22
    7740:	9c 8b       	std	Y+20, r25	; 0x14
    7742:	8b 8b       	std	Y+19, r24	; 0x13
    7744:	0f c0       	rjmp	.+30     	; 0x7764 <LCD_displayCharacter+0x2b6>
    7746:	88 ec       	ldi	r24, 0xC8	; 200
    7748:	90 e0       	ldi	r25, 0x00	; 0
    774a:	9a 8b       	std	Y+18, r25	; 0x12
    774c:	89 8b       	std	Y+17, r24	; 0x11
    774e:	89 89       	ldd	r24, Y+17	; 0x11
    7750:	9a 89       	ldd	r25, Y+18	; 0x12
    7752:	01 97       	sbiw	r24, 0x01	; 1
    7754:	f1 f7       	brne	.-4      	; 0x7752 <LCD_displayCharacter+0x2a4>
    7756:	9a 8b       	std	Y+18, r25	; 0x12
    7758:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    775a:	8b 89       	ldd	r24, Y+19	; 0x13
    775c:	9c 89       	ldd	r25, Y+20	; 0x14
    775e:	01 97       	sbiw	r24, 0x01	; 1
    7760:	9c 8b       	std	Y+20, r25	; 0x14
    7762:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7764:	8b 89       	ldd	r24, Y+19	; 0x13
    7766:	9c 89       	ldd	r25, Y+20	; 0x14
    7768:	00 97       	sbiw	r24, 0x00	; 0
    776a:	69 f7       	brne	.-38     	; 0x7746 <LCD_displayCharacter+0x298>
    776c:	14 c0       	rjmp	.+40     	; 0x7796 <LCD_displayCharacter+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    776e:	6d 89       	ldd	r22, Y+21	; 0x15
    7770:	7e 89       	ldd	r23, Y+22	; 0x16
    7772:	8f 89       	ldd	r24, Y+23	; 0x17
    7774:	98 8d       	ldd	r25, Y+24	; 0x18
    7776:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    777a:	dc 01       	movw	r26, r24
    777c:	cb 01       	movw	r24, r22
    777e:	9c 8b       	std	Y+20, r25	; 0x14
    7780:	8b 8b       	std	Y+19, r24	; 0x13
    7782:	8b 89       	ldd	r24, Y+19	; 0x13
    7784:	9c 89       	ldd	r25, Y+20	; 0x14
    7786:	98 8b       	std	Y+16, r25	; 0x10
    7788:	8f 87       	std	Y+15, r24	; 0x0f
    778a:	8f 85       	ldd	r24, Y+15	; 0x0f
    778c:	98 89       	ldd	r25, Y+16	; 0x10
    778e:	01 97       	sbiw	r24, 0x01	; 1
    7790:	f1 f7       	brne	.-4      	; 0x778e <LCD_displayCharacter+0x2e0>
    7792:	98 8b       	std	Y+16, r25	; 0x10
    7794:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	DIO_SET_PIN_VALUE(LCD_E_PORT_ID,LCD_E_PIN_ID,STD_LOW); /* Disable LCD E=0 */
    7796:	81 e0       	ldi	r24, 0x01	; 1
    7798:	62 e0       	ldi	r22, 0x02	; 2
    779a:	40 e0       	ldi	r20, 0x00	; 0
    779c:	0e 94 c8 33 	call	0x6790	; 0x6790 <DIO_SET_PIN_VALUE>
    77a0:	80 e0       	ldi	r24, 0x00	; 0
    77a2:	90 e0       	ldi	r25, 0x00	; 0
    77a4:	a0 e8       	ldi	r26, 0x80	; 128
    77a6:	bf e3       	ldi	r27, 0x3F	; 63
    77a8:	8b 87       	std	Y+11, r24	; 0x0b
    77aa:	9c 87       	std	Y+12, r25	; 0x0c
    77ac:	ad 87       	std	Y+13, r26	; 0x0d
    77ae:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    77b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    77b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    77b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    77b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    77b8:	20 e0       	ldi	r18, 0x00	; 0
    77ba:	30 e0       	ldi	r19, 0x00	; 0
    77bc:	4a ef       	ldi	r20, 0xFA	; 250
    77be:	54 e4       	ldi	r21, 0x44	; 68
    77c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    77c4:	dc 01       	movw	r26, r24
    77c6:	cb 01       	movw	r24, r22
    77c8:	8f 83       	std	Y+7, r24	; 0x07
    77ca:	98 87       	std	Y+8, r25	; 0x08
    77cc:	a9 87       	std	Y+9, r26	; 0x09
    77ce:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    77d0:	6f 81       	ldd	r22, Y+7	; 0x07
    77d2:	78 85       	ldd	r23, Y+8	; 0x08
    77d4:	89 85       	ldd	r24, Y+9	; 0x09
    77d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    77d8:	20 e0       	ldi	r18, 0x00	; 0
    77da:	30 e0       	ldi	r19, 0x00	; 0
    77dc:	40 e8       	ldi	r20, 0x80	; 128
    77de:	5f e3       	ldi	r21, 0x3F	; 63
    77e0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    77e4:	88 23       	and	r24, r24
    77e6:	2c f4       	brge	.+10     	; 0x77f2 <LCD_displayCharacter+0x344>
		__ticks = 1;
    77e8:	81 e0       	ldi	r24, 0x01	; 1
    77ea:	90 e0       	ldi	r25, 0x00	; 0
    77ec:	9e 83       	std	Y+6, r25	; 0x06
    77ee:	8d 83       	std	Y+5, r24	; 0x05
    77f0:	3f c0       	rjmp	.+126    	; 0x7870 <LCD_displayCharacter+0x3c2>
	else if (__tmp > 65535)
    77f2:	6f 81       	ldd	r22, Y+7	; 0x07
    77f4:	78 85       	ldd	r23, Y+8	; 0x08
    77f6:	89 85       	ldd	r24, Y+9	; 0x09
    77f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    77fa:	20 e0       	ldi	r18, 0x00	; 0
    77fc:	3f ef       	ldi	r19, 0xFF	; 255
    77fe:	4f e7       	ldi	r20, 0x7F	; 127
    7800:	57 e4       	ldi	r21, 0x47	; 71
    7802:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7806:	18 16       	cp	r1, r24
    7808:	4c f5       	brge	.+82     	; 0x785c <LCD_displayCharacter+0x3ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    780a:	6b 85       	ldd	r22, Y+11	; 0x0b
    780c:	7c 85       	ldd	r23, Y+12	; 0x0c
    780e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7810:	9e 85       	ldd	r25, Y+14	; 0x0e
    7812:	20 e0       	ldi	r18, 0x00	; 0
    7814:	30 e0       	ldi	r19, 0x00	; 0
    7816:	40 e2       	ldi	r20, 0x20	; 32
    7818:	51 e4       	ldi	r21, 0x41	; 65
    781a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    781e:	dc 01       	movw	r26, r24
    7820:	cb 01       	movw	r24, r22
    7822:	bc 01       	movw	r22, r24
    7824:	cd 01       	movw	r24, r26
    7826:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    782a:	dc 01       	movw	r26, r24
    782c:	cb 01       	movw	r24, r22
    782e:	9e 83       	std	Y+6, r25	; 0x06
    7830:	8d 83       	std	Y+5, r24	; 0x05
    7832:	0f c0       	rjmp	.+30     	; 0x7852 <LCD_displayCharacter+0x3a4>
    7834:	88 ec       	ldi	r24, 0xC8	; 200
    7836:	90 e0       	ldi	r25, 0x00	; 0
    7838:	9c 83       	std	Y+4, r25	; 0x04
    783a:	8b 83       	std	Y+3, r24	; 0x03
    783c:	8b 81       	ldd	r24, Y+3	; 0x03
    783e:	9c 81       	ldd	r25, Y+4	; 0x04
    7840:	01 97       	sbiw	r24, 0x01	; 1
    7842:	f1 f7       	brne	.-4      	; 0x7840 <LCD_displayCharacter+0x392>
    7844:	9c 83       	std	Y+4, r25	; 0x04
    7846:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7848:	8d 81       	ldd	r24, Y+5	; 0x05
    784a:	9e 81       	ldd	r25, Y+6	; 0x06
    784c:	01 97       	sbiw	r24, 0x01	; 1
    784e:	9e 83       	std	Y+6, r25	; 0x06
    7850:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7852:	8d 81       	ldd	r24, Y+5	; 0x05
    7854:	9e 81       	ldd	r25, Y+6	; 0x06
    7856:	00 97       	sbiw	r24, 0x00	; 0
    7858:	69 f7       	brne	.-38     	; 0x7834 <LCD_displayCharacter+0x386>
    785a:	14 c0       	rjmp	.+40     	; 0x7884 <LCD_displayCharacter+0x3d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    785c:	6f 81       	ldd	r22, Y+7	; 0x07
    785e:	78 85       	ldd	r23, Y+8	; 0x08
    7860:	89 85       	ldd	r24, Y+9	; 0x09
    7862:	9a 85       	ldd	r25, Y+10	; 0x0a
    7864:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7868:	dc 01       	movw	r26, r24
    786a:	cb 01       	movw	r24, r22
    786c:	9e 83       	std	Y+6, r25	; 0x06
    786e:	8d 83       	std	Y+5, r24	; 0x05
    7870:	8d 81       	ldd	r24, Y+5	; 0x05
    7872:	9e 81       	ldd	r25, Y+6	; 0x06
    7874:	9a 83       	std	Y+2, r25	; 0x02
    7876:	89 83       	std	Y+1, r24	; 0x01
    7878:	89 81       	ldd	r24, Y+1	; 0x01
    787a:	9a 81       	ldd	r25, Y+2	; 0x02
    787c:	01 97       	sbiw	r24, 0x01	; 1
    787e:	f1 f7       	brne	.-4      	; 0x787c <LCD_displayCharacter+0x3ce>
    7880:	9a 83       	std	Y+2, r25	; 0x02
    7882:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
}
    7884:	e9 96       	adiw	r28, 0x39	; 57
    7886:	0f b6       	in	r0, 0x3f	; 63
    7888:	f8 94       	cli
    788a:	de bf       	out	0x3e, r29	; 62
    788c:	0f be       	out	0x3f, r0	; 63
    788e:	cd bf       	out	0x3d, r28	; 61
    7890:	cf 91       	pop	r28
    7892:	df 91       	pop	r29
    7894:	08 95       	ret

00007896 <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    7896:	df 93       	push	r29
    7898:	cf 93       	push	r28
    789a:	00 d0       	rcall	.+0      	; 0x789c <LCD_displayString+0x6>
    789c:	0f 92       	push	r0
    789e:	cd b7       	in	r28, 0x3d	; 61
    78a0:	de b7       	in	r29, 0x3e	; 62
    78a2:	9b 83       	std	Y+3, r25	; 0x03
    78a4:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    78a6:	19 82       	std	Y+1, r1	; 0x01
    78a8:	0e c0       	rjmp	.+28     	; 0x78c6 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    78aa:	89 81       	ldd	r24, Y+1	; 0x01
    78ac:	28 2f       	mov	r18, r24
    78ae:	30 e0       	ldi	r19, 0x00	; 0
    78b0:	8a 81       	ldd	r24, Y+2	; 0x02
    78b2:	9b 81       	ldd	r25, Y+3	; 0x03
    78b4:	fc 01       	movw	r30, r24
    78b6:	e2 0f       	add	r30, r18
    78b8:	f3 1f       	adc	r31, r19
    78ba:	80 81       	ld	r24, Z
    78bc:	0e 94 57 3a 	call	0x74ae	; 0x74ae <LCD_displayCharacter>
		i++;
    78c0:	89 81       	ldd	r24, Y+1	; 0x01
    78c2:	8f 5f       	subi	r24, 0xFF	; 255
    78c4:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    78c6:	89 81       	ldd	r24, Y+1	; 0x01
    78c8:	28 2f       	mov	r18, r24
    78ca:	30 e0       	ldi	r19, 0x00	; 0
    78cc:	8a 81       	ldd	r24, Y+2	; 0x02
    78ce:	9b 81       	ldd	r25, Y+3	; 0x03
    78d0:	fc 01       	movw	r30, r24
    78d2:	e2 0f       	add	r30, r18
    78d4:	f3 1f       	adc	r31, r19
    78d6:	80 81       	ld	r24, Z
    78d8:	88 23       	and	r24, r24
    78da:	39 f7       	brne	.-50     	; 0x78aa <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	*********************************************************/
}
    78dc:	0f 90       	pop	r0
    78de:	0f 90       	pop	r0
    78e0:	0f 90       	pop	r0
    78e2:	cf 91       	pop	r28
    78e4:	df 91       	pop	r29
    78e6:	08 95       	ret

000078e8 <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    78e8:	df 93       	push	r29
    78ea:	cf 93       	push	r28
    78ec:	00 d0       	rcall	.+0      	; 0x78ee <LCD_moveCursor+0x6>
    78ee:	00 d0       	rcall	.+0      	; 0x78f0 <LCD_moveCursor+0x8>
    78f0:	0f 92       	push	r0
    78f2:	cd b7       	in	r28, 0x3d	; 61
    78f4:	de b7       	in	r29, 0x3e	; 62
    78f6:	8a 83       	std	Y+2, r24	; 0x02
    78f8:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;
	
	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    78fa:	8a 81       	ldd	r24, Y+2	; 0x02
    78fc:	28 2f       	mov	r18, r24
    78fe:	30 e0       	ldi	r19, 0x00	; 0
    7900:	3d 83       	std	Y+5, r19	; 0x05
    7902:	2c 83       	std	Y+4, r18	; 0x04
    7904:	8c 81       	ldd	r24, Y+4	; 0x04
    7906:	9d 81       	ldd	r25, Y+5	; 0x05
    7908:	81 30       	cpi	r24, 0x01	; 1
    790a:	91 05       	cpc	r25, r1
    790c:	c1 f0       	breq	.+48     	; 0x793e <LCD_moveCursor+0x56>
    790e:	2c 81       	ldd	r18, Y+4	; 0x04
    7910:	3d 81       	ldd	r19, Y+5	; 0x05
    7912:	22 30       	cpi	r18, 0x02	; 2
    7914:	31 05       	cpc	r19, r1
    7916:	2c f4       	brge	.+10     	; 0x7922 <LCD_moveCursor+0x3a>
    7918:	8c 81       	ldd	r24, Y+4	; 0x04
    791a:	9d 81       	ldd	r25, Y+5	; 0x05
    791c:	00 97       	sbiw	r24, 0x00	; 0
    791e:	61 f0       	breq	.+24     	; 0x7938 <LCD_moveCursor+0x50>
    7920:	19 c0       	rjmp	.+50     	; 0x7954 <LCD_moveCursor+0x6c>
    7922:	2c 81       	ldd	r18, Y+4	; 0x04
    7924:	3d 81       	ldd	r19, Y+5	; 0x05
    7926:	22 30       	cpi	r18, 0x02	; 2
    7928:	31 05       	cpc	r19, r1
    792a:	69 f0       	breq	.+26     	; 0x7946 <LCD_moveCursor+0x5e>
    792c:	8c 81       	ldd	r24, Y+4	; 0x04
    792e:	9d 81       	ldd	r25, Y+5	; 0x05
    7930:	83 30       	cpi	r24, 0x03	; 3
    7932:	91 05       	cpc	r25, r1
    7934:	61 f0       	breq	.+24     	; 0x794e <LCD_moveCursor+0x66>
    7936:	0e c0       	rjmp	.+28     	; 0x7954 <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    7938:	8b 81       	ldd	r24, Y+3	; 0x03
    793a:	89 83       	std	Y+1, r24	; 0x01
    793c:	0b c0       	rjmp	.+22     	; 0x7954 <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    793e:	8b 81       	ldd	r24, Y+3	; 0x03
    7940:	80 5c       	subi	r24, 0xC0	; 192
    7942:	89 83       	std	Y+1, r24	; 0x01
    7944:	07 c0       	rjmp	.+14     	; 0x7954 <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    7946:	8b 81       	ldd	r24, Y+3	; 0x03
    7948:	80 5f       	subi	r24, 0xF0	; 240
    794a:	89 83       	std	Y+1, r24	; 0x01
    794c:	03 c0       	rjmp	.+6      	; 0x7954 <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    794e:	8b 81       	ldd	r24, Y+3	; 0x03
    7950:	80 5b       	subi	r24, 0xB0	; 176
    7952:	89 83       	std	Y+1, r24	; 0x01
				break;
	}					
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    7954:	89 81       	ldd	r24, Y+1	; 0x01
    7956:	80 68       	ori	r24, 0x80	; 128
    7958:	0e 94 63 38 	call	0x70c6	; 0x70c6 <LCD_sendCommand>
}
    795c:	0f 90       	pop	r0
    795e:	0f 90       	pop	r0
    7960:	0f 90       	pop	r0
    7962:	0f 90       	pop	r0
    7964:	0f 90       	pop	r0
    7966:	cf 91       	pop	r28
    7968:	df 91       	pop	r29
    796a:	08 95       	ret

0000796c <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    796c:	df 93       	push	r29
    796e:	cf 93       	push	r28
    7970:	00 d0       	rcall	.+0      	; 0x7972 <LCD_displayStringRowColumn+0x6>
    7972:	00 d0       	rcall	.+0      	; 0x7974 <LCD_displayStringRowColumn+0x8>
    7974:	cd b7       	in	r28, 0x3d	; 61
    7976:	de b7       	in	r29, 0x3e	; 62
    7978:	89 83       	std	Y+1, r24	; 0x01
    797a:	6a 83       	std	Y+2, r22	; 0x02
    797c:	5c 83       	std	Y+4, r21	; 0x04
    797e:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    7980:	89 81       	ldd	r24, Y+1	; 0x01
    7982:	6a 81       	ldd	r22, Y+2	; 0x02
    7984:	0e 94 74 3c 	call	0x78e8	; 0x78e8 <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    7988:	8b 81       	ldd	r24, Y+3	; 0x03
    798a:	9c 81       	ldd	r25, Y+4	; 0x04
    798c:	0e 94 4b 3c 	call	0x7896	; 0x7896 <LCD_displayString>
}
    7990:	0f 90       	pop	r0
    7992:	0f 90       	pop	r0
    7994:	0f 90       	pop	r0
    7996:	0f 90       	pop	r0
    7998:	cf 91       	pop	r28
    799a:	df 91       	pop	r29
    799c:	08 95       	ret

0000799e <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
    799e:	df 93       	push	r29
    79a0:	cf 93       	push	r28
    79a2:	cd b7       	in	r28, 0x3d	; 61
    79a4:	de b7       	in	r29, 0x3e	; 62
    79a6:	62 97       	sbiw	r28, 0x12	; 18
    79a8:	0f b6       	in	r0, 0x3f	; 63
    79aa:	f8 94       	cli
    79ac:	de bf       	out	0x3e, r29	; 62
    79ae:	0f be       	out	0x3f, r0	; 63
    79b0:	cd bf       	out	0x3d, r28	; 61
    79b2:	9a 8b       	std	Y+18, r25	; 0x12
    79b4:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    79b6:	89 89       	ldd	r24, Y+17	; 0x11
    79b8:	9a 89       	ldd	r25, Y+18	; 0x12
    79ba:	9e 01       	movw	r18, r28
    79bc:	2f 5f       	subi	r18, 0xFF	; 255
    79be:	3f 4f       	sbci	r19, 0xFF	; 255
    79c0:	b9 01       	movw	r22, r18
    79c2:	4a e0       	ldi	r20, 0x0A	; 10
    79c4:	50 e0       	ldi	r21, 0x00	; 0
    79c6:	0e 94 f0 3d 	call	0x7be0	; 0x7be0 <itoa>
   LCD_displayString(buff); /* Display the string */
    79ca:	ce 01       	movw	r24, r28
    79cc:	01 96       	adiw	r24, 0x01	; 1
    79ce:	0e 94 4b 3c 	call	0x7896	; 0x7896 <LCD_displayString>
}
    79d2:	62 96       	adiw	r28, 0x12	; 18
    79d4:	0f b6       	in	r0, 0x3f	; 63
    79d6:	f8 94       	cli
    79d8:	de bf       	out	0x3e, r29	; 62
    79da:	0f be       	out	0x3f, r0	; 63
    79dc:	cd bf       	out	0x3d, r28	; 61
    79de:	cf 91       	pop	r28
    79e0:	df 91       	pop	r29
    79e2:	08 95       	ret

000079e4 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    79e4:	df 93       	push	r29
    79e6:	cf 93       	push	r28
    79e8:	cd b7       	in	r28, 0x3d	; 61
    79ea:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    79ec:	81 e0       	ldi	r24, 0x01	; 1
    79ee:	0e 94 63 38 	call	0x70c6	; 0x70c6 <LCD_sendCommand>
}
    79f2:	cf 91       	pop	r28
    79f4:	df 91       	pop	r29
    79f6:	08 95       	ret

000079f8 <Enable_Global_Interrupt>:

/*Enable Global Interrupt*/


void  Enable_Global_Interrupt(void)
{
    79f8:	df 93       	push	r29
    79fa:	cf 93       	push	r28
    79fc:	cd b7       	in	r28, 0x3d	; 61
    79fe:	de b7       	in	r29, 0x3e	; 62
	SREG |= (1<<7);
    7a00:	af e5       	ldi	r26, 0x5F	; 95
    7a02:	b0 e0       	ldi	r27, 0x00	; 0
    7a04:	ef e5       	ldi	r30, 0x5F	; 95
    7a06:	f0 e0       	ldi	r31, 0x00	; 0
    7a08:	80 81       	ld	r24, Z
    7a0a:	80 68       	ori	r24, 0x80	; 128
    7a0c:	8c 93       	st	X, r24
}
    7a0e:	cf 91       	pop	r28
    7a10:	df 91       	pop	r29
    7a12:	08 95       	ret

00007a14 <main>:

void ToggleLED1 (void);
void ToggleLED2 (void);

int main ()
{
    7a14:	ef 92       	push	r14
    7a16:	ff 92       	push	r15
    7a18:	0f 93       	push	r16
    7a1a:	df 93       	push	r29
    7a1c:	cf 93       	push	r28
    7a1e:	cd b7       	in	r28, 0x3d	; 61
    7a20:	de b7       	in	r29, 0x3e	; 62
	DIO_SET_PIN_DIREC(DIO_PORTA, DIO_PIN0, OUTPUT);
    7a22:	80 e0       	ldi	r24, 0x00	; 0
    7a24:	60 e0       	ldi	r22, 0x00	; 0
    7a26:	41 e0       	ldi	r20, 0x01	; 1
    7a28:	0e 94 e5 32 	call	0x65ca	; 0x65ca <DIO_SET_PIN_DIREC>
	DIO_SET_PIN_DIREC(DIO_PORTA, DIO_PIN5, OUTPUT);
    7a2c:	80 e0       	ldi	r24, 0x00	; 0
    7a2e:	65 e0       	ldi	r22, 0x05	; 5
    7a30:	41 e0       	ldi	r20, 0x01	; 1
    7a32:	0e 94 e5 32 	call	0x65ca	; 0x65ca <DIO_SET_PIN_DIREC>

	xTaskCreate(ToggleLED1, NULL, 85, NULL, 2, &xHandle1);
    7a36:	8a e3       	ldi	r24, 0x3A	; 58
    7a38:	9d e3       	ldi	r25, 0x3D	; 61
    7a3a:	e1 eb       	ldi	r30, 0xB1	; 177
    7a3c:	f6 e0       	ldi	r31, 0x06	; 6
    7a3e:	60 e0       	ldi	r22, 0x00	; 0
    7a40:	70 e0       	ldi	r23, 0x00	; 0
    7a42:	45 e5       	ldi	r20, 0x55	; 85
    7a44:	50 e0       	ldi	r21, 0x00	; 0
    7a46:	20 e0       	ldi	r18, 0x00	; 0
    7a48:	30 e0       	ldi	r19, 0x00	; 0
    7a4a:	02 e0       	ldi	r16, 0x02	; 2
    7a4c:	7f 01       	movw	r14, r30
    7a4e:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <xTaskCreate>
	xTaskCreate(ToggleLED2, NULL, 85, NULL, 1, &xHandle2);
    7a52:	87 e4       	ldi	r24, 0x47	; 71
    7a54:	9d e3       	ldi	r25, 0x3D	; 61
    7a56:	e3 eb       	ldi	r30, 0xB3	; 179
    7a58:	f6 e0       	ldi	r31, 0x06	; 6
    7a5a:	60 e0       	ldi	r22, 0x00	; 0
    7a5c:	70 e0       	ldi	r23, 0x00	; 0
    7a5e:	45 e5       	ldi	r20, 0x55	; 85
    7a60:	50 e0       	ldi	r21, 0x00	; 0
    7a62:	20 e0       	ldi	r18, 0x00	; 0
    7a64:	30 e0       	ldi	r19, 0x00	; 0
    7a66:	01 e0       	ldi	r16, 0x01	; 1
    7a68:	7f 01       	movw	r14, r30
    7a6a:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <xTaskCreate>
	vTaskStartScheduler();
    7a6e:	0e 94 9d 20 	call	0x413a	; 0x413a <vTaskStartScheduler>
    7a72:	ff cf       	rjmp	.-2      	; 0x7a72 <main+0x5e>

00007a74 <ToggleLED1>:

	}
}

void ToggleLED1 (void)
{
    7a74:	df 93       	push	r29
    7a76:	cf 93       	push	r28
    7a78:	cd b7       	in	r28, 0x3d	; 61
    7a7a:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		DIO_TOOGLE_PIN(DIO_PORTA, DIO_PIN0);
    7a7c:	80 e0       	ldi	r24, 0x00	; 0
    7a7e:	60 e0       	ldi	r22, 0x00	; 0
    7a80:	0e 94 ec 34 	call	0x69d8	; 0x69d8 <DIO_TOOGLE_PIN>
		vTaskDelay(1000);
    7a84:	88 ee       	ldi	r24, 0xE8	; 232
    7a86:	93 e0       	ldi	r25, 0x03	; 3
    7a88:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <vTaskDelay>
    7a8c:	f7 cf       	rjmp	.-18     	; 0x7a7c <ToggleLED1+0x8>

00007a8e <ToggleLED2>:
	}
}

void ToggleLED2 (void)
{
    7a8e:	df 93       	push	r29
    7a90:	cf 93       	push	r28
    7a92:	cd b7       	in	r28, 0x3d	; 61
    7a94:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		DIO_TOOGLE_PIN(DIO_PORTA, DIO_PIN5);
    7a96:	80 e0       	ldi	r24, 0x00	; 0
    7a98:	65 e0       	ldi	r22, 0x05	; 5
    7a9a:	0e 94 ec 34 	call	0x69d8	; 0x69d8 <DIO_TOOGLE_PIN>
		vTaskDelay(500);
    7a9e:	84 ef       	ldi	r24, 0xF4	; 244
    7aa0:	91 e0       	ldi	r25, 0x01	; 1
    7aa2:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <vTaskDelay>
    7aa6:	f7 cf       	rjmp	.-18     	; 0x7a96 <ToggleLED2+0x8>

00007aa8 <__mulsi3>:
    7aa8:	62 9f       	mul	r22, r18
    7aaa:	d0 01       	movw	r26, r0
    7aac:	73 9f       	mul	r23, r19
    7aae:	f0 01       	movw	r30, r0
    7ab0:	82 9f       	mul	r24, r18
    7ab2:	e0 0d       	add	r30, r0
    7ab4:	f1 1d       	adc	r31, r1
    7ab6:	64 9f       	mul	r22, r20
    7ab8:	e0 0d       	add	r30, r0
    7aba:	f1 1d       	adc	r31, r1
    7abc:	92 9f       	mul	r25, r18
    7abe:	f0 0d       	add	r31, r0
    7ac0:	83 9f       	mul	r24, r19
    7ac2:	f0 0d       	add	r31, r0
    7ac4:	74 9f       	mul	r23, r20
    7ac6:	f0 0d       	add	r31, r0
    7ac8:	65 9f       	mul	r22, r21
    7aca:	f0 0d       	add	r31, r0
    7acc:	99 27       	eor	r25, r25
    7ace:	72 9f       	mul	r23, r18
    7ad0:	b0 0d       	add	r27, r0
    7ad2:	e1 1d       	adc	r30, r1
    7ad4:	f9 1f       	adc	r31, r25
    7ad6:	63 9f       	mul	r22, r19
    7ad8:	b0 0d       	add	r27, r0
    7ada:	e1 1d       	adc	r30, r1
    7adc:	f9 1f       	adc	r31, r25
    7ade:	bd 01       	movw	r22, r26
    7ae0:	cf 01       	movw	r24, r30
    7ae2:	11 24       	eor	r1, r1
    7ae4:	08 95       	ret

00007ae6 <__udivmodhi4>:
    7ae6:	aa 1b       	sub	r26, r26
    7ae8:	bb 1b       	sub	r27, r27
    7aea:	51 e1       	ldi	r21, 0x11	; 17
    7aec:	07 c0       	rjmp	.+14     	; 0x7afc <__udivmodhi4_ep>

00007aee <__udivmodhi4_loop>:
    7aee:	aa 1f       	adc	r26, r26
    7af0:	bb 1f       	adc	r27, r27
    7af2:	a6 17       	cp	r26, r22
    7af4:	b7 07       	cpc	r27, r23
    7af6:	10 f0       	brcs	.+4      	; 0x7afc <__udivmodhi4_ep>
    7af8:	a6 1b       	sub	r26, r22
    7afa:	b7 0b       	sbc	r27, r23

00007afc <__udivmodhi4_ep>:
    7afc:	88 1f       	adc	r24, r24
    7afe:	99 1f       	adc	r25, r25
    7b00:	5a 95       	dec	r21
    7b02:	a9 f7       	brne	.-22     	; 0x7aee <__udivmodhi4_loop>
    7b04:	80 95       	com	r24
    7b06:	90 95       	com	r25
    7b08:	bc 01       	movw	r22, r24
    7b0a:	cd 01       	movw	r24, r26
    7b0c:	08 95       	ret

00007b0e <__udivmodsi4>:
    7b0e:	a1 e2       	ldi	r26, 0x21	; 33
    7b10:	1a 2e       	mov	r1, r26
    7b12:	aa 1b       	sub	r26, r26
    7b14:	bb 1b       	sub	r27, r27
    7b16:	fd 01       	movw	r30, r26
    7b18:	0d c0       	rjmp	.+26     	; 0x7b34 <__udivmodsi4_ep>

00007b1a <__udivmodsi4_loop>:
    7b1a:	aa 1f       	adc	r26, r26
    7b1c:	bb 1f       	adc	r27, r27
    7b1e:	ee 1f       	adc	r30, r30
    7b20:	ff 1f       	adc	r31, r31
    7b22:	a2 17       	cp	r26, r18
    7b24:	b3 07       	cpc	r27, r19
    7b26:	e4 07       	cpc	r30, r20
    7b28:	f5 07       	cpc	r31, r21
    7b2a:	20 f0       	brcs	.+8      	; 0x7b34 <__udivmodsi4_ep>
    7b2c:	a2 1b       	sub	r26, r18
    7b2e:	b3 0b       	sbc	r27, r19
    7b30:	e4 0b       	sbc	r30, r20
    7b32:	f5 0b       	sbc	r31, r21

00007b34 <__udivmodsi4_ep>:
    7b34:	66 1f       	adc	r22, r22
    7b36:	77 1f       	adc	r23, r23
    7b38:	88 1f       	adc	r24, r24
    7b3a:	99 1f       	adc	r25, r25
    7b3c:	1a 94       	dec	r1
    7b3e:	69 f7       	brne	.-38     	; 0x7b1a <__udivmodsi4_loop>
    7b40:	60 95       	com	r22
    7b42:	70 95       	com	r23
    7b44:	80 95       	com	r24
    7b46:	90 95       	com	r25
    7b48:	9b 01       	movw	r18, r22
    7b4a:	ac 01       	movw	r20, r24
    7b4c:	bd 01       	movw	r22, r26
    7b4e:	cf 01       	movw	r24, r30
    7b50:	08 95       	ret

00007b52 <__prologue_saves__>:
    7b52:	2f 92       	push	r2
    7b54:	3f 92       	push	r3
    7b56:	4f 92       	push	r4
    7b58:	5f 92       	push	r5
    7b5a:	6f 92       	push	r6
    7b5c:	7f 92       	push	r7
    7b5e:	8f 92       	push	r8
    7b60:	9f 92       	push	r9
    7b62:	af 92       	push	r10
    7b64:	bf 92       	push	r11
    7b66:	cf 92       	push	r12
    7b68:	df 92       	push	r13
    7b6a:	ef 92       	push	r14
    7b6c:	ff 92       	push	r15
    7b6e:	0f 93       	push	r16
    7b70:	1f 93       	push	r17
    7b72:	cf 93       	push	r28
    7b74:	df 93       	push	r29
    7b76:	cd b7       	in	r28, 0x3d	; 61
    7b78:	de b7       	in	r29, 0x3e	; 62
    7b7a:	ca 1b       	sub	r28, r26
    7b7c:	db 0b       	sbc	r29, r27
    7b7e:	0f b6       	in	r0, 0x3f	; 63
    7b80:	f8 94       	cli
    7b82:	de bf       	out	0x3e, r29	; 62
    7b84:	0f be       	out	0x3f, r0	; 63
    7b86:	cd bf       	out	0x3d, r28	; 61
    7b88:	09 94       	ijmp

00007b8a <__epilogue_restores__>:
    7b8a:	2a 88       	ldd	r2, Y+18	; 0x12
    7b8c:	39 88       	ldd	r3, Y+17	; 0x11
    7b8e:	48 88       	ldd	r4, Y+16	; 0x10
    7b90:	5f 84       	ldd	r5, Y+15	; 0x0f
    7b92:	6e 84       	ldd	r6, Y+14	; 0x0e
    7b94:	7d 84       	ldd	r7, Y+13	; 0x0d
    7b96:	8c 84       	ldd	r8, Y+12	; 0x0c
    7b98:	9b 84       	ldd	r9, Y+11	; 0x0b
    7b9a:	aa 84       	ldd	r10, Y+10	; 0x0a
    7b9c:	b9 84       	ldd	r11, Y+9	; 0x09
    7b9e:	c8 84       	ldd	r12, Y+8	; 0x08
    7ba0:	df 80       	ldd	r13, Y+7	; 0x07
    7ba2:	ee 80       	ldd	r14, Y+6	; 0x06
    7ba4:	fd 80       	ldd	r15, Y+5	; 0x05
    7ba6:	0c 81       	ldd	r16, Y+4	; 0x04
    7ba8:	1b 81       	ldd	r17, Y+3	; 0x03
    7baa:	aa 81       	ldd	r26, Y+2	; 0x02
    7bac:	b9 81       	ldd	r27, Y+1	; 0x01
    7bae:	ce 0f       	add	r28, r30
    7bb0:	d1 1d       	adc	r29, r1
    7bb2:	0f b6       	in	r0, 0x3f	; 63
    7bb4:	f8 94       	cli
    7bb6:	de bf       	out	0x3e, r29	; 62
    7bb8:	0f be       	out	0x3f, r0	; 63
    7bba:	cd bf       	out	0x3d, r28	; 61
    7bbc:	ed 01       	movw	r28, r26
    7bbe:	08 95       	ret

00007bc0 <memcpy>:
    7bc0:	fb 01       	movw	r30, r22
    7bc2:	dc 01       	movw	r26, r24
    7bc4:	02 c0       	rjmp	.+4      	; 0x7bca <memcpy+0xa>
    7bc6:	01 90       	ld	r0, Z+
    7bc8:	0d 92       	st	X+, r0
    7bca:	41 50       	subi	r20, 0x01	; 1
    7bcc:	50 40       	sbci	r21, 0x00	; 0
    7bce:	d8 f7       	brcc	.-10     	; 0x7bc6 <memcpy+0x6>
    7bd0:	08 95       	ret

00007bd2 <memset>:
    7bd2:	dc 01       	movw	r26, r24
    7bd4:	01 c0       	rjmp	.+2      	; 0x7bd8 <memset+0x6>
    7bd6:	6d 93       	st	X+, r22
    7bd8:	41 50       	subi	r20, 0x01	; 1
    7bda:	50 40       	sbci	r21, 0x00	; 0
    7bdc:	e0 f7       	brcc	.-8      	; 0x7bd6 <memset+0x4>
    7bde:	08 95       	ret

00007be0 <itoa>:
    7be0:	fb 01       	movw	r30, r22
    7be2:	9f 01       	movw	r18, r30
    7be4:	e8 94       	clt
    7be6:	42 30       	cpi	r20, 0x02	; 2
    7be8:	c4 f0       	brlt	.+48     	; 0x7c1a <itoa+0x3a>
    7bea:	45 32       	cpi	r20, 0x25	; 37
    7bec:	b4 f4       	brge	.+44     	; 0x7c1a <itoa+0x3a>
    7bee:	4a 30       	cpi	r20, 0x0A	; 10
    7bf0:	29 f4       	brne	.+10     	; 0x7bfc <itoa+0x1c>
    7bf2:	97 fb       	bst	r25, 7
    7bf4:	1e f4       	brtc	.+6      	; 0x7bfc <itoa+0x1c>
    7bf6:	90 95       	com	r25
    7bf8:	81 95       	neg	r24
    7bfa:	9f 4f       	sbci	r25, 0xFF	; 255
    7bfc:	64 2f       	mov	r22, r20
    7bfe:	77 27       	eor	r23, r23
    7c00:	0e 94 73 3d 	call	0x7ae6	; 0x7ae6 <__udivmodhi4>
    7c04:	80 5d       	subi	r24, 0xD0	; 208
    7c06:	8a 33       	cpi	r24, 0x3A	; 58
    7c08:	0c f0       	brlt	.+2      	; 0x7c0c <itoa+0x2c>
    7c0a:	89 5d       	subi	r24, 0xD9	; 217
    7c0c:	81 93       	st	Z+, r24
    7c0e:	cb 01       	movw	r24, r22
    7c10:	00 97       	sbiw	r24, 0x00	; 0
    7c12:	a1 f7       	brne	.-24     	; 0x7bfc <itoa+0x1c>
    7c14:	16 f4       	brtc	.+4      	; 0x7c1a <itoa+0x3a>
    7c16:	5d e2       	ldi	r21, 0x2D	; 45
    7c18:	51 93       	st	Z+, r21
    7c1a:	10 82       	st	Z, r1
    7c1c:	c9 01       	movw	r24, r18
    7c1e:	0c 94 11 3e 	jmp	0x7c22	; 0x7c22 <strrev>

00007c22 <strrev>:
    7c22:	dc 01       	movw	r26, r24
    7c24:	fc 01       	movw	r30, r24
    7c26:	67 2f       	mov	r22, r23
    7c28:	71 91       	ld	r23, Z+
    7c2a:	77 23       	and	r23, r23
    7c2c:	e1 f7       	brne	.-8      	; 0x7c26 <strrev+0x4>
    7c2e:	32 97       	sbiw	r30, 0x02	; 2
    7c30:	04 c0       	rjmp	.+8      	; 0x7c3a <strrev+0x18>
    7c32:	7c 91       	ld	r23, X
    7c34:	6d 93       	st	X+, r22
    7c36:	70 83       	st	Z, r23
    7c38:	62 91       	ld	r22, -Z
    7c3a:	ae 17       	cp	r26, r30
    7c3c:	bf 07       	cpc	r27, r31
    7c3e:	c8 f3       	brcs	.-14     	; 0x7c32 <strrev+0x10>
    7c40:	08 95       	ret

00007c42 <_exit>:
    7c42:	f8 94       	cli

00007c44 <__stop_program>:
    7c44:	ff cf       	rjmp	.-2      	; 0x7c44 <__stop_program>
